/*!
 * @license Copyright (c) 2003-2022, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */
!(function (t) {
	const e = (t.en = t.en || {});
	e.dictionary = Object.assign(e.dictionary || {}, {
		"%0 of %1": "%0 of %1",
		Aquamarine: "Aquamarine",
		Black: "Black",
		"Block quote": "Block quote",
		Blue: "Blue",
		Bold: "Bold",
		"Bulleted List": "Bulleted List",
		"Bulleted list styles toolbar": "Bulleted list styles toolbar",
		Cancel: "Cancel",
		"Caption for image: %0": "Caption for image: %0",
		"Caption for the image": "Caption for the image",
		"Change image text alternative": "Change image text alternative",
		"Choose heading": "Choose heading",
		Circle: "Circle",
		Code: "Code",
		Decimal: "Decimal",
		"Decimal with leading zero": "Decimal with leading zero",
		"Decrease indent": "Decrease indent",
		"Dim grey": "Dim grey",
		Disc: "Disc",
		Downloadable: "Downloadable",
		"Dropdown toolbar": "Dropdown toolbar",
		"Edit block": "Edit block",
		"Edit link": "Edit link",
		"Editor block content toolbar": "Editor block content toolbar",
		"Editor contextual toolbar": "Editor contextual toolbar",
		"Editor editing area: %0": "Editor editing area: %0",
		"Editor toolbar": "Editor toolbar",
		"Enter image caption": "Enter image caption",
		Green: "Green",
		Grey: "Grey",
		Heading: "Heading",
		"Heading 1": "Heading 1",
		"Heading 2": "Heading 2",
		"Heading 3": "Heading 3",
		"Heading 4": "Heading 4",
		"Heading 5": "Heading 5",
		"Heading 6": "Heading 6",
		"Horizontal line": "Horizontal line",
		"Image toolbar": "Image toolbar",
		"image widget": "image widget",
		"Increase indent": "Increase indent",
		"Insert code block": "Insert code block",
		"Insert paragraph after block": "Insert paragraph after block",
		"Insert paragraph before block": "Insert paragraph before block",
		Italic: "Italic",
		"Light blue": "Light blue",
		"Light green": "Light green",
		"Light grey": "Light grey",
		Link: "Link",
		"Link URL": "Link URL",
		"List properties": "List properties",
		"Lower-latin": "Lower-latin",
		"Lower–roman": "Lower–roman",
		Next: "Next",
		"Numbered List": "Numbered List",
		"Numbered list styles toolbar": "Numbered list styles toolbar",
		"Open in a new tab": "Open in a new tab",
		"Open link in new tab": "Open link in new tab",
		Orange: "Orange",
		Paragraph: "Paragraph",
		"Plain text": "Plain text",
		Previous: "Previous",
		Purple: "Purple",
		Red: "Red",
		Redo: "Redo",
		"Remove Format": "Remove Format",
		"Reversed order": "Reversed order",
		"Rich Text Editor": "Rich Text Editor",
		"Rich Text Editor. Editing area: %0": "Rich Text Editor. Editing area: %0",
		Save: "Save",
		"Select all": "Select all",
		"Show more items": "Show more items",
		Source: "Source",
		Square: "Square",
		"Start at": "Start at",
		"Start index must be greater than 0.":
			"Start index must be greater than 0.",
		Strikethrough: "Strikethrough",
		"Text alternative": "Text alternative",
		"This link has no URL": "This link has no URL",
		"To-do List": "To-do List",
		"Toggle the circle list style": "Toggle the circle list style",
		"Toggle the decimal list style": "Toggle the decimal list style",
		"Toggle the decimal with leading zero list style":
			"Toggle the decimal with leading zero list style",
		"Toggle the disc list style": "Toggle the disc list style",
		"Toggle the lower–latin list style": "Toggle the lower–latin list style",
		"Toggle the lower–roman list style": "Toggle the lower–roman list style",
		"Toggle the square list style": "Toggle the square list style",
		"Toggle the upper–latin list style": "Toggle the upper–latin list style",
		"Toggle the upper–roman list style": "Toggle the upper–roman list style",
		Turquoise: "Turquoise",
		Underline: "Underline",
		Undo: "Undo",
		Unlink: "Unlink",
		"Upper-latin": "Upper-latin",
		"Upper-roman": "Upper-roman",
		White: "White",
		"Widget toolbar": "Widget toolbar",
		Yellow: "Yellow",
	});
})(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {})),
	(function (t, e) {
		"object" == typeof exports && "object" == typeof module
			? (module.exports = e())
			: "function" == typeof define && define.amd
				? define([], e)
				: "object" == typeof exports
					? (exports.BalloonEditor = e())
					: (t.BalloonEditor = e());
	})(window, function () {
		return (function (t) {
			var e = {};
			function n(o) {
				if (e[o]) return e[o].exports;
				var i = (e[o] = { i: o, l: !1, exports: {} });
				return t[o].call(i.exports, i, i.exports, n), (i.l = !0), i.exports;
			}
			return (
				(n.m = t),
				(n.c = e),
				(n.d = function (t, e, o) {
					n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: o });
				}),
				(n.r = function (t) {
					"undefined" != typeof Symbol &&
						Symbol.toStringTag &&
						Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
						Object.defineProperty(t, "__esModule", { value: !0 });
				}),
				(n.t = function (t, e) {
					if ((1 & e && (t = n(t)), 8 & e)) return t;
					if (4 & e && "object" == typeof t && t && t.__esModule) return t;
					var o = Object.create(null);
					if (
						(n.r(o),
						Object.defineProperty(o, "default", { enumerable: !0, value: t }),
						2 & e && "string" != typeof t)
					)
						for (var i in t)
							n.d(
								o,
								i,
								function (e) {
									return t[e];
								}.bind(null, i),
							);
					return o;
				}),
				(n.n = function (t) {
					var e =
						t && t.__esModule
							? function () {
									return t.default;
								}
							: function () {
									return t;
								};
					return n.d(e, "a", e), e;
				}),
				(n.o = function (t, e) {
					return Object.prototype.hasOwnProperty.call(t, e);
				}),
				(n.p = ""),
				n((n.s = 65))
			);
		})([
			function (t, e, n) {
				"use strict";
				n.d(e, "a", function () {
					return o;
				}),
					n.d(e, "b", function () {
						return i;
					});
				class o extends Error {
					constructor(t, e, n) {
						super(
							(function (t, e) {
								const n = new WeakSet(),
									o = (t, e) => {
										if ("object" == typeof e && null !== e) {
											if (n.has(e)) return `[object ${e.constructor.name}]`;
											n.add(e);
										}
										return e;
									},
									i = e ? ` ${JSON.stringify(e, o)}` : "",
									s = r(t);
								return t + i + s;
							})(t, n),
						),
							(this.name = "CKEditorError"),
							(this.context = e),
							(this.data = n);
					}
					is(t) {
						return "CKEditorError" === t;
					}
					static rethrowUnexpectedError(t, e) {
						if (t.is && t.is("CKEditorError")) throw t;
						const n = new o(t.message, e);
						throw ((n.stack = t.stack), n);
					}
				}
				function i(t, e) {
					console.warn(...s(t, e));
				}
				function r(t) {
					return `\nRead more: https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html#error-${t}`;
				}
				function s(t, e) {
					const n = r(t);
					return e ? [t, e, n] : [t, n];
				}
			},
			function (t, e, n) {
				"use strict";
				var o,
					i = function () {
						return (
							void 0 === o &&
								(o = Boolean(
									window && document && document.all && !window.atob,
								)),
							o
						);
					},
					r = (function () {
						var t = {};
						return function (e) {
							if (void 0 === t[e]) {
								var n = document.querySelector(e);
								if (
									window.HTMLIFrameElement &&
									n instanceof window.HTMLIFrameElement
								)
									try {
										n = n.contentDocument.head;
									} catch (t) {
										n = null;
									}
								t[e] = n;
							}
							return t[e];
						};
					})(),
					s = [];
				function a(t) {
					for (var e = -1, n = 0; n < s.length; n++)
						if (s[n].identifier === t) {
							e = n;
							break;
						}
					return e;
				}
				function c(t, e) {
					for (var n = {}, o = [], i = 0; i < t.length; i++) {
						var r = t[i],
							c = e.base ? r[0] + e.base : r[0],
							l = n[c] || 0,
							d = "".concat(c, " ").concat(l);
						n[c] = l + 1;
						var u = a(d),
							h = { css: r[1], media: r[2], sourceMap: r[3] };
						-1 !== u
							? (s[u].references++, s[u].updater(h))
							: s.push({ identifier: d, updater: m(h, e), references: 1 }),
							o.push(d);
					}
					return o;
				}
				function l(t) {
					var e = document.createElement("style"),
						o = t.attributes || {};
					if (void 0 === o.nonce) {
						var i = n.nc;
						i && (o.nonce = i);
					}
					if (
						(Object.keys(o).forEach(function (t) {
							e.setAttribute(t, o[t]);
						}),
						"function" == typeof t.insert)
					)
						t.insert(e);
					else {
						var s = r(t.insert || "head");
						if (!s)
							throw new Error(
								"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.",
							);
						s.appendChild(e);
					}
					return e;
				}
				var d,
					u =
						((d = []),
						function (t, e) {
							return (d[t] = e), d.filter(Boolean).join("\n");
						});
				function h(t, e, n, o) {
					var i = n
						? ""
						: o.media
							? "@media ".concat(o.media, " {").concat(o.css, "}")
							: o.css;
					if (t.styleSheet) t.styleSheet.cssText = u(e, i);
					else {
						var r = document.createTextNode(i),
							s = t.childNodes;
						s[e] && t.removeChild(s[e]),
							s.length ? t.insertBefore(r, s[e]) : t.appendChild(r);
					}
				}
				function p(t, e, n) {
					var o = n.css,
						i = n.media,
						r = n.sourceMap;
					if (
						(i ? t.setAttribute("media", i) : t.removeAttribute("media"),
						r &&
							"undefined" != typeof btoa &&
							(o +=
								"\n/*# sourceMappingURL=data:application/json;base64,".concat(
									btoa(unescape(encodeURIComponent(JSON.stringify(r)))),
									" */",
								)),
						t.styleSheet)
					)
						t.styleSheet.cssText = o;
					else {
						for (; t.firstChild; ) t.removeChild(t.firstChild);
						t.appendChild(document.createTextNode(o));
					}
				}
				var g = null,
					f = 0;
				function m(t, e) {
					var n, o, i;
					if (e.singleton) {
						var r = f++;
						(n = g || (g = l(e))),
							(o = h.bind(null, n, r, !1)),
							(i = h.bind(null, n, r, !0));
					} else
						(n = l(e)),
							(o = p.bind(null, n, e)),
							(i = function () {
								!(function (t) {
									if (null === t.parentNode) return !1;
									t.parentNode.removeChild(t);
								})(n);
							});
					return (
						o(t),
						function (e) {
							if (e) {
								if (
									e.css === t.css &&
									e.media === t.media &&
									e.sourceMap === t.sourceMap
								)
									return;
								o((t = e));
							} else i();
						}
					);
				}
				t.exports = function (t, e) {
					(e = e || {}).singleton ||
						"boolean" == typeof e.singleton ||
						(e.singleton = i());
					var n = c((t = t || []), e);
					return function (t) {
						if (
							((t = t || []),
							"[object Array]" === Object.prototype.toString.call(t))
						) {
							for (var o = 0; o < n.length; o++) {
								var i = a(n[o]);
								s[i].references--;
							}
							for (var r = c(t, e), l = 0; l < n.length; l++) {
								var d = a(n[l]);
								0 === s[d].references && (s[d].updater(), s.splice(d, 1));
							}
							n = r;
						}
					};
				};
			},
			function (t, e, n) {
				"use strict";
				function o(t, e) {
					return (
						(function (t) {
							if (Array.isArray(t)) return t;
						})(t) ||
						(function (t, e) {
							var n =
								t &&
								(("undefined" != typeof Symbol && t[Symbol.iterator]) ||
									t["@@iterator"]);
							if (null == n) return;
							var o,
								i,
								r = [],
								s = !0,
								a = !1;
							try {
								for (
									n = n.call(t);
									!(s = (o = n.next()).done) &&
									(r.push(o.value), !e || r.length !== e);
									s = !0
								);
							} catch (t) {
								(a = !0), (i = t);
							} finally {
								try {
									s || null == n.return || n.return();
								} finally {
									if (a) throw i;
								}
							}
							return r;
						})(t, e) ||
						(function (t, e) {
							if (!t) return;
							if ("string" == typeof t) return i(t, e);
							var n = Object.prototype.toString.call(t).slice(8, -1);
							"Object" === n && t.constructor && (n = t.constructor.name);
							if ("Map" === n || "Set" === n) return Array.from(t);
							if (
								"Arguments" === n ||
								/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
							)
								return i(t, e);
						})(t, e) ||
						(function () {
							throw new TypeError(
								"Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
							);
						})()
					);
				}
				function i(t, e) {
					(null == e || e > t.length) && (e = t.length);
					for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
					return o;
				}
				t.exports = function (t) {
					var e = o(t, 4),
						n = e[1],
						i = e[3];
					if (!i) return n;
					if ("function" == typeof btoa) {
						var r = btoa(unescape(encodeURIComponent(JSON.stringify(i)))),
							s =
								"sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(
									r,
								),
							a = "/*# ".concat(s, " */"),
							c = i.sources.map(function (t) {
								return "/*# sourceURL="
									.concat(i.sourceRoot || "")
									.concat(t, " */");
							});
						return [n].concat(c).concat([a]).join("\n");
					}
					return [n].join("\n");
				};
			},
			function (t, e, n) {
				"use strict";
				t.exports = function (t) {
					var e = [];
					return (
						(e.toString = function () {
							return this.map(function (e) {
								var n = t(e);
								return e[2] ? "@media ".concat(e[2], " {").concat(n, "}") : n;
							}).join("");
						}),
						(e.i = function (t, n, o) {
							"string" == typeof t && (t = [[null, t, ""]]);
							var i = {};
							if (o)
								for (var r = 0; r < this.length; r++) {
									var s = this[r][0];
									null != s && (i[s] = !0);
								}
							for (var a = 0; a < t.length; a++) {
								var c = [].concat(t[a]);
								(o && i[c[0]]) ||
									(n &&
										(c[2]
											? (c[2] = "".concat(n, " and ").concat(c[2]))
											: (c[2] = n)),
									e.push(c));
							}
						}),
						e
					);
				};
			},
			,
			function (t, e, n) {
				"use strict";
				var o = n(10),
					i = "object" == typeof self && self && self.Object === Object && self,
					r = o.a || i || Function("return this")();
				e.a = r;
			},
			function (t, e, n) {
				"use strict";
				(function (t) {
					var o = n(5),
						i = n(63),
						r =
							"object" == typeof exports &&
							exports &&
							!exports.nodeType &&
							exports,
						s = r && "object" == typeof t && t && !t.nodeType && t,
						a = s && s.exports === r ? o.a.Buffer : void 0,
						c = (a ? a.isBuffer : void 0) || i.a;
					e.a = c;
				}).call(this, n(14)(t));
			},
			function (t, e, n) {
				"use strict";
				(function (t) {
					var o = n(10),
						i =
							"object" == typeof exports &&
							exports &&
							!exports.nodeType &&
							exports,
						r = i && "object" == typeof t && t && !t.nodeType && t,
						s = r && r.exports === i && o.a.process,
						a = (function () {
							try {
								var t = r && r.require && r.require("util").types;
								return t || (s && s.binding && s.binding("util"));
							} catch (t) {}
						})();
					e.a = a;
				}).call(this, n(14)(t));
			},
			function (t, e, n) {
				"use strict";
				(function (t) {
					var e = n(0);
					const o = "35.3.0";
					const i = "object" == typeof window ? window : t;
					if (i.CKEDITOR_VERSION)
						throw new e.a("ckeditor-duplicated-modules", null);
					i.CKEDITOR_VERSION = o;
				}).call(this, n(13));
			},
			function (t, e, n) {
				"use strict";
				function o(t) {
					if ("string" != typeof t || !t)
						throw new Error("expected a non-empty string, got: " + t);
				}
				function i(t) {
					if ("number" != typeof t)
						throw new Error("expected a number, got: " + t);
				}
				n.d(e, "a", function () {
					return W;
				});
				const r = "emoji",
					s = "keyvalue",
					a = "favorites",
					c = "tokens",
					l = "count",
					d = "group-order",
					u = "eTag",
					h = "url",
					p = "skinTone",
					g = "readonly",
					f = "readwrite",
					m = "skinUnicodes";
				function k(t) {
					return (function (t, e) {
						const n = new Set(),
							o = [];
						for (const i of t) {
							const t = e(i);
							n.has(t) || (n.add(t), o.push(i));
						}
						return o;
					})(t, (t) => t.unicode);
				}
				const b = {},
					w = {},
					A = {};
				function _(t, e, n) {
					(n.onerror = () => e(n.error)),
						(n.onblocked = () => e(new Error("IDB blocked"))),
						(n.onsuccess = () => t(n.result));
				}
				async function C(t) {
					const e = await new Promise((e, n) => {
						const o = indexedDB.open(t, 1);
						(b[t] = o),
							(o.onupgradeneeded = (t) => {
								t.oldVersion < 1 &&
									(function (t) {
										function e(e, n, o) {
											const i = n
												? t.createObjectStore(e, { keyPath: n })
												: t.createObjectStore(e);
											if (o)
												for (const [t, [e, n]] of Object.entries(o))
													i.createIndex(t, e, { multiEntry: n });
											return i;
										}
										e(s),
											e(r, "unicode", {
												[c]: ["tokens", !0],
												[d]: [["group", "order"]],
												[m]: ["skinUnicodes", !0],
											}),
											e(a, void 0, { [l]: [""] });
									})(o.result);
							}),
							_(e, n, o);
					});
					return (e.onclose = () => y(t)), e;
				}
				function v(t, e, n, o) {
					return new Promise((i, r) => {
						const s = t.transaction(e, n, { durability: "relaxed" }),
							a =
								"string" == typeof e
									? s.objectStore(e)
									: e.map((t) => s.objectStore(t));
						let c;
						o(a, s, (t) => {
							c = t;
						}),
							(s.oncomplete = () => i(c)),
							(s.onerror = () => r(s.error));
					});
				}
				function y(t) {
					const e = b[t],
						n = e && e.result;
					if (n) {
						n.close();
						const e = A[t];
						if (e) for (const t of e) t();
					}
					delete b[t], delete w[t], delete A[t];
				}
				const x = new Set([
					":D",
					"XD",
					":'D",
					"O:)",
					":X",
					":P",
					";P",
					"XP",
					":L",
					":Z",
					":j",
					"8D",
					"XO",
					"8)",
					":B",
					":O",
					":S",
					":'o",
					"Dx",
					"X(",
					"D:",
					":C",
					">0)",
					":3",
					"</3",
					"<3",
					"\\M/",
					":E",
					"8#",
				]);
				function D(t) {
					return t
						.split(/[\s_]+/)
						.map((t) =>
							!t.match(/\w/) || x.has(t)
								? t.toLowerCase()
								: t
										.replace(/[)(:,]/g, "")
										.replace(/’/g, "'")
										.toLowerCase(),
						)
						.filter(Boolean);
				}
				function E(t) {
					return t
						.filter(Boolean)
						.map((t) => t.toLowerCase())
						.filter((t) => t.length >= 2);
				}
				function S(t, e, n, o) {
					t[e](n).onsuccess = (t) => o && o(t.target.result);
				}
				function B(t, e, n) {
					S(t, "get", e, n);
				}
				function T(t, e, n) {
					S(t, "getAll", e, n);
				}
				function P(t) {
					t.commit && t.commit();
				}
				function F(t, e) {
					const n = (function (t, e) {
							let n = t[0];
							for (let o = 1; o < t.length; o++) {
								const i = t[o];
								e(n) > e(i) && (n = i);
							}
							return n;
						})(t, (t) => t.length),
						o = [];
					for (const i of n)
						t.some((t) => -1 === t.findIndex((t) => e(t) === e(i))) ||
							o.push(i);
					return o;
				}
				async function I(t, e, n, o) {
					try {
						const i = (function (t) {
							return t.map(
								({
									annotation: t,
									emoticon: e,
									group: n,
									order: o,
									shortcodes: i,
									skins: r,
									tags: s,
									emoji: a,
									version: c,
								}) => {
									const l = [
											...new Set(
												E([
													...(i || []).map(D).flat(),
													...s.map(D).flat(),
													...D(t),
													e,
												]),
											),
										].sort(),
										d = {
											annotation: t,
											group: n,
											order: o,
											tags: s,
											tokens: l,
											unicode: a,
											version: c,
										};
									if ((e && (d.emoticon = e), i && (d.shortcodes = i), r)) {
										(d.skinTones = []),
											(d.skinUnicodes = []),
											(d.skinVersions = []);
										for (const { tone: t, emoji: e, version: n } of r)
											d.skinTones.push(t),
												d.skinUnicodes.push(e),
												d.skinVersions.push(n);
									}
									return d;
								},
							);
						})(e);
						await v(t, [r, s], f, ([t, e], r) => {
							let s,
								a,
								c = 0;
							function l() {
								2 == ++c &&
									(function () {
										if (s === o && a === n) return;
										t.clear();
										for (const e of i) t.put(e);
										e.put(o, u), e.put(n, h), P(r);
									})();
							}
							B(e, u, (t) => {
								(s = t), l();
							}),
								B(e, h, (t) => {
									(a = t), l();
								});
						});
					} finally {
					}
				}
				async function z(t, e) {
					const n = E(D(e));
					return n.length
						? v(t, r, g, (t, e, o) => {
								const i = [],
									r = () => {
										const t = F(i, (t) => t.unicode);
										o(t.sort((t, e) => (t.order < e.order ? -1 : 1)));
									};
								for (let e = 0; e < n.length; e++) {
									const o = n[e],
										s =
											e === n.length - 1
												? IDBKeyRange.bound(o, o + "￿", !1, !0)
												: IDBKeyRange.only(o);
									T(t.index(c), s, (t) => {
										i.push(t), i.length === n.length && r();
									});
								}
							})
						: [];
				}
				async function R(t, e) {
					const n = await z(t, e);
					if (!n.length) {
						const n = (t) => (t.shortcodes || []).includes(e.toLowerCase());
						return (
							(await (async function (t, e) {
								return v(t, r, g, (t, n, o) => {
									let i;
									const r = () => {
										t.getAll(i && IDBKeyRange.lowerBound(i, !0), 50).onsuccess =
											(t) => {
												const n = t.target.result;
												for (const t of n)
													if (((i = t.unicode), e(t))) return o(t);
												if (n.length < 50) return o();
												r();
											};
									};
									r();
								});
							})(t, n)) || null
						);
					}
					return (
						n.filter((t) => {
							const n = (t.shortcodes || []).map((t) => t.toLowerCase());
							return n.includes(e.toLowerCase());
						})[0] || null
					);
				}
				function O(t, e, n) {
					return v(t, e, g, (t, e, o) => B(t, n, o));
				}
				const M = ["name", "url"];
				function N(t) {
					!(function (t) {
						const e = t && Array.isArray(t),
							n = e && t.length && (!t[0] || M.some((e) => !(e in t[0])));
						if (!e || n)
							throw new Error("Custom emojis are in the wrong format");
					})(t);
					const e = (t, e) =>
							t.name.toLowerCase() < e.name.toLowerCase() ? -1 : 1,
						n = t.sort(e),
						o = (function (t, e) {
							const n = new Map();
							for (const o of t) {
								const t = e(o);
								for (const e of t) {
									let t = n;
									for (let n = 0; n < e.length; n++) {
										const o = e.charAt(n);
										let i = t.get(o);
										i || ((i = new Map()), t.set(o, i)), (t = i);
									}
									let i = t.get("");
									i || ((i = []), t.set("", i)), i.push(o);
								}
							}
							return (t, e) => {
								let o = n;
								for (let e = 0; e < t.length; e++) {
									const n = t.charAt(e),
										i = o.get(n);
									if (!i) return [];
									o = i;
								}
								if (e) return o.get("") || [];
								const i = [],
									r = [o];
								for (; r.length; ) {
									const t = [...r.shift().entries()].sort((t, e) =>
										t[0] < e[0] ? -1 : 1,
									);
									for (const [e, n] of t) "" === e ? i.push(...n) : r.push(n);
								}
								return i;
							};
						})(t, (t) => [
							...new Set((t.shortcodes || []).map((t) => D(t)).flat()),
						]),
						i = (t) => o(t, !0),
						r = (t) => o(t, !1),
						s = new Map(),
						a = new Map();
					for (const e of t) {
						a.set(e.name.toLowerCase(), e);
						for (const t of e.shortcodes || []) s.set(t.toLowerCase(), e);
					}
					return {
						all: n,
						search: (t) => {
							const n = D(t);
							return F(
								n.map((t, e) => (e < n.length - 1 ? i : r)(t)),
								(t) => t.name,
							).sort(e);
						},
						byShortcode: (t) => s.get(t.toLowerCase()),
						byName: (t) => a.get(t.toLowerCase()),
					};
				}
				function V(t) {
					if (!t) return t;
					if ((delete t.tokens, t.skinTones)) {
						const e = t.skinTones.length;
						t.skins = Array(e);
						for (let n = 0; n < e; n++)
							t.skins[n] = {
								tone: t.skinTones[n],
								unicode: t.skinUnicodes[n],
								version: t.skinVersions[n],
							};
						delete t.skinTones, delete t.skinUnicodes, delete t.skinVersions;
					}
					return t;
				}
				function L(t) {
					t ||
						console.warn(
							"emoji-picker-element is more efficient if the dataSource server exposes an ETag header.",
						);
				}
				const j = ["annotation", "emoji", "group", "order", "tags", "version"];
				function H(t, e) {
					if (2 !== Math.floor(t.status / 100))
						throw new Error("Failed to fetch: " + e + ":  " + t.status);
				}
				async function $(t) {
					const e = await fetch(t);
					H(e, t);
					const n = e.headers.get("etag");
					L(n);
					const o = await e.json();
					return (
						(function (t) {
							if (
								!t ||
								!Array.isArray(t) ||
								!t[0] ||
								"object" != typeof t[0] ||
								j.some((e) => !(e in t[0]))
							)
								throw new Error("Emoji data is in the wrong format");
						})(o),
						[n, o]
					);
				}
				async function q(t) {
					const e = (function (t) {
							for (
								var e = t.length,
									n = new ArrayBuffer(e),
									o = new Uint8Array(n),
									i = -1;
								++i < e;
							)
								o[i] = t.charCodeAt(i);
							return n;
						})(JSON.stringify(t)),
						n = (function (t) {
							for (
								var e = "", n = new Uint8Array(t), o = n.byteLength, i = -1;
								++i < o;
							)
								e += String.fromCharCode(n[i]);
							return e;
						})(await crypto.subtle.digest("SHA-1", e));
					return btoa(n);
				}
				async function U(t, e) {
					let n,
						o = await (async function (t) {
							const e = await fetch(t, { method: "HEAD" });
							H(e, t);
							const n = e.headers.get("etag");
							return L(n), n;
						})(e);
					if (!o) {
						const t = await $(e);
						(o = t[0]), (n = t[1]), o || (o = await q(n));
					}
					if (
						await (async function (t, e, n) {
							const [o, i] = await Promise.all([u, h].map((e) => O(t, s, e)));
							return o === n && i === e;
						})(t, e, o)
					);
					else {
						if (!n) {
							n = (await $(e))[1];
						}
						await I(t, n, e, o);
					}
				}
				class W {
					constructor({
						dataSource:
							t = "https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json",
						locale: e = "en",
						customEmoji: n = [],
					} = {}) {
						(this.dataSource = t),
							(this.locale = e),
							(this._dbName = `emoji-picker-element-${this.locale}`),
							(this._db = void 0),
							(this._lazyUpdate = void 0),
							(this._custom = N(n)),
							(this._clear = this._clear.bind(this)),
							(this._ready = this._init());
					}
					async _init() {
						const t = (this._db = await ((e = this._dbName),
						w[e] || (w[e] = C(e)),
						w[e]));
						var e;
						!(function (t, e) {
							let n = A[t];
							n || (n = A[t] = []), n.push(e);
						})(this._dbName, this._clear);
						const n = this.dataSource,
							o = await (async function (t) {
								return !(await O(t, s, h));
							})(t);
						o
							? await (async function (t, e) {
									let [n, o] = await $(e);
									n || (n = await q(o)), await I(t, o, e, n);
								})(t, n)
							: (this._lazyUpdate = U(t, n));
					}
					async ready() {
						const t = async () => (
							this._ready || (this._ready = this._init()), this._ready
						);
						await t(), this._db || (await t());
					}
					async getEmojiByGroup(t) {
						return (
							i(t),
							await this.ready(),
							k(
								await (async function (t, e) {
									return v(t, r, g, (t, n, o) => {
										const i = IDBKeyRange.bound([e, 0], [e + 1, 0], !1, !0);
										T(t.index(d), i, o);
									});
								})(this._db, t),
							).map(V)
						);
					}
					async getEmojiBySearchQuery(t) {
						o(t), await this.ready();
						return [
							...this._custom.search(t),
							...k(await z(this._db, t)).map(V),
						];
					}
					async getEmojiByShortcode(t) {
						o(t), await this.ready();
						const e = this._custom.byShortcode(t);
						return e || V(await R(this._db, t));
					}
					async getEmojiByUnicodeOrName(t) {
						o(t), await this.ready();
						const e = this._custom.byName(t);
						return (
							e ||
							V(
								await (async function (t, e) {
									return v(t, r, g, (t, n, o) =>
										B(t, e, (n) => {
											if (n) return o(n);
											B(t.index(m), e, (t) => o(t || null));
										}),
									);
								})(this._db, t),
							)
						);
					}
					async getPreferredSkinTone() {
						return await this.ready(), (await O(this._db, s, p)) || 0;
					}
					async setPreferredSkinTone(t) {
						return (
							i(t),
							await this.ready(),
							(e = this._db),
							(n = p),
							(o = t),
							v(e, s, f, (t, e) => {
								t.put(o, n), P(e);
							})
						);
						var e, n, o;
					}
					async incrementFavoriteEmojiCount(t) {
						return (
							o(t),
							await this.ready(),
							(e = this._db),
							(n = t),
							v(e, a, f, (t, e) =>
								B(t, n, (o) => {
									t.put((o || 0) + 1, n), P(e);
								}),
							)
						);
						var e, n;
					}
					async getTopFavoriteEmoji(t) {
						return (
							i(t),
							await this.ready(),
							(
								await (function (t, e, n) {
									return 0 === n
										? []
										: v(t, [a, r], g, ([t, o], i, r) => {
												const s = [];
												t.index(l).openCursor(void 0, "prev").onsuccess = (
													t,
												) => {
													const i = t.target.result;
													if (!i) return r(s);
													function a(t) {
														if ((s.push(t), s.length === n)) return r(s);
														i.continue();
													}
													const c = i.primaryKey,
														l = e.byName(c);
													if (l) return a(l);
													B(o, c, (t) => {
														if (t) return a(t);
														i.continue();
													});
												};
											});
								})(this._db, this._custom, t)
							).map(V)
						);
					}
					set customEmoji(t) {
						this._custom = N(t);
					}
					get customEmoji() {
						return this._custom.all;
					}
					async _shutdown() {
						await this.ready();
						try {
							await this._lazyUpdate;
						} catch (t) {}
					}
					_clear() {
						this._db = this._ready = this._lazyUpdate = void 0;
					}
					async close() {
						await this._shutdown(), await y(this._dbName);
					}
					async delete() {
						var t;
						await this._shutdown(),
							await ((t = this._dbName),
							new Promise((e, n) => {
								y(t), _(e, n, indexedDB.deleteDatabase(t));
							}));
					}
				}
			},
			function (t, e, n) {
				"use strict";
				(function (t) {
					var n = "object" == typeof t && t && t.Object === Object && t;
					e.a = n;
				}).call(this, n(13));
			},
			function (t, e, n) {
				"use strict";
				(function (t) {
					var o = n(5),
						i =
							"object" == typeof exports &&
							exports &&
							!exports.nodeType &&
							exports,
						r = i && "object" == typeof t && t && !t.nodeType && t,
						s = r && r.exports === i ? o.a.Buffer : void 0,
						a = s ? s.allocUnsafe : void 0;
					e.a = function (t, e) {
						if (e) return t.slice();
						var n = t.length,
							o = a ? a(n) : new t.constructor(n);
						return t.copy(o), o;
					};
				}).call(this, n(14)(t));
			},
			function (t, e, n) {
				!(function (t) {
					"use strict";
					function e(t, e) {
						for (var n = 0; n < e.length; n++) {
							var o = e[n];
							(o.enumerable = o.enumerable || !1),
								(o.configurable = !0),
								"value" in o && (o.writable = !0),
								Object.defineProperty(t, o.key, o);
						}
					}
					function n(t, n, o) {
						return (
							n && e(t.prototype, n),
							o && e(t, o),
							Object.defineProperty(t, "prototype", { writable: !1 }),
							t
						);
					}
					function o(t, e) {
						if (t) {
							if ("string" == typeof t) return i(t, e);
							var n = Object.prototype.toString.call(t).slice(8, -1);
							return (
								"Object" === n && t.constructor && (n = t.constructor.name),
								"Map" === n || "Set" === n
									? Array.from(t)
									: "Arguments" === n ||
											/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
										? i(t, e)
										: void 0
							);
						}
					}
					function i(t, e) {
						(null == e || e > t.length) && (e = t.length);
						for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
						return o;
					}
					function r(t, e) {
						var n =
							("undefined" != typeof Symbol && t[Symbol.iterator]) ||
							t["@@iterator"];
						if (n) return (n = n.call(t)).next.bind(n);
						if (
							Array.isArray(t) ||
							(n = o(t)) ||
							(e && t && "number" == typeof t.length)
						) {
							n && (t = n);
							var i = 0;
							return function () {
								return i >= t.length
									? { done: !0 }
									: { done: !1, value: t[i++] };
							};
						}
						throw new TypeError(
							"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
						);
					}
					function s() {
						return {
							baseUrl: null,
							breaks: !1,
							extensions: null,
							gfm: !0,
							headerIds: !0,
							headerPrefix: "",
							highlight: null,
							langPrefix: "language-",
							mangle: !0,
							pedantic: !1,
							renderer: null,
							sanitize: !1,
							sanitizer: null,
							silent: !1,
							smartLists: !1,
							smartypants: !1,
							tokenizer: null,
							walkTokens: null,
							xhtml: !1,
						};
					}
					function a(e) {
						t.defaults = e;
					}
					t.defaults = s();
					var c = /[&<>"']/,
						l = /[&<>"']/g,
						d = /[<>"']|&(?!#?\w+;)/,
						u = /[<>"']|&(?!#?\w+;)/g,
						h = {
							"&": "&amp;",
							"<": "&lt;",
							">": "&gt;",
							'"': "&quot;",
							"'": "&#39;",
						},
						p = function (t) {
							return h[t];
						};
					function g(t, e) {
						if (e) {
							if (c.test(t)) return t.replace(l, p);
						} else if (d.test(t)) return t.replace(u, p);
						return t;
					}
					var f = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;
					function m(t) {
						return t.replace(f, function (t, e) {
							return "colon" === (e = e.toLowerCase())
								? ":"
								: "#" === e.charAt(0)
									? "x" === e.charAt(1)
										? String.fromCharCode(parseInt(e.substring(2), 16))
										: String.fromCharCode(+e.substring(1))
									: "";
						});
					}
					var k = /(^|[^\[])\^/g;
					function b(t, e) {
						(t = t.source || t), (e = e || "");
						var n = {
							replace: function (e, o) {
								return (
									(o = (o = o.source || o).replace(k, "$1")),
									(t = t.replace(e, o)),
									n
								);
							},
							getRegex: function () {
								return new RegExp(t, e);
							},
						};
						return n;
					}
					var w = /[^\w:]/g,
						A = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
					function _(t, e, n) {
						if (t) {
							var o;
							try {
								o = decodeURIComponent(m(n)).replace(w, "").toLowerCase();
							} catch (t) {
								return null;
							}
							if (
								0 === o.indexOf("javascript:") ||
								0 === o.indexOf("vbscript:") ||
								0 === o.indexOf("data:")
							)
								return null;
						}
						e && !A.test(n) && (n = D(e, n));
						try {
							n = encodeURI(n).replace(/%25/g, "%");
						} catch (t) {
							return null;
						}
						return n;
					}
					var C = {},
						v = /^[^:]+:\/*[^/]*$/,
						y = /^([^:]+:)[\s\S]*$/,
						x = /^([^:]+:\/*[^/]*)[\s\S]*$/;
					function D(t, e) {
						C[" " + t] ||
							(v.test(t)
								? (C[" " + t] = t + "/")
								: (C[" " + t] = T(t, "/", !0)));
						var n = -1 === (t = C[" " + t]).indexOf(":");
						return "//" === e.substring(0, 2)
							? n
								? e
								: t.replace(y, "$1") + e
							: "/" === e.charAt(0)
								? n
									? e
									: t.replace(x, "$1") + e
								: t + e;
					}
					var E = { exec: function () {} };
					function S(t) {
						for (var e, n, o = 1; o < arguments.length; o++)
							for (n in (e = arguments[o]))
								Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
						return t;
					}
					function B(t, e) {
						var n = t
								.replace(/\|/g, function (t, e, n) {
									for (var o = !1, i = e; --i >= 0 && "\\" === n[i]; ) o = !o;
									return o ? "|" : " |";
								})
								.split(/ \|/),
							o = 0;
						if (
							(n[0].trim() || n.shift(),
							n.length > 0 && !n[n.length - 1].trim() && n.pop(),
							n.length > e)
						)
							n.splice(e);
						else for (; n.length < e; ) n.push("");
						for (; o < n.length; o++) n[o] = n[o].trim().replace(/\\\|/g, "|");
						return n;
					}
					function T(t, e, n) {
						var o = t.length;
						if (0 === o) return "";
						for (var i = 0; i < o; ) {
							var r = t.charAt(o - i - 1);
							if (r !== e || n) {
								if (r === e || !n) break;
								i++;
							} else i++;
						}
						return t.substr(0, o - i);
					}
					function P(t, e) {
						if (-1 === t.indexOf(e[1])) return -1;
						for (var n = t.length, o = 0, i = 0; i < n; i++)
							if ("\\" === t[i]) i++;
							else if (t[i] === e[0]) o++;
							else if (t[i] === e[1] && --o < 0) return i;
						return -1;
					}
					function F(t) {
						t &&
							t.sanitize &&
							!t.silent &&
							console.warn(
								"marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options",
							);
					}
					function I(t, e) {
						if (e < 1) return "";
						for (var n = ""; e > 1; ) 1 & e && (n += t), (e >>= 1), (t += t);
						return n + t;
					}
					function z(t, e, n, o) {
						var i = e.href,
							r = e.title ? g(e.title) : null,
							s = t[1].replace(/\\([\[\]])/g, "$1");
						if ("!" !== t[0].charAt(0)) {
							o.state.inLink = !0;
							var a = {
								type: "link",
								raw: n,
								href: i,
								title: r,
								text: s,
								tokens: o.inlineTokens(s, []),
							};
							return (o.state.inLink = !1), a;
						}
						return { type: "image", raw: n, href: i, title: r, text: g(s) };
					}
					function R(t, e) {
						var n = t.match(/^(\s+)(?:```)/);
						if (null === n) return e;
						var o = n[1];
						return e
							.split("\n")
							.map(function (t) {
								var e = t.match(/^\s+/);
								return null === e
									? t
									: e[0].length >= o.length
										? t.slice(o.length)
										: t;
							})
							.join("\n");
					}
					var O = (function () {
							function e(e) {
								this.options = e || t.defaults;
							}
							var n = e.prototype;
							return (
								(n.space = function (t) {
									var e = this.rules.block.newline.exec(t);
									if (e && e[0].length > 0) return { type: "space", raw: e[0] };
								}),
								(n.code = function (t) {
									var e = this.rules.block.code.exec(t);
									if (e) {
										var n = e[0].replace(/^ {1,4}/gm, "");
										return {
											type: "code",
											raw: e[0],
											codeBlockStyle: "indented",
											text: this.options.pedantic ? n : T(n, "\n"),
										};
									}
								}),
								(n.fences = function (t) {
									var e = this.rules.block.fences.exec(t);
									if (e) {
										var n = e[0],
											o = R(n, e[3] || "");
										return {
											type: "code",
											raw: n,
											lang: e[2] ? e[2].trim() : e[2],
											text: o,
										};
									}
								}),
								(n.heading = function (t) {
									var e = this.rules.block.heading.exec(t);
									if (e) {
										var n = e[2].trim();
										if (/#$/.test(n)) {
											var o = T(n, "#");
											this.options.pedantic
												? (n = o.trim())
												: (o && !/ $/.test(o)) || (n = o.trim());
										}
										var i = {
											type: "heading",
											raw: e[0],
											depth: e[1].length,
											text: n,
											tokens: [],
										};
										return this.lexer.inline(i.text, i.tokens), i;
									}
								}),
								(n.hr = function (t) {
									var e = this.rules.block.hr.exec(t);
									if (e) return { type: "hr", raw: e[0] };
								}),
								(n.blockquote = function (t) {
									var e = this.rules.block.blockquote.exec(t);
									if (e) {
										var n = e[0].replace(/^ *> ?/gm, "");
										return {
											type: "blockquote",
											raw: e[0],
											tokens: this.lexer.blockTokens(n, []),
											text: n,
										};
									}
								}),
								(n.list = function (t) {
									var e = this.rules.block.list.exec(t);
									if (e) {
										var n,
											o,
											i,
											s,
											a,
											c,
											l,
											d,
											u,
											h,
											p,
											g,
											f = e[1].trim(),
											m = f.length > 1,
											k = {
												type: "list",
												raw: "",
												ordered: m,
												start: m ? +f.slice(0, -1) : "",
												loose: !1,
												items: [],
											};
										(f = m ? "\\d{1,9}\\" + f.slice(-1) : "\\" + f),
											this.options.pedantic && (f = m ? f : "[*+-]");
										for (
											var b = new RegExp(
												"^( {0,3}" + f + ")((?: [^\\n]*)?(?:\\n|$))",
											);
											t &&
											((g = !1), (e = b.exec(t))) &&
											!this.rules.block.hr.test(t);
										) {
											if (
												((n = e[0]),
												(t = t.substring(n.length)),
												(d = e[2].split("\n", 1)[0]),
												(u = t.split("\n", 1)[0]),
												this.options.pedantic
													? ((s = 2), (p = d.trimLeft()))
													: ((s = (s = e[2].search(/[^ ]/)) > 4 ? 1 : s),
														(p = d.slice(s)),
														(s += e[1].length)),
												(c = !1),
												!d &&
													/^ *$/.test(u) &&
													((n += u + "\n"),
													(t = t.substring(u.length + 1)),
													(g = !0)),
												!g)
											)
												for (
													var w = new RegExp(
														"^ {0," +
															Math.min(3, s - 1) +
															"}(?:[*+-]|\\d{1,9}[.)])",
													);
													t &&
													((d = h = t.split("\n", 1)[0]),
													this.options.pedantic &&
														(d = d.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")),
													!w.test(d));
												) {
													if (d.search(/[^ ]/) >= s || !d.trim())
														p += "\n" + d.slice(s);
													else {
														if (c) break;
														p += "\n" + d;
													}
													c || d.trim() || (c = !0),
														(n += h + "\n"),
														(t = t.substring(h.length + 1));
												}
											k.loose ||
												(l ? (k.loose = !0) : /\n *\n *$/.test(n) && (l = !0)),
												this.options.gfm &&
													(o = /^\[[ xX]\] /.exec(p)) &&
													((i = "[ ] " !== o[0]),
													(p = p.replace(/^\[[ xX]\] +/, ""))),
												k.items.push({
													type: "list_item",
													raw: n,
													task: !!o,
													checked: i,
													loose: !1,
													text: p,
												}),
												(k.raw += n);
										}
										(k.items[k.items.length - 1].raw = n.trimRight()),
											(k.items[k.items.length - 1].text = p.trimRight()),
											(k.raw = k.raw.trimRight());
										var A = k.items.length;
										for (a = 0; a < A; a++) {
											(this.lexer.state.top = !1),
												(k.items[a].tokens = this.lexer.blockTokens(
													k.items[a].text,
													[],
												));
											var _ = k.items[a].tokens.filter(function (t) {
													return "space" === t.type;
												}),
												C = _.every(function (t) {
													for (
														var e, n = 0, o = r(t.raw.split(""));
														!(e = o()).done;
													)
														if (("\n" === e.value && (n += 1), n > 1))
															return !0;
													return !1;
												});
											!k.loose &&
												_.length &&
												C &&
												((k.loose = !0), (k.items[a].loose = !0));
										}
										return k;
									}
								}),
								(n.html = function (t) {
									var e = this.rules.block.html.exec(t);
									if (e) {
										var n = {
											type: "html",
											raw: e[0],
											pre:
												!this.options.sanitizer &&
												("pre" === e[1] ||
													"script" === e[1] ||
													"style" === e[1]),
											text: e[0],
										};
										return (
											this.options.sanitize &&
												((n.type = "paragraph"),
												(n.text = this.options.sanitizer
													? this.options.sanitizer(e[0])
													: g(e[0])),
												(n.tokens = []),
												this.lexer.inline(n.text, n.tokens)),
											n
										);
									}
								}),
								(n.def = function (t) {
									var e = this.rules.block.def.exec(t);
									if (e)
										return (
											e[3] && (e[3] = e[3].substring(1, e[3].length - 1)),
											{
												type: "def",
												tag: e[1].toLowerCase().replace(/\s+/g, " "),
												raw: e[0],
												href: e[2],
												title: e[3],
											}
										);
								}),
								(n.table = function (t) {
									var e = this.rules.block.table.exec(t);
									if (e) {
										var n = {
											type: "table",
											header: B(e[1]).map(function (t) {
												return { text: t };
											}),
											align: e[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
											rows:
												e[3] && e[3].trim()
													? e[3].replace(/\n[ \t]*$/, "").split("\n")
													: [],
										};
										if (n.header.length === n.align.length) {
											n.raw = e[0];
											var o,
												i,
												r,
												s,
												a = n.align.length;
											for (o = 0; o < a; o++)
												/^ *-+: *$/.test(n.align[o])
													? (n.align[o] = "right")
													: /^ *:-+: *$/.test(n.align[o])
														? (n.align[o] = "center")
														: /^ *:-+ *$/.test(n.align[o])
															? (n.align[o] = "left")
															: (n.align[o] = null);
											for (a = n.rows.length, o = 0; o < a; o++)
												n.rows[o] = B(n.rows[o], n.header.length).map(
													function (t) {
														return { text: t };
													},
												);
											for (a = n.header.length, i = 0; i < a; i++)
												(n.header[i].tokens = []),
													this.lexer.inlineTokens(
														n.header[i].text,
														n.header[i].tokens,
													);
											for (a = n.rows.length, i = 0; i < a; i++)
												for (s = n.rows[i], r = 0; r < s.length; r++)
													(s[r].tokens = []),
														this.lexer.inlineTokens(s[r].text, s[r].tokens);
											return n;
										}
									}
								}),
								(n.lheading = function (t) {
									var e = this.rules.block.lheading.exec(t);
									if (e) {
										var n = {
											type: "heading",
											raw: e[0],
											depth: "=" === e[2].charAt(0) ? 1 : 2,
											text: e[1],
											tokens: [],
										};
										return this.lexer.inline(n.text, n.tokens), n;
									}
								}),
								(n.paragraph = function (t) {
									var e = this.rules.block.paragraph.exec(t);
									if (e) {
										var n = {
											type: "paragraph",
											raw: e[0],
											text:
												"\n" === e[1].charAt(e[1].length - 1)
													? e[1].slice(0, -1)
													: e[1],
											tokens: [],
										};
										return this.lexer.inline(n.text, n.tokens), n;
									}
								}),
								(n.text = function (t) {
									var e = this.rules.block.text.exec(t);
									if (e) {
										var n = { type: "text", raw: e[0], text: e[0], tokens: [] };
										return this.lexer.inline(n.text, n.tokens), n;
									}
								}),
								(n.escape = function (t) {
									var e = this.rules.inline.escape.exec(t);
									if (e) return { type: "escape", raw: e[0], text: g(e[1]) };
								}),
								(n.tag = function (t) {
									var e = this.rules.inline.tag.exec(t);
									if (e)
										return (
											!this.lexer.state.inLink && /^<a /i.test(e[0])
												? (this.lexer.state.inLink = !0)
												: this.lexer.state.inLink &&
													/^<\/a>/i.test(e[0]) &&
													(this.lexer.state.inLink = !1),
											!this.lexer.state.inRawBlock &&
											/^<(pre|code|kbd|script)(\s|>)/i.test(e[0])
												? (this.lexer.state.inRawBlock = !0)
												: this.lexer.state.inRawBlock &&
													/^<\/(pre|code|kbd|script)(\s|>)/i.test(e[0]) &&
													(this.lexer.state.inRawBlock = !1),
											{
												type: this.options.sanitize ? "text" : "html",
												raw: e[0],
												inLink: this.lexer.state.inLink,
												inRawBlock: this.lexer.state.inRawBlock,
												text: this.options.sanitize
													? this.options.sanitizer
														? this.options.sanitizer(e[0])
														: g(e[0])
													: e[0],
											}
										);
								}),
								(n.link = function (t) {
									var e = this.rules.inline.link.exec(t);
									if (e) {
										var n = e[2].trim();
										if (!this.options.pedantic && /^</.test(n)) {
											if (!/>$/.test(n)) return;
											var o = T(n.slice(0, -1), "\\");
											if ((n.length - o.length) % 2 == 0) return;
										} else {
											var i = P(e[2], "()");
											if (i > -1) {
												var r =
													(0 === e[0].indexOf("!") ? 5 : 4) + e[1].length + i;
												(e[2] = e[2].substring(0, i)),
													(e[0] = e[0].substring(0, r).trim()),
													(e[3] = "");
											}
										}
										var s = e[2],
											a = "";
										if (this.options.pedantic) {
											var c = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(s);
											c && ((s = c[1]), (a = c[3]));
										} else a = e[3] ? e[3].slice(1, -1) : "";
										return (
											(s = s.trim()),
											/^</.test(s) &&
												(s =
													this.options.pedantic && !/>$/.test(n)
														? s.slice(1)
														: s.slice(1, -1)),
											z(
												e,
												{
													href: s
														? s.replace(this.rules.inline._escapes, "$1")
														: s,
													title: a
														? a.replace(this.rules.inline._escapes, "$1")
														: a,
												},
												e[0],
												this.lexer,
											)
										);
									}
								}),
								(n.reflink = function (t, e) {
									var n;
									if (
										(n = this.rules.inline.reflink.exec(t)) ||
										(n = this.rules.inline.nolink.exec(t))
									) {
										var o = (n[2] || n[1]).replace(/\s+/g, " ");
										if (!(o = e[o.toLowerCase()]) || !o.href) {
											var i = n[0].charAt(0);
											return { type: "text", raw: i, text: i };
										}
										return z(n, o, n[0], this.lexer);
									}
								}),
								(n.emStrong = function (t, e, n) {
									void 0 === n && (n = "");
									var o = this.rules.inline.emStrong.lDelim.exec(t);
									if (
										o &&
										(!o[3] ||
											!n.match(
												/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/,
											))
									) {
										var i = o[1] || o[2] || "";
										if (
											!i ||
											(i && ("" === n || this.rules.inline.punctuation.exec(n)))
										) {
											var r,
												s,
												a = o[0].length - 1,
												c = a,
												l = 0,
												d =
													"*" === o[0][0]
														? this.rules.inline.emStrong.rDelimAst
														: this.rules.inline.emStrong.rDelimUnd;
											for (
												d.lastIndex = 0, e = e.slice(-1 * t.length + a);
												null != (o = d.exec(e));
											)
												if ((r = o[1] || o[2] || o[3] || o[4] || o[5] || o[6]))
													if (((s = r.length), o[3] || o[4])) c += s;
													else if (!((o[5] || o[6]) && a % 3) || (a + s) % 3) {
														if (!((c -= s) > 0)) {
															if (
																((s = Math.min(s, s + c + l)),
																Math.min(a, s) % 2)
															) {
																var u = t.slice(1, a + o.index + s);
																return {
																	type: "em",
																	raw: t.slice(0, a + o.index + s + 1),
																	text: u,
																	tokens: this.lexer.inlineTokens(u, []),
																};
															}
															var h = t.slice(2, a + o.index + s - 1);
															return {
																type: "strong",
																raw: t.slice(0, a + o.index + s + 1),
																text: h,
																tokens: this.lexer.inlineTokens(h, []),
															};
														}
													} else l += s;
										}
									}
								}),
								(n.codespan = function (t) {
									var e = this.rules.inline.code.exec(t);
									if (e) {
										var n = e[2].replace(/\n/g, " "),
											o = /[^ ]/.test(n),
											i = /^ /.test(n) && / $/.test(n);
										return (
											o && i && (n = n.substring(1, n.length - 1)),
											(n = g(n, !0)),
											{ type: "codespan", raw: e[0], text: n }
										);
									}
								}),
								(n.br = function (t) {
									var e = this.rules.inline.br.exec(t);
									if (e) return { type: "br", raw: e[0] };
								}),
								(n.del = function (t) {
									var e = this.rules.inline.del.exec(t);
									if (e)
										return {
											type: "del",
											raw: e[0],
											text: e[2],
											tokens: this.lexer.inlineTokens(e[2], []),
										};
								}),
								(n.autolink = function (t, e) {
									var n,
										o,
										i = this.rules.inline.autolink.exec(t);
									if (i)
										return (
											(o =
												"@" === i[2]
													? "mailto:" +
														(n = g(this.options.mangle ? e(i[1]) : i[1]))
													: (n = g(i[1]))),
											{
												type: "link",
												raw: i[0],
												text: n,
												href: o,
												tokens: [{ type: "text", raw: n, text: n }],
											}
										);
								}),
								(n.url = function (t, e) {
									var n;
									if ((n = this.rules.inline.url.exec(t))) {
										var o, i;
										if ("@" === n[2])
											i =
												"mailto:" +
												(o = g(this.options.mangle ? e(n[0]) : n[0]));
										else {
											var r;
											do {
												(r = n[0]),
													(n[0] = this.rules.inline._backpedal.exec(n[0])[0]);
											} while (r !== n[0]);
											(o = g(n[0])), (i = "www." === n[1] ? "http://" + o : o);
										}
										return {
											type: "link",
											raw: n[0],
											text: o,
											href: i,
											tokens: [{ type: "text", raw: o, text: o }],
										};
									}
								}),
								(n.inlineText = function (t, e) {
									var n,
										o = this.rules.inline.text.exec(t);
									if (o)
										return (
											(n = this.lexer.state.inRawBlock
												? this.options.sanitize
													? this.options.sanitizer
														? this.options.sanitizer(o[0])
														: g(o[0])
													: o[0]
												: g(this.options.smartypants ? e(o[0]) : o[0])),
											{ type: "text", raw: o[0], text: n }
										);
								}),
								e
							);
						})(),
						M = {
							newline: /^(?: *(?:\n|$))+/,
							code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
							fences:
								/^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
							hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
							heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
							blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
							list: /^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,
							html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
							def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
							table: E,
							lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
							_paragraph:
								/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
							text: /^[^\n]+/,
							_label: /(?!\s*\])(?:\\.|[^\[\]\\])+/,
							_title:
								/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/,
						};
					(M.def = b(M.def)
						.replace("label", M._label)
						.replace("title", M._title)
						.getRegex()),
						(M.bullet = /(?:[*+-]|\d{1,9}[.)])/),
						(M.listItemStart = b(/^( *)(bull) */)
							.replace("bull", M.bullet)
							.getRegex()),
						(M.list = b(M.list)
							.replace(/bull/g, M.bullet)
							.replace(
								"hr",
								"\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))",
							)
							.replace("def", "\\n+(?=" + M.def.source + ")")
							.getRegex()),
						(M._tag =
							"address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul"),
						(M._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/),
						(M.html = b(M.html, "i")
							.replace("comment", M._comment)
							.replace("tag", M._tag)
							.replace(
								"attribute",
								/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/,
							)
							.getRegex()),
						(M.paragraph = b(M._paragraph)
							.replace("hr", M.hr)
							.replace("heading", " {0,3}#{1,6} ")
							.replace("|lheading", "")
							.replace("|table", "")
							.replace("blockquote", " {0,3}>")
							.replace(
								"fences",
								" {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n",
							)
							.replace("list", " {0,3}(?:[*+-]|1[.)]) ")
							.replace(
								"html",
								"</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)",
							)
							.replace("tag", M._tag)
							.getRegex()),
						(M.blockquote = b(M.blockquote)
							.replace("paragraph", M.paragraph)
							.getRegex()),
						(M.normal = S({}, M)),
						(M.gfm = S({}, M.normal, {
							table:
								"^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)",
						})),
						(M.gfm.table = b(M.gfm.table)
							.replace("hr", M.hr)
							.replace("heading", " {0,3}#{1,6} ")
							.replace("blockquote", " {0,3}>")
							.replace("code", " {4}[^\\n]")
							.replace(
								"fences",
								" {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n",
							)
							.replace("list", " {0,3}(?:[*+-]|1[.)]) ")
							.replace(
								"html",
								"</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)",
							)
							.replace("tag", M._tag)
							.getRegex()),
						(M.gfm.paragraph = b(M._paragraph)
							.replace("hr", M.hr)
							.replace("heading", " {0,3}#{1,6} ")
							.replace("|lheading", "")
							.replace("table", M.gfm.table)
							.replace("blockquote", " {0,3}>")
							.replace(
								"fences",
								" {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n",
							)
							.replace("list", " {0,3}(?:[*+-]|1[.)]) ")
							.replace(
								"html",
								"</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)",
							)
							.replace("tag", M._tag)
							.getRegex()),
						(M.pedantic = S({}, M.normal, {
							html: b(
								"^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))",
							)
								.replace("comment", M._comment)
								.replace(
									/tag/g,
									"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b",
								)
								.getRegex(),
							def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
							heading: /^(#{1,6})(.*)(?:\n+|$)/,
							fences: E,
							paragraph: b(M.normal._paragraph)
								.replace("hr", M.hr)
								.replace("heading", " *#{1,6} *[^\n]")
								.replace("lheading", M.lheading)
								.replace("blockquote", " {0,3}>")
								.replace("|fences", "")
								.replace("|list", "")
								.replace("|html", "")
								.getRegex(),
						}));
					var N = {
						escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
						autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
						url: E,
						tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
						link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
						reflink: /^!?\[(label)\]\[(ref)\]/,
						nolink: /^!?\[(ref)\](?:\[\])?/,
						reflinkSearch: "reflink|nolink(?!\\()",
						emStrong: {
							lDelim:
								/^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
							rDelimAst:
								/^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
							rDelimUnd:
								/^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/,
						},
						code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
						br: /^( {2,}|\\)\n(?!\s*$)/,
						del: E,
						text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
						punctuation: /^([\spunctuation])/,
					};
					function V(t) {
						return t
							.replace(/---/g, "—")
							.replace(/--/g, "–")
							.replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘")
							.replace(/'/g, "’")
							.replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“")
							.replace(/"/g, "”")
							.replace(/\.{3}/g, "…");
					}
					function L(t) {
						var e,
							n,
							o = "",
							i = t.length;
						for (e = 0; e < i; e++)
							(n = t.charCodeAt(e)),
								Math.random() > 0.5 && (n = "x" + n.toString(16)),
								(o += "&#" + n + ";");
						return o;
					}
					(N._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~"),
						(N.punctuation = b(N.punctuation)
							.replace(/punctuation/g, N._punctuation)
							.getRegex()),
						(N.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g),
						(N.escapedEmSt = /\\\*|\\_/g),
						(N._comment = b(M._comment)
							.replace("(?:--\x3e|$)", "--\x3e")
							.getRegex()),
						(N.emStrong.lDelim = b(N.emStrong.lDelim)
							.replace(/punct/g, N._punctuation)
							.getRegex()),
						(N.emStrong.rDelimAst = b(N.emStrong.rDelimAst, "g")
							.replace(/punct/g, N._punctuation)
							.getRegex()),
						(N.emStrong.rDelimUnd = b(N.emStrong.rDelimUnd, "g")
							.replace(/punct/g, N._punctuation)
							.getRegex()),
						(N._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g),
						(N._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/),
						(N._email =
							/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/),
						(N.autolink = b(N.autolink)
							.replace("scheme", N._scheme)
							.replace("email", N._email)
							.getRegex()),
						(N._attribute =
							/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/),
						(N.tag = b(N.tag)
							.replace("comment", N._comment)
							.replace("attribute", N._attribute)
							.getRegex()),
						(N._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/),
						(N._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/),
						(N._title =
							/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/),
						(N.link = b(N.link)
							.replace("label", N._label)
							.replace("href", N._href)
							.replace("title", N._title)
							.getRegex()),
						(N.reflink = b(N.reflink)
							.replace("label", N._label)
							.replace("ref", M._label)
							.getRegex()),
						(N.nolink = b(N.nolink).replace("ref", M._label).getRegex()),
						(N.reflinkSearch = b(N.reflinkSearch, "g")
							.replace("reflink", N.reflink)
							.replace("nolink", N.nolink)
							.getRegex()),
						(N.normal = S({}, N)),
						(N.pedantic = S({}, N.normal, {
							strong: {
								start: /^__|\*\*/,
								middle:
									/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
								endAst: /\*\*(?!\*)/g,
								endUnd: /__(?!_)/g,
							},
							em: {
								start: /^_|\*/,
								middle:
									/^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
								endAst: /\*(?!\*)/g,
								endUnd: /_(?!_)/g,
							},
							link: b(/^!?\[(label)\]\((.*?)\)/)
								.replace("label", N._label)
								.getRegex(),
							reflink: b(/^!?\[(label)\]\s*\[([^\]]*)\]/)
								.replace("label", N._label)
								.getRegex(),
						})),
						(N.gfm = S({}, N.normal, {
							escape: b(N.escape).replace("])", "~|])").getRegex(),
							_extended_email:
								/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
							url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
							_backpedal:
								/(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
							del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
							text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/,
						})),
						(N.gfm.url = b(N.gfm.url, "i")
							.replace("email", N.gfm._extended_email)
							.getRegex()),
						(N.breaks = S({}, N.gfm, {
							br: b(N.br).replace("{2,}", "*").getRegex(),
							text: b(N.gfm.text)
								.replace("\\b_", "\\b_| {2,}\\n")
								.replace(/\{2,\}/g, "*")
								.getRegex(),
						}));
					var j = (function () {
							function e(e) {
								(this.tokens = []),
									(this.tokens.links = Object.create(null)),
									(this.options = e || t.defaults),
									(this.options.tokenizer = this.options.tokenizer || new O()),
									(this.tokenizer = this.options.tokenizer),
									(this.tokenizer.options = this.options),
									(this.tokenizer.lexer = this),
									(this.inlineQueue = []),
									(this.state = { inLink: !1, inRawBlock: !1, top: !0 });
								var n = { block: M.normal, inline: N.normal };
								this.options.pedantic
									? ((n.block = M.pedantic), (n.inline = N.pedantic))
									: this.options.gfm &&
										((n.block = M.gfm),
										this.options.breaks
											? (n.inline = N.breaks)
											: (n.inline = N.gfm)),
									(this.tokenizer.rules = n);
							}
							(e.lex = function (t, n) {
								return new e(n).lex(t);
							}),
								(e.lexInline = function (t, n) {
									return new e(n).inlineTokens(t);
								});
							var o = e.prototype;
							return (
								(o.lex = function (t) {
									var e;
									for (
										t = t.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    "),
											this.blockTokens(t, this.tokens);
										(e = this.inlineQueue.shift());
									)
										this.inlineTokens(e.src, e.tokens);
									return this.tokens;
								}),
								(o.blockTokens = function (t, e) {
									var n,
										o,
										i,
										r,
										s = this;
									for (
										void 0 === e && (e = []),
											this.options.pedantic && (t = t.replace(/^ +$/gm, ""));
										t;
									)
										if (
											!(
												this.options.extensions &&
												this.options.extensions.block &&
												this.options.extensions.block.some(function (o) {
													return (
														!!(n = o.call({ lexer: s }, t, e)) &&
														((t = t.substring(n.raw.length)), e.push(n), !0)
													);
												})
											)
										)
											if ((n = this.tokenizer.space(t)))
												(t = t.substring(n.raw.length)),
													1 === n.raw.length && e.length > 0
														? (e[e.length - 1].raw += "\n")
														: e.push(n);
											else if ((n = this.tokenizer.code(t)))
												(t = t.substring(n.raw.length)),
													!(o = e[e.length - 1]) ||
													("paragraph" !== o.type && "text" !== o.type)
														? e.push(n)
														: ((o.raw += "\n" + n.raw),
															(o.text += "\n" + n.text),
															(this.inlineQueue[
																this.inlineQueue.length - 1
															].src = o.text));
											else if ((n = this.tokenizer.fences(t)))
												(t = t.substring(n.raw.length)), e.push(n);
											else if ((n = this.tokenizer.heading(t)))
												(t = t.substring(n.raw.length)), e.push(n);
											else if ((n = this.tokenizer.hr(t)))
												(t = t.substring(n.raw.length)), e.push(n);
											else if ((n = this.tokenizer.blockquote(t)))
												(t = t.substring(n.raw.length)), e.push(n);
											else if ((n = this.tokenizer.list(t)))
												(t = t.substring(n.raw.length)), e.push(n);
											else if ((n = this.tokenizer.html(t)))
												(t = t.substring(n.raw.length)), e.push(n);
											else if ((n = this.tokenizer.def(t)))
												(t = t.substring(n.raw.length)),
													!(o = e[e.length - 1]) ||
													("paragraph" !== o.type && "text" !== o.type)
														? this.tokens.links[n.tag] ||
															(this.tokens.links[n.tag] = {
																href: n.href,
																title: n.title,
															})
														: ((o.raw += "\n" + n.raw),
															(o.text += "\n" + n.raw),
															(this.inlineQueue[
																this.inlineQueue.length - 1
															].src = o.text));
											else if ((n = this.tokenizer.table(t)))
												(t = t.substring(n.raw.length)), e.push(n);
											else if ((n = this.tokenizer.lheading(t)))
												(t = t.substring(n.raw.length)), e.push(n);
											else if (
												((i = t),
												this.options.extensions &&
													this.options.extensions.startBlock &&
													(function () {
														var e = 1 / 0,
															n = t.slice(1),
															o = void 0;
														s.options.extensions.startBlock.forEach(
															function (t) {
																"number" ==
																	typeof (o = t.call({ lexer: this }, n)) &&
																	o >= 0 &&
																	(e = Math.min(e, o));
															},
														),
															e < 1 / 0 &&
																e >= 0 &&
																(i = t.substring(0, e + 1));
													})(),
												this.state.top && (n = this.tokenizer.paragraph(i)))
											)
												(o = e[e.length - 1]),
													r && "paragraph" === o.type
														? ((o.raw += "\n" + n.raw),
															(o.text += "\n" + n.text),
															this.inlineQueue.pop(),
															(this.inlineQueue[
																this.inlineQueue.length - 1
															].src = o.text))
														: e.push(n),
													(r = i.length !== t.length),
													(t = t.substring(n.raw.length));
											else if ((n = this.tokenizer.text(t)))
												(t = t.substring(n.raw.length)),
													(o = e[e.length - 1]) && "text" === o.type
														? ((o.raw += "\n" + n.raw),
															(o.text += "\n" + n.text),
															this.inlineQueue.pop(),
															(this.inlineQueue[
																this.inlineQueue.length - 1
															].src = o.text))
														: e.push(n);
											else if (t) {
												var a = "Infinite loop on byte: " + t.charCodeAt(0);
												if (this.options.silent) {
													console.error(a);
													break;
												}
												throw new Error(a);
											}
									return (this.state.top = !0), e;
								}),
								(o.inline = function (t, e) {
									this.inlineQueue.push({ src: t, tokens: e });
								}),
								(o.inlineTokens = function (t, e) {
									var n,
										o,
										i,
										r = this;
									void 0 === e && (e = []);
									var s,
										a,
										c,
										l = t;
									if (this.tokens.links) {
										var d = Object.keys(this.tokens.links);
										if (d.length > 0)
											for (
												;
												null !=
												(s = this.tokenizer.rules.inline.reflinkSearch.exec(l));
											)
												d.includes(s[0].slice(s[0].lastIndexOf("[") + 1, -1)) &&
													(l =
														l.slice(0, s.index) +
														"[" +
														I("a", s[0].length - 2) +
														"]" +
														l.slice(
															this.tokenizer.rules.inline.reflinkSearch
																.lastIndex,
														));
									}
									for (
										;
										null != (s = this.tokenizer.rules.inline.blockSkip.exec(l));
									)
										l =
											l.slice(0, s.index) +
											"[" +
											I("a", s[0].length - 2) +
											"]" +
											l.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
									for (
										;
										null !=
										(s = this.tokenizer.rules.inline.escapedEmSt.exec(l));
									)
										l =
											l.slice(0, s.index) +
											"++" +
											l.slice(
												this.tokenizer.rules.inline.escapedEmSt.lastIndex,
											);
									for (; t; )
										if (
											(a || (c = ""),
											(a = !1),
											!(
												this.options.extensions &&
												this.options.extensions.inline &&
												this.options.extensions.inline.some(function (o) {
													return (
														!!(n = o.call({ lexer: r }, t, e)) &&
														((t = t.substring(n.raw.length)), e.push(n), !0)
													);
												})
											))
										)
											if ((n = this.tokenizer.escape(t)))
												(t = t.substring(n.raw.length)), e.push(n);
											else if ((n = this.tokenizer.tag(t)))
												(t = t.substring(n.raw.length)),
													(o = e[e.length - 1]) &&
													"text" === n.type &&
													"text" === o.type
														? ((o.raw += n.raw), (o.text += n.text))
														: e.push(n);
											else if ((n = this.tokenizer.link(t)))
												(t = t.substring(n.raw.length)), e.push(n);
											else if (
												(n = this.tokenizer.reflink(t, this.tokens.links))
											)
												(t = t.substring(n.raw.length)),
													(o = e[e.length - 1]) &&
													"text" === n.type &&
													"text" === o.type
														? ((o.raw += n.raw), (o.text += n.text))
														: e.push(n);
											else if ((n = this.tokenizer.emStrong(t, l, c)))
												(t = t.substring(n.raw.length)), e.push(n);
											else if ((n = this.tokenizer.codespan(t)))
												(t = t.substring(n.raw.length)), e.push(n);
											else if ((n = this.tokenizer.br(t)))
												(t = t.substring(n.raw.length)), e.push(n);
											else if ((n = this.tokenizer.del(t)))
												(t = t.substring(n.raw.length)), e.push(n);
											else if ((n = this.tokenizer.autolink(t, L)))
												(t = t.substring(n.raw.length)), e.push(n);
											else if (
												this.state.inLink ||
												!(n = this.tokenizer.url(t, L))
											) {
												if (
													((i = t),
													this.options.extensions &&
														this.options.extensions.startInline &&
														(function () {
															var e = 1 / 0,
																n = t.slice(1),
																o = void 0;
															r.options.extensions.startInline.forEach(
																function (t) {
																	"number" ==
																		typeof (o = t.call({ lexer: this }, n)) &&
																		o >= 0 &&
																		(e = Math.min(e, o));
																},
															),
																e < 1 / 0 &&
																	e >= 0 &&
																	(i = t.substring(0, e + 1));
														})(),
													(n = this.tokenizer.inlineText(i, V)))
												)
													(t = t.substring(n.raw.length)),
														"_" !== n.raw.slice(-1) && (c = n.raw.slice(-1)),
														(a = !0),
														(o = e[e.length - 1]) && "text" === o.type
															? ((o.raw += n.raw), (o.text += n.text))
															: e.push(n);
												else if (t) {
													var u = "Infinite loop on byte: " + t.charCodeAt(0);
													if (this.options.silent) {
														console.error(u);
														break;
													}
													throw new Error(u);
												}
											} else (t = t.substring(n.raw.length)), e.push(n);
									return e;
								}),
								n(e, null, [
									{
										key: "rules",
										get: function () {
											return { block: M, inline: N };
										},
									},
								]),
								e
							);
						})(),
						H = (function () {
							function e(e) {
								this.options = e || t.defaults;
							}
							var n = e.prototype;
							return (
								(n.code = function (t, e, n) {
									var o = (e || "").match(/\S*/)[0];
									if (this.options.highlight) {
										var i = this.options.highlight(t, o);
										null != i && i !== t && ((n = !0), (t = i));
									}
									return (
										(t = t.replace(/\n$/, "") + "\n"),
										o
											? '<pre><code class="' +
												this.options.langPrefix +
												g(o, !0) +
												'">' +
												(n ? t : g(t, !0)) +
												"</code></pre>\n"
											: "<pre><code>" + (n ? t : g(t, !0)) + "</code></pre>\n"
									);
								}),
								(n.blockquote = function (t) {
									return "<blockquote>\n" + t + "</blockquote>\n";
								}),
								(n.html = function (t) {
									return t;
								}),
								(n.heading = function (t, e, n, o) {
									return this.options.headerIds
										? "<h" +
												e +
												' id="' +
												this.options.headerPrefix +
												o.slug(n) +
												'">' +
												t +
												"</h" +
												e +
												">\n"
										: "<h" + e + ">" + t + "</h" + e + ">\n";
								}),
								(n.hr = function () {
									return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
								}),
								(n.list = function (t, e, n) {
									var o = e ? "ol" : "ul";
									return (
										"<" +
										o +
										(e && 1 !== n ? ' start="' + n + '"' : "") +
										">\n" +
										t +
										"</" +
										o +
										">\n"
									);
								}),
								(n.listitem = function (t) {
									return "<li>" + t + "</li>\n";
								}),
								(n.checkbox = function (t) {
									return (
										"<input " +
										(t ? 'checked="" ' : "") +
										'disabled="" type="checkbox"' +
										(this.options.xhtml ? " /" : "") +
										"> "
									);
								}),
								(n.paragraph = function (t) {
									return "<p>" + t + "</p>\n";
								}),
								(n.table = function (t, e) {
									return (
										e && (e = "<tbody>" + e + "</tbody>"),
										"<table>\n<thead>\n" + t + "</thead>\n" + e + "</table>\n"
									);
								}),
								(n.tablerow = function (t) {
									return "<tr>\n" + t + "</tr>\n";
								}),
								(n.tablecell = function (t, e) {
									var n = e.header ? "th" : "td";
									return (
										(e.align
											? "<" + n + ' align="' + e.align + '">'
											: "<" + n + ">") +
										t +
										"</" +
										n +
										">\n"
									);
								}),
								(n.strong = function (t) {
									return "<strong>" + t + "</strong>";
								}),
								(n.em = function (t) {
									return "<em>" + t + "</em>";
								}),
								(n.codespan = function (t) {
									return "<code>" + t + "</code>";
								}),
								(n.br = function () {
									return this.options.xhtml ? "<br/>" : "<br>";
								}),
								(n.del = function (t) {
									return "<del>" + t + "</del>";
								}),
								(n.link = function (t, e, n) {
									if (
										null ===
										(t = _(this.options.sanitize, this.options.baseUrl, t))
									)
										return n;
									var o = '<a href="' + g(t) + '"';
									return (
										e && (o += ' title="' + e + '"'), (o += ">" + n + "</a>")
									);
								}),
								(n.image = function (t, e, n) {
									if (
										null ===
										(t = _(this.options.sanitize, this.options.baseUrl, t))
									)
										return n;
									var o = '<img src="' + t + '" alt="' + n + '"';
									return (
										e && (o += ' title="' + e + '"'),
										(o += this.options.xhtml ? "/>" : ">")
									);
								}),
								(n.text = function (t) {
									return t;
								}),
								e
							);
						})(),
						$ = (function () {
							function t() {}
							var e = t.prototype;
							return (
								(e.strong = function (t) {
									return t;
								}),
								(e.em = function (t) {
									return t;
								}),
								(e.codespan = function (t) {
									return t;
								}),
								(e.del = function (t) {
									return t;
								}),
								(e.html = function (t) {
									return t;
								}),
								(e.text = function (t) {
									return t;
								}),
								(e.link = function (t, e, n) {
									return "" + n;
								}),
								(e.image = function (t, e, n) {
									return "" + n;
								}),
								(e.br = function () {
									return "";
								}),
								t
							);
						})(),
						q = (function () {
							function t() {
								this.seen = {};
							}
							var e = t.prototype;
							return (
								(e.serialize = function (t) {
									return t
										.toLowerCase()
										.trim()
										.replace(/<[!\/a-z].*?>/gi, "")
										.replace(
											/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g,
											"",
										)
										.replace(/\s/g, "-");
								}),
								(e.getNextSafeSlug = function (t, e) {
									var n = t,
										o = 0;
									if (this.seen.hasOwnProperty(n)) {
										o = this.seen[t];
										do {
											n = t + "-" + ++o;
										} while (this.seen.hasOwnProperty(n));
									}
									return e || ((this.seen[t] = o), (this.seen[n] = 0)), n;
								}),
								(e.slug = function (t, e) {
									void 0 === e && (e = {});
									var n = this.serialize(t);
									return this.getNextSafeSlug(n, e.dryrun);
								}),
								t
							);
						})(),
						U = (function () {
							function e(e) {
								(this.options = e || t.defaults),
									(this.options.renderer = this.options.renderer || new H()),
									(this.renderer = this.options.renderer),
									(this.renderer.options = this.options),
									(this.textRenderer = new $()),
									(this.slugger = new q());
							}
							(e.parse = function (t, n) {
								return new e(n).parse(t);
							}),
								(e.parseInline = function (t, n) {
									return new e(n).parseInline(t);
								});
							var n = e.prototype;
							return (
								(n.parse = function (t, e) {
									void 0 === e && (e = !0);
									var n,
										o,
										i,
										r,
										s,
										a,
										c,
										l,
										d,
										u,
										h,
										p,
										g,
										f,
										k,
										b,
										w,
										A,
										_,
										C = "",
										v = t.length;
									for (n = 0; n < v; n++)
										if (
											((u = t[n]),
											!(
												this.options.extensions &&
												this.options.extensions.renderers &&
												this.options.extensions.renderers[u.type]
											) ||
												(!1 ===
													(_ = this.options.extensions.renderers[u.type].call(
														{ parser: this },
														u,
													)) &&
													[
														"space",
														"hr",
														"heading",
														"code",
														"table",
														"blockquote",
														"list",
														"html",
														"paragraph",
														"text",
													].includes(u.type)))
										)
											switch (u.type) {
												case "space":
													continue;
												case "hr":
													C += this.renderer.hr();
													continue;
												case "heading":
													C += this.renderer.heading(
														this.parseInline(u.tokens),
														u.depth,
														m(this.parseInline(u.tokens, this.textRenderer)),
														this.slugger,
													);
													continue;
												case "code":
													C += this.renderer.code(u.text, u.lang, u.escaped);
													continue;
												case "table":
													for (
														l = "", c = "", r = u.header.length, o = 0;
														o < r;
														o++
													)
														c += this.renderer.tablecell(
															this.parseInline(u.header[o].tokens),
															{ header: !0, align: u.align[o] },
														);
													for (
														l += this.renderer.tablerow(c),
															d = "",
															r = u.rows.length,
															o = 0;
														o < r;
														o++
													) {
														for (
															c = "", s = (a = u.rows[o]).length, i = 0;
															i < s;
															i++
														)
															c += this.renderer.tablecell(
																this.parseInline(a[i].tokens),
																{ header: !1, align: u.align[i] },
															);
														d += this.renderer.tablerow(c);
													}
													C += this.renderer.table(l, d);
													continue;
												case "blockquote":
													(d = this.parse(u.tokens)),
														(C += this.renderer.blockquote(d));
													continue;
												case "list":
													for (
														h = u.ordered,
															p = u.start,
															g = u.loose,
															r = u.items.length,
															d = "",
															o = 0;
														o < r;
														o++
													)
														(b = (k = u.items[o]).checked),
															(w = k.task),
															(f = ""),
															k.task &&
																((A = this.renderer.checkbox(b)),
																g
																	? k.tokens.length > 0 &&
																		"paragraph" === k.tokens[0].type
																		? ((k.tokens[0].text =
																				A + " " + k.tokens[0].text),
																			k.tokens[0].tokens &&
																				k.tokens[0].tokens.length > 0 &&
																				"text" === k.tokens[0].tokens[0].type &&
																				(k.tokens[0].tokens[0].text =
																					A + " " + k.tokens[0].tokens[0].text))
																		: k.tokens.unshift({
																				type: "text",
																				text: A,
																			})
																	: (f += A)),
															(f += this.parse(k.tokens, g)),
															(d += this.renderer.listitem(f, w, b));
													C += this.renderer.list(d, h, p);
													continue;
												case "html":
													C += this.renderer.html(u.text);
													continue;
												case "paragraph":
													C += this.renderer.paragraph(
														this.parseInline(u.tokens),
													);
													continue;
												case "text":
													for (
														d = u.tokens ? this.parseInline(u.tokens) : u.text;
														n + 1 < v && "text" === t[n + 1].type;
													)
														d +=
															"\n" +
															((u = t[++n]).tokens
																? this.parseInline(u.tokens)
																: u.text);
													C += e ? this.renderer.paragraph(d) : d;
													continue;
												default:
													var y =
														'Token with "' + u.type + '" type was not found.';
													if (this.options.silent) return void console.error(y);
													throw new Error(y);
											}
										else C += _ || "";
									return C;
								}),
								(n.parseInline = function (t, e) {
									e = e || this.renderer;
									var n,
										o,
										i,
										r = "",
										s = t.length;
									for (n = 0; n < s; n++)
										if (
											((o = t[n]),
											!(
												this.options.extensions &&
												this.options.extensions.renderers &&
												this.options.extensions.renderers[o.type]
											) ||
												(!1 ===
													(i = this.options.extensions.renderers[o.type].call(
														{ parser: this },
														o,
													)) &&
													[
														"escape",
														"html",
														"link",
														"image",
														"strong",
														"em",
														"codespan",
														"br",
														"del",
														"text",
													].includes(o.type)))
										)
											switch (o.type) {
												case "escape":
												case "text":
													r += e.text(o.text);
													break;
												case "html":
													r += e.html(o.text);
													break;
												case "link":
													r += e.link(
														o.href,
														o.title,
														this.parseInline(o.tokens, e),
													);
													break;
												case "image":
													r += e.image(o.href, o.title, o.text);
													break;
												case "strong":
													r += e.strong(this.parseInline(o.tokens, e));
													break;
												case "em":
													r += e.em(this.parseInline(o.tokens, e));
													break;
												case "codespan":
													r += e.codespan(o.text);
													break;
												case "br":
													r += e.br();
													break;
												case "del":
													r += e.del(this.parseInline(o.tokens, e));
													break;
												default:
													var a =
														'Token with "' + o.type + '" type was not found.';
													if (this.options.silent) return void console.error(a);
													throw new Error(a);
											}
										else r += i || "";
									return r;
								}),
								e
							);
						})();
					function W(t, e, n) {
						if (null == t)
							throw new Error("marked(): input parameter is undefined or null");
						if ("string" != typeof t)
							throw new Error(
								"marked(): input parameter is of type " +
									Object.prototype.toString.call(t) +
									", string expected",
							);
						if (
							("function" == typeof e && ((n = e), (e = null)),
							F((e = S({}, W.defaults, e || {}))),
							n)
						) {
							var o,
								i = e.highlight;
							try {
								o = j.lex(t, e);
							} catch (t) {
								return n(t);
							}
							var r = function (t) {
								var r;
								if (!t)
									try {
										e.walkTokens && W.walkTokens(o, e.walkTokens),
											(r = U.parse(o, e));
									} catch (e) {
										t = e;
									}
								return (e.highlight = i), t ? n(t) : n(null, r);
							};
							if (!i || i.length < 3) return r();
							if ((delete e.highlight, !o.length)) return r();
							var s = 0;
							return (
								W.walkTokens(o, function (t) {
									"code" === t.type &&
										(s++,
										setTimeout(function () {
											i(t.text, t.lang, function (e, n) {
												if (e) return r(e);
												null != n &&
													n !== t.text &&
													((t.text = n), (t.escaped = !0)),
													0 == --s && r();
											});
										}, 0));
								}),
								void (0 === s && r())
							);
						}
						try {
							var a = j.lex(t, e);
							return (
								e.walkTokens && W.walkTokens(a, e.walkTokens), U.parse(a, e)
							);
						} catch (t) {
							if (
								((t.message +=
									"\nPlease report this to https://github.com/markedjs/marked."),
								e.silent)
							)
								return (
									"<p>An error occurred:</p><pre>" +
									g(t.message + "", !0) +
									"</pre>"
								);
							throw t;
						}
					}
					(W.options = W.setOptions =
						function (t) {
							return S(W.defaults, t), a(W.defaults), W;
						}),
						(W.getDefaults = s),
						(W.defaults = t.defaults),
						(W.use = function () {
							for (
								var t = arguments.length, e = new Array(t), n = 0;
								n < t;
								n++
							)
								e[n] = arguments[n];
							var o,
								i = S.apply(void 0, [{}].concat(e)),
								r = W.defaults.extensions || { renderers: {}, childTokens: {} };
							e.forEach(function (t) {
								if (
									(t.extensions &&
										((o = !0),
										t.extensions.forEach(function (t) {
											if (!t.name) throw new Error("extension name required");
											if (t.renderer) {
												var e = r.renderers ? r.renderers[t.name] : null;
												r.renderers[t.name] = e
													? function () {
															for (
																var n = arguments.length,
																	o = new Array(n),
																	i = 0;
																i < n;
																i++
															)
																o[i] = arguments[i];
															var r = t.renderer.apply(this, o);
															return !1 === r && (r = e.apply(this, o)), r;
														}
													: t.renderer;
											}
											if (t.tokenizer) {
												if (
													!t.level ||
													("block" !== t.level && "inline" !== t.level)
												)
													throw new Error(
														"extension level must be 'block' or 'inline'",
													);
												r[t.level]
													? r[t.level].unshift(t.tokenizer)
													: (r[t.level] = [t.tokenizer]),
													t.start &&
														("block" === t.level
															? r.startBlock
																? r.startBlock.push(t.start)
																: (r.startBlock = [t.start])
															: "inline" === t.level &&
																(r.startInline
																	? r.startInline.push(t.start)
																	: (r.startInline = [t.start])));
											}
											t.childTokens && (r.childTokens[t.name] = t.childTokens);
										})),
									t.renderer &&
										(function () {
											var e = W.defaults.renderer || new H(),
												n = function (n) {
													var o = e[n];
													e[n] = function () {
														for (
															var i = arguments.length, r = new Array(i), s = 0;
															s < i;
															s++
														)
															r[s] = arguments[s];
														var a = t.renderer[n].apply(e, r);
														return !1 === a && (a = o.apply(e, r)), a;
													};
												};
											for (var o in t.renderer) n(o);
											i.renderer = e;
										})(),
									t.tokenizer &&
										(function () {
											var e = W.defaults.tokenizer || new O(),
												n = function (n) {
													var o = e[n];
													e[n] = function () {
														for (
															var i = arguments.length, r = new Array(i), s = 0;
															s < i;
															s++
														)
															r[s] = arguments[s];
														var a = t.tokenizer[n].apply(e, r);
														return !1 === a && (a = o.apply(e, r)), a;
													};
												};
											for (var o in t.tokenizer) n(o);
											i.tokenizer = e;
										})(),
									t.walkTokens)
								) {
									var e = W.defaults.walkTokens;
									i.walkTokens = function (n) {
										t.walkTokens.call(this, n), e && e.call(this, n);
									};
								}
								o && (i.extensions = r), W.setOptions(i);
							});
						}),
						(W.walkTokens = function (t, e) {
							for (
								var n,
									o = function () {
										var t = n.value;
										switch ((e.call(W, t), t.type)) {
											case "table":
												for (var o, i = r(t.header); !(o = i()).done; ) {
													var s = o.value;
													W.walkTokens(s.tokens, e);
												}
												for (var a, c = r(t.rows); !(a = c()).done; )
													for (var l, d = r(a.value); !(l = d()).done; ) {
														var u = l.value;
														W.walkTokens(u.tokens, e);
													}
												break;
											case "list":
												W.walkTokens(t.items, e);
												break;
											default:
												W.defaults.extensions &&
												W.defaults.extensions.childTokens &&
												W.defaults.extensions.childTokens[t.type]
													? W.defaults.extensions.childTokens[t.type].forEach(
															function (n) {
																W.walkTokens(t[n], e);
															},
														)
													: t.tokens && W.walkTokens(t.tokens, e);
										}
									},
									i = r(t);
								!(n = i()).done;
							)
								o();
						}),
						(W.parseInline = function (t, e) {
							if (null == t)
								throw new Error(
									"marked.parseInline(): input parameter is undefined or null",
								);
							if ("string" != typeof t)
								throw new Error(
									"marked.parseInline(): input parameter is of type " +
										Object.prototype.toString.call(t) +
										", string expected",
								);
							F((e = S({}, W.defaults, e || {})));
							try {
								var n = j.lexInline(t, e);
								return (
									e.walkTokens && W.walkTokens(n, e.walkTokens),
									U.parseInline(n, e)
								);
							} catch (t) {
								if (
									((t.message +=
										"\nPlease report this to https://github.com/markedjs/marked."),
									e.silent)
								)
									return (
										"<p>An error occurred:</p><pre>" +
										g(t.message + "", !0) +
										"</pre>"
									);
								throw t;
							}
						}),
						(W.Parser = U),
						(W.parser = U.parse),
						(W.Renderer = H),
						(W.TextRenderer = $),
						(W.Lexer = j),
						(W.lexer = j.lex),
						(W.Tokenizer = O),
						(W.Slugger = q),
						(W.parse = W);
					var K = W.options,
						G = W.setOptions,
						J = W.use,
						Y = W.walkTokens,
						Q = W.parseInline,
						X = W,
						Z = U.parse,
						tt = j.lex;
					(t.Lexer = j),
						(t.Parser = U),
						(t.Renderer = H),
						(t.Slugger = q),
						(t.TextRenderer = $),
						(t.Tokenizer = O),
						(t.getDefaults = s),
						(t.lexer = tt),
						(t.marked = W),
						(t.options = K),
						(t.parse = X),
						(t.parseInline = Q),
						(t.parser = Z),
						(t.setOptions = G),
						(t.use = J),
						(t.walkTokens = Y),
						Object.defineProperty(t, "__esModule", { value: !0 });
				})(e);
			},
			function (t, e) {
				var n;
				n = (function () {
					return this;
				})();
				try {
					n = n || new Function("return this")();
				} catch (t) {
					"object" == typeof window && (n = window);
				}
				t.exports = n;
			},
			function (t, e) {
				t.exports = function (t) {
					if (!t.webpackPolyfill) {
						var e = Object.create(t);
						e.children || (e.children = []),
							Object.defineProperty(e, "loaded", {
								enumerable: !0,
								get: function () {
									return e.l;
								},
							}),
							Object.defineProperty(e, "id", {
								enumerable: !0,
								get: function () {
									return e.i;
								},
							}),
							Object.defineProperty(e, "exports", { enumerable: !0 }),
							(e.webpackPolyfill = 1);
					}
					return e;
				};
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/renderer.css",
						],
						names: [],
						mappings: "AAMA,qDACC,YACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Elements marked by the Renderer as hidden should be invisible in the editor. */\n.ck.ck-editor__editable span[data-ck-unsafe-element] {\n\tdisplay: none;\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-placeholder,.ck .ck-placeholder{position:relative}.ck.ck-placeholder:before,.ck .ck-placeholder:before{position:absolute;left:0;right:0;content:attr(data-placeholder);pointer-events:none}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck.ck-placeholder:before,.ck .ck-placeholder:before{cursor:text;color:var(--ck-color-engine-placeholder-text)}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css",
						],
						names: [],
						mappings:
							"AAMA,uCAEC,iBAWD,CATC,qDACC,iBAAkB,CAClB,MAAO,CACP,OAAQ,CACR,8BAA+B,CAG/B,mBACD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDACC,WAAY,CACZ,6CACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n\tposition: relative;\n\n\t&::before {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tcontent: attr(data-placeholder);\n\n\t\t/* See ckeditor/ckeditor5#469. */\n\t\tpointer-events: none;\n\t}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n\n/*\n * Rules for the `ck-placeholder` are loaded before the rules for `ck-reset_all` in the base CKEditor 5 DLL build.\n * This fix overwrites the incorrectly set `position: static` from `ck-reset_all`.\n * See https://github.com/ckeditor/ckeditor5/issues/11418.\n */\n.ck.ck-reset_all .ck-placeholder {\n\tposition: relative;\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n\t&::before {\n\t\tcursor: text;\n\t\tcolor: var(--ck-color-engine-placeholder-text);\n\t}\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;width:auto;height:auto;position:static}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,0.3);--ck-color-focus-error-shadow:rgba(255,64,31,0.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,0.15);--ck-color-shadow-drop-active:rgba(0,0,0,0.2);--ck-color-shadow-inner:rgba(0,0,0,0.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,0.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,177,255,0.1);--ck-color-link-fake-selection:rgba(31,177,255,0.3);--ck-color-highlight-background:#ff0;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{margin:0;padding:0;border:0;background:transparent;text-decoration:none;vertical-align:middle;transition:none;word-wrap:break-word}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);color:var(--ck-color-text);text-align:left;white-space:nowrap;cursor:auto;float:none}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){padding:10px;border:2px groove #dfdee3}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{padding:0;border:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_hidden.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_reset.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_zindex.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_transition.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css",
						],
						names: [],
						mappings:
							"AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CACtB,UAAW,CACX,WAAY,CACZ,eACD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,sDAA8D,CAC9D,iDAAyD,CACzD,yCAAqD,CACrD,uCAAsD,CACtD,6CAA0D,CAC1D,uCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,qDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,wDAAmE,CACnE,mDAAgE,CAIhE,oCAAwD,CCvGxD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJuGD,CIjGA,2EAIC,QAAS,CACT,SAAU,CACV,QAAS,CACT,sBAAuB,CACvB,oBAAqB,CACrB,qBAAsB,CACtB,eAAgB,CAGhB,oBACD,CAKA,8DAGC,wBAAyB,CACzB,iGAAkG,CAClG,0BAA2B,CAC3B,eAAgB,CAChB,kBAAmB,CACnB,WAAY,CACZ,UACD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDACC,YAAa,CACb,yBACD,CAEA,qEAEC,SAAU,CACV,QACD,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n\t/* Override selector specificity. Otherwise, all elements with some display\n\tstyle defined will override this one, which is not a desired result. */\n\tdisplay: none !important;\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\tbox-sizing: border-box;\n\twidth: auto;\n\theight: auto;\n\tposition: static;\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-z-default: 1;\n\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n\ttransition: none !important;\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-base-foreground: \t\t\t\t\t\t\t\thsl(0, 0%, 98%);\n\t--ck-color-base-background: \t\t\t\t\t\t\t\thsl(0, 0%, 100%);\n\t--ck-color-base-border: \t\t\t\t\t\t\t\t\thsl(220, 6%, 81%);\n\t--ck-color-base-action: \t\t\t\t\t\t\t\t\thsl(104, 50.2%, 42.5%);\n\t--ck-color-base-focus: \t\t\t\t\t\t\t\t\t\thsl(209, 92%, 70%);\n\t--ck-color-base-text: \t\t\t\t\t\t\t\t\t\thsl(0, 0%, 20%);\n\t--ck-color-base-active: \t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\t--ck-color-base-active-focus:\t\t\t\t\t\t\t\thsl(218.2, 100%, 52.5%);\n\t--ck-color-base-error:\t\t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------ */\n\n\t--ck-color-focus-border-coordinates: \t\t\t\t\t\t218, 81.8%, 56.9%;\n\t--ck-color-focus-border: \t\t\t\t\t\t\t\t\thsl(var(--ck-color-focus-border-coordinates));\n\t--ck-color-focus-outer-shadow:\t\t\t\t\t\t\t\thsl(212.4, 89.3%, 89%);\n\t--ck-color-focus-disabled-shadow:\t\t\t\t\t\t\thsla(209, 90%, 72%,.3);\n\t--ck-color-focus-error-shadow:\t\t\t\t\t\t\t\thsla(9,100%,56%,.3);\n\t--ck-color-text: \t\t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-shadow-drop: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.15);\n\t--ck-color-shadow-drop-active:\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.2);\n\t--ck-color-shadow-inner: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Buttons ------------------------------------------------------------------------------- */\n\n\t--ck-color-button-default-background: \t\t\t\t\t\ttransparent;\n\t--ck-color-button-default-hover-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-active-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-disabled-background: \t\t\t\ttransparent;\n\n\t--ck-color-button-on-background: \t\t\t\t\t\t\thsl(212, 100%, 97.1%);\n\t--ck-color-button-on-hover-background: \t\t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-active-background: \t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-disabled-background: \t\t\t\t\thsl(211, 15%, 95%);\n\t--ck-color-button-on-color:\t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\n\n\t--ck-color-button-action-background: \t\t\t\t\t\tvar(--ck-color-base-action);\n\t--ck-color-button-action-hover-background: \t\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-active-background: \t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-disabled-background: \t\t\t\thsl(104, 44%, 58%);\n\t--ck-color-button-action-text: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t--ck-color-button-save: \t\t\t\t\t\t\t\t\thsl(120, 100%, 27%);\n\t--ck-color-button-cancel: \t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t--ck-color-switch-button-off-background:\t\t\t\t\thsl(0, 0%, 57.6%);\n\t--ck-color-switch-button-off-hover-background:\t\t\t\thsl(0, 0%, 49%);\n\t--ck-color-switch-button-on-background:\t\t\t\t\t\tvar(--ck-color-button-action-background);\n\t--ck-color-switch-button-on-hover-background:\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-switch-button-inner-background:\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-switch-button-inner-shadow:\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Dropdown ------------------------------------------------------------------------------ */\n\n\t--ck-color-dropdown-panel-background: \t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-dropdown-panel-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Input --------------------------------------------------------------------------------- */\n\n\t--ck-color-input-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-input-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-error-border:\t\t\t\t\t\t\t\tvar(--ck-color-base-error);\n\t--ck-color-input-text: \t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-input-disabled-background: \t\t\t\t\t\thsl(0, 0%, 95%);\n\t--ck-color-input-disabled-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-disabled-text: \t\t\t\t\t\t\thsl(0, 0%, 46%);\n\n\t/* -- List ---------------------------------------------------------------------------------- */\n\n\t--ck-color-list-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-list-button-hover-background: \t\t\t\t\tvar(--ck-color-button-default-hover-background);\n\t--ck-color-list-button-on-background: \t\t\t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-background-focus: \t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-text:\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Panel --------------------------------------------------------------------------------- */\n\n\t--ck-color-panel-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-panel-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Toolbar ------------------------------------------------------------------------------- */\n\n\t--ck-color-toolbar-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-toolbar-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Tooltip ------------------------------------------------------------------------------- */\n\n\t--ck-color-tooltip-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-tooltip-text: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Engine -------------------------------------------------------------------------------- */\n\n\t--ck-color-engine-placeholder-text: \t\t\t\t\t\thsl(0, 0%, 44%);\n\n\t/* -- Upload -------------------------------------------------------------------------------- */\n\n\t--ck-color-upload-bar-background:\t\t \t\t\t\t\thsl(209, 92%, 70%);\n\n\t/* -- Link -------------------------------------------------------------------------------- */\n\n\t--ck-color-link-default:\t\t\t\t\t\t\t\t\thsl(240, 100%, 47%);\n\t--ck-color-link-selected-background:\t\t\t\t\t\thsla(201, 100%, 56%, 0.1);\n\t--ck-color-link-fake-selection:\t\t\t\t\t\t\t\thsla(201, 100%, 56%, 0.3);\n\n\t/* -- Search result highlight ---------------------------------------------------------------- */\n\n\t--ck-color-highlight-background:\t\t\t\t\t\t\thsl(60, 100%, 50%)\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * An opacity value of disabled UI item.\n\t */\n\t--ck-disabled-opacity: .5;\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * The geometry of the of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n\t/**\n\t * A visual style of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when disabled).\n\t */\n\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when has errors).\n\t */\n\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n\t/**\n\t * A visual style of focused element's border or outline.\n\t */\n\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-font-size-base: 13px;\n\t--ck-line-height-base: 1.84615;\n\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n\t--ck-font-size-tiny: 0.7em;\n\t--ck-font-size-small: 0.75em;\n\t--ck-font-size-normal: 1em;\n\t--ck-font-size-big: 1.4em;\n\t--ck-font-size-large: 1.8em;\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* This is super-important. This is **manually** adjusted so a button without an icon\n\tis never smaller than a button with icon, additionally making sure that text-less buttons\n\tare perfect squares. The value is also shared by other components which should stay "in-line"\n\twith buttons. */\n\t--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* Do not include inheritable rules here. */\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: transparent;\n\ttext-decoration: none;\n\tvertical-align: middle;\n\ttransition: none;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n\tword-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* These are rule inherited by all children elements. */\n\tborder-collapse: collapse;\n\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n\tcolor: var(--ck-color-text);\n\ttext-align: left;\n\twhite-space: nowrap;\n\tcursor: auto;\n\tfloat: none;\n}\n\n.ck-reset_all {\n\t& .ck-rtl *:not(.ck-reset_all-excluded *) {\n\t\ttext-align: right;\n\t}\n\n\t& iframe:not(.ck-reset_all-excluded *) {\n\t\t/* For IE */\n\t\tvertical-align: inherit;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *) {\n\t\twhite-space: pre-wrap;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *),\n\t& input[type="text"]:not(.ck-reset_all-excluded *),\n\t& input[type="password"]:not(.ck-reset_all-excluded *) {\n\t\tcursor: text;\n\t}\n\n\t& textarea[disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="text"][disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {\n\t\tcursor: default;\n\t}\n\n\t& fieldset:not(.ck-reset_all-excluded *) {\n\t\tpadding: 10px;\n\t\tborder: 2px groove hsl(255, 7%, 88%);\n\t}\n\n\t& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {\n\t\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n\t\tpadding: 0;\n\t\tborder: 0\n\t}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n\ttext-align: right;\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n\t--ck-border-radius: 2px;\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * A visual style of element's inner shadow (i.e. input).\n\t */\n\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n\t/**\n\t * A visual style of element's drop shadow (i.e. panel).\n\t */\n\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n\t/**\n\t * A visual style of element's active shadow (i.e. comment or suggestion).\n\t */\n\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-spacing-unit: \t\t\t\t\t\t0.6em;\n\t--ck-spacing-large: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 1.5);\n\t--ck-spacing-standard: \t\t\t\t\tvar(--ck-spacing-unit);\n\t--ck-spacing-medium: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.8);\n\t--ck-spacing-small: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.5);\n\t--ck-spacing-tiny: \t\t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.3);\n\t--ck-spacing-extra-tiny: \t\t\t\tcalc(var(--ck-spacing-unit) * 0.16);\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{width:0;height:0;border-style:solid}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:var(--ck-balloon-arrow-height);border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:0}.ck.ck-balloon-panel[class*=arrow_n]:before{border-bottom-color:var(--ck-color-panel-border);margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-color:transparent;border-right-color:transparent;border-top-color:transparent}.ck.ck-balloon-panel[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background);margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:0;border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-top-color:var(--ck-color-panel-border);filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent}.ck.ck-balloon-panel[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background);margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-left-width:var(--ck-balloon-arrow-height);border-bottom-width:var(--ck-balloon-arrow-half-width);border-right-width:0;border-top-width:var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-left-color:var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-bottom-color:transparent;border-right-color:transparent;border-top-color:transparent}.ck.ck-balloon-panel[class*=arrow_e]:after{border-left-color:var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-left-width:0;border-bottom-width:var(--ck-balloon-arrow-half-width);border-right-width:var(--ck-balloon-arrow-height);border-top-width:var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_w]:before{border-right-color:var(--ck-color-panel-border);margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-left-color:transparent;border-bottom-color:transparent;border-top-color:transparent}.ck.ck-balloon-panel[class*=arrow_w]:after{border-right-color:var(--ck-color-panel-background);margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{right:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{right:25%;margin-right:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{right:25%;margin-right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{right:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}',
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
						],
						names: [],
						mappings:
							"AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBEPC,oCAA8B,CFW9B,eAAgB,CAEhB,2CAA4C,CAC5C,wEAuLD,CApLE,+GAEC,OAAQ,CACR,QAAS,CACT,kBACD,CAIA,uFAEC,oDAAoH,CAApH,kDAAoH,CAApH,qDAAoH,CAApH,kBACD,CAEA,4CACC,gDAA8E,CAC9E,kDACD,CAEA,uFAJC,6BAA8E,CAA9E,8BAA8E,CAA9E,4BAOD,CAHA,2CACC,oDAAkF,CAClF,gFACD,CAIA,uFAEC,oDAAoH,CAApH,qBAAoH,CAApH,qDAAoH,CAApH,+CACD,CAEA,4CACC,6CAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,uFALC,6BAAkE,CAAlE,+BAAkE,CAAlE,8BAQD,CAHA,2CACC,iDAAkF,CAClF,mFACD,CAIA,uFAEC,gDAAoH,CAApH,sDAAoH,CAApH,oBAAoH,CAApH,mDACD,CAEA,4CACC,8CAA8E,CAC9E,oDACD,CAEA,uFAJC,+BAA8E,CAA9E,8BAA8E,CAA9E,4BAOD,CAHA,2CACC,kDAAkF,CAClF,kFACD,CAIA,uFAEC,mBAAoH,CAApH,sDAAoH,CAApH,iDAAoH,CAApH,mDACD,CAEA,4CACC,+CAA8E,CAC9E,mDACD,CAEA,uFAJC,6BAA8E,CAA9E,+BAA8E,CAA9E,4BAOD,CAHA,2CACC,mDAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,8CACD,CAIA,2GAEC,+CAAkD,CAClD,8CACD,CAIA,2GAEC,gDAAmD,CACnD,8CACD,CAIA,6GAEC,SAAU,CACV,uDAA0D,CAC1D,8CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,8CACD,CAIA,6GAEC,SAAU,CACV,uDAA0D,CAC1D,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAEC,6CAAgD,CAChD,sDAAyD,CACzD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD",
						sourcesContent: [
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Make sure the balloon arrow does not float over its children. */\n\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n\tdisplay: none;\n\tposition: absolute;\n\n\tz-index: var(--ck-z-modal);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tposition: absolute;\n\t\t}\n\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_visible {\n\t\tdisplay: block;\n\t}\n}\n',
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-border-width: 1px;\n\t--ck-balloon-arrow-offset: 2px;\n\t--ck-balloon-arrow-height: 10px;\n\t--ck-balloon-arrow-half-width: 8px;\n\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder-style: solid;\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\n\t\t\tmargin-top: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\n\t\t\tmargin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: var(--ck-color-panel-border) transparent transparent;\n\t\t\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n\t\t\tmargin-bottom: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\n\t\t\tmargin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_e"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-border);\n\t\t\tmargin-right: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-background);\n\t\t\tmargin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_w"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent var(--ck-color-panel-border) transparent transparent;\n\t\t\tmargin-left: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent var(--ck-color-panel-background) transparent transparent;\n\t\t\tmargin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_n {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_ne {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_s {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_se {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_smw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nmw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_e {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_w {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-balloon-panel.ck-tooltip{pointer-events:none;z-index:calc(var(--ck-z-modal) + 100);--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{font-size:.9em;line-height:1.5;color:var(--ck-color-tooltip-text)}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css",
						],
						names: [],
						mappings:
							"AAKA,gCAEC,mBAAoB,CAEpB,qCAAwC,CCDxC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,8DAA+D,CAE/D,kCDJD,CCMC,kDACC,cAAe,CACf,eAAgB,CAChB,kCACD,CAbD,gCAgBC,eAMD,CAHC,uCACC,YACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t/* Keep tooltips transparent for any interactions. */\n\tpointer-events: none;\n\n\tz-index: calc( var(--ck-z-modal) + 100 );\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t--ck-balloon-border-width: 0px;\n\t--ck-balloon-arrow-offset: 0px;\n\t--ck-balloon-arrow-half-width: 4px;\n\t--ck-balloon-arrow-height: 4px;\n\t--ck-color-panel-background: var(--ck-color-tooltip-background);\n\n\tpadding: 0 var(--ck-spacing-medium);\n\n\t& .ck-tooltip__text {\n\t\tfont-size: .9em;\n\t\tline-height: 1.5;\n\t\tcolor: var(--ck-color-tooltip-text);\n\t}\n\n\t/* Reset balloon panel styles */\n\tbox-shadow: none;\n\n\t/* Hide the default shadow of the .ck-balloon-panel tip */\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n',
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{width:var(--ck-icon-size);height:var(--ck-icon-size);font-size:.8333350694em;will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css",
						],
						names: [],
						mappings:
							"AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YACC,yBAA0B,CAC1B,0BAA2B,CAG3B,uBAAwB,CAMxB,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n\tvertical-align: middle;\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n\twidth: var(--ck-icon-size);\n\theight: var(--ck-icon-size);\n\n\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n\tfont-size: .8333350694em;\n\n\t/* Inherit cursor style (#5). */\n\tcursor: inherit;\n\n\t/* This will prevent blurry icons on Firefox. See #340. */\n\twill-change: transform;\n\n\t& * {\n\t\t/* Inherit cursor style (#5). */\n\t\tcursor: inherit;\n\t}\n\n\t/* Allows dynamic coloring of an icon by inheriting its color from the parent. */\n\t&.ck-icon_inherit-color {\n\t\tcolor: inherit;\n\n\t\t& * {\n\t\t\tcolor: inherit;\n\n\t\t\t&:not([fill]) {\n\t\t\t\t/* Needed by FF. */\n\t\t\t\tfill: currentColor;\n\t\t\t}\n\t\t}\n\t}\n}\n',
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-button,a.ck.ck-button{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:inline-flex;align-items:center;justify-content:left}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{white-space:nowrap;cursor:default;vertical-align:middle;padding:var(--ck-spacing-tiny);text-align:center;min-width:var(--ck-ui-component-min-height);min-height:var(--ck-ui-component-min-height);line-height:1;font-size:inherit;border:1px solid transparent;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;-webkit-appearance:none}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{font-size:inherit;font-weight:inherit;color:inherit;cursor:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__icon{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-right:calc(var(--ck-spacing-small)*-1);margin-left:var(--ck-spacing-small)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
						],
						names: [],
						mappings:
							"AAOA,6BCEC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBAAgB,CDDhB,iBAAkB,CAClB,mBAAoB,CACpB,kBAAmB,CACnB,oBAgBD,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEjBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BAKC,kBAAmB,CACnB,cAAe,CACf,qBAAsB,CACtB,8BAA+B,CAC/B,iBAAkB,CAGlB,2CAA4C,CAC5C,4CAA6C,CAI7C,aAAc,CAGd,iBAAkB,CAGlB,4BAA6B,CAG7B,4DAA8D,CAG9D,uBA+GD,CA7GC,oFGjCA,YAAa,CACb,2BAA2B,CCF3B,2CJsCA,CAIC,kJAEC,aACD,CAGD,iEAEC,iBAAkB,CAClB,mBAAoB,CACpB,aAAc,CACd,cAAe,CAIf,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAEA,uFK3FD,kCL6FC,CAGA,yFKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAOE,6CAAgD,CAChD,mCAEF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD",
						sourcesContent: [
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-unselectable;\n\n\tposition: relative;\n\tdisplay: inline-flex;\n\talign-items: center;\n\tjustify-content: left;\n\n\t& .ck-button__label {\n\t\tdisplay: none;\n\t}\n\n\t&.ck-button_with-text {\n\t\t& .ck-button__label {\n\t\t\tdisplay: inline-block;\n\t\t}\n\t}\n\n\t/* Center the icon horizontally in a button without text. */\n\t&:not(.ck-button_with-text)  {\n\t\tjustify-content: center;\n\t}\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../mixins/_button.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-button-colors --ck-color-button-default;\n\t@mixin ck-rounded-corners;\n\n\twhite-space: nowrap;\n\tcursor: default;\n\tvertical-align: middle;\n\tpadding: var(--ck-spacing-tiny);\n\ttext-align: center;\n\n\t/* A very important piece of styling. Go to variable declaration to learn more. */\n\tmin-width: var(--ck-ui-component-min-height);\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Normalize the height of the line. Removing this will break consistent height\n\tamong text and text-less buttons (with icons). */\n\tline-height: 1;\n\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t/* Avoid flickering when the foucs border shows up. */\n\tborder: 1px solid transparent;\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\n\t-webkit-appearance: none;\n\n\t&:active,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t/* Allow icon coloring using the text "color" property. */\n\t& .ck-button__icon {\n\t\t& use,\n\t\t& use * {\n\t\t\tcolor: inherit;\n\t\t}\n\t}\n\n\t& .ck-button__label {\n\t\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\t\tfont-size: inherit;\n\t\tfont-weight: inherit;\n\t\tcolor: inherit;\n\t\tcursor: inherit;\n\n\t\t/* Must be consistent with .ck-icon\'s vertical align. Otherwise, buttons with and\n\t\twithout labels (but with icons) have different sizes in Chrome */\n\t\tvertical-align: middle;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\t}\n\n\t& .ck-button__keystroke {\n\t\tcolor: inherit;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t}\n\n\t\tfont-weight: bold;\n\t\topacity: .7;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t&.ck-disabled {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t/* The disabled button should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t\t& .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t& .ck-button__keystroke {\n\t\t\topacity: .3;\n\t\t}\n\t}\n\n\t&.ck-button_with-text {\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-button_with-keystroke {\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__label {\n\t\t\tflex-grow: 1;\n\t\t}\n\t}\n\n\t/* A style of the button which is currently on, e.g. its feature is active. */\n\t&.ck-on {\n\t\t@mixin ck-button-colors --ck-color-button-on;\n\n\t\tcolor: var(--ck-color-button-on-color);\n\t}\n\n\t&.ck-button-save {\n\t\tcolor: var(--ck-color-button-save);\n\t}\n\n\t&.ck-button-cancel {\n\t\tcolor: var(--ck-color-button-cancel);\n\t}\n}\n\n/* A style of the button which handles the primary action. */\n.ck.ck-button-action,\na.ck.ck-button-action {\n\t@mixin ck-button-colors --ck-color-button-action;\n\n\tcolor: var(--ck-color-button-action-text);\n}\n\n.ck.ck-button-bold,\na.ck.ck-button-bold {\n\tfont-weight: bold;\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n\tbackground: var($(prefix)-background);\n\n\t&:not(.ck-disabled) {\n\t\t&:hover {\n\t\t\tbackground: var($(prefix)-hover-background);\n\t\t}\n\n\t\t&:active {\n\t\t\tbackground: var($(prefix)-active-background);\n\t\t}\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t&.ck-disabled {\n\t\tbackground: var($(prefix)-disabled-background);\n\t}\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{color:inherit;background:transparent}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;border:1px solid transparent;width:var(--ck-switch-button-toggle-width);background:var(--ck-color-switch-button-off-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*0.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{width:var(--ck-switch-button-toggle-inner-size);height:var(--ck-switch-button-toggle-inner-size);background:var(--ck-color-switch-button-inner-background);transition:all .3s ease}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;outline:none;box-shadow:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline-offset:1px;outline:var(--ck-focus-ring)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var(--ck-switch-button-translation))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var(--ck-switch-button-translation)*-1))}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
						],
						names: [],
						mappings:
							"AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QACC,aAAc,CACd,sBACD,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAeC,iFAAsF,CACtF,4BAA6B,CAC7B,0CAA2C,CAC3C,uDAsBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,+CASF,CAXA,2EAKC,+CAAgD,CAChD,gDAAiD,CACjD,yDAA0D,CAG1D,uBACD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CACzB,YAAa,CACb,eAOD,CALC,uDACC,iGAAmG,CACnG,kBAAmB,CACnB,4BACD,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,yDAMF,CAXA,2FASE,kEAEF",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__toggle {\n\t\tdisplay: block;\n\n\t\t& .ck-button__toggle__inner {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floating–point numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n\t/* 34px at 13px font-size */\n\t--ck-switch-button-toggle-width: 2.6153846154em;\n\t/* 14px at 13px font-size */\n\t--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);\n\t--ck-switch-button-translation: calc(\n\t\tvar(--ck-switch-button-toggle-width) -\n\t\tvar(--ck-switch-button-toggle-inner-size) -\n\t\t2px /* Border */\n\t);\n\t--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n}\n\n.ck.ck-button.ck-switchbutton {\n\t/* Unlike a regular button, the switch button text color and background should never change.\n\t * Changing toggle switch (background, outline) is enough to carry the information about the\n\t * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)\n\t */\n\t&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {\n\t\tcolor: inherit;\n\t\tbackground: transparent;\n\t}\n\n\t& .ck-button__label {\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-right: calc(2 * var(--ck-spacing-large));\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-left: calc(2 * var(--ck-spacing-large));\n\t\t}\n\t}\n\n\t& .ck-button__toggle {\n\t\t@mixin ck-rounded-corners;\n\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Make sure the toggle is always to the right as far as possible. */\n\t\t\tmargin-left: auto;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Make sure the toggle is always to the left as far as possible. */\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Apply some smooth transition to the box-shadow and border. */\n\t\t/* Gently animate the background color of the toggle switch */\n\t\ttransition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;\n\t\tborder: 1px solid transparent;\n\t\twidth: var(--ck-switch-button-toggle-width);\n\t\tbackground: var(--ck-color-switch-button-off-background);\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: calc(.5 * var(--ck-border-radius));\n\t\t\t}\n\n\t\t\twidth: var(--ck-switch-button-toggle-inner-size);\n\t\t\theight: var(--ck-switch-button-toggle-inner-size);\n\t\t\tbackground: var(--ck-color-switch-button-inner-background);\n\n\t\t\t/* Gently animate the inner part of the toggle switch */\n\t\t\ttransition: all 300ms ease;\n\t\t}\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-off-hover-background);\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\tbox-shadow: var(--ck-switch-button-inner-hover-shadow);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-button__toggle {\n\t\t@mixin ck-disabled;\n\t}\n\n\t/* Overriding default .ck-button:focus styles + an outline around the toogle */\n\t&:focus {\n\t\tborder-color: transparent;\n\t\toutline: none;\n\t\tbox-shadow: none;\n\n\t\t& .ck-button__toggle {\n\t\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);\n\t\t\toutline-offset: 1px;\n\t\t\toutline: var(--ck-focus-ring);\n\t\t}\n\t}\n\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-on {\n\t\t& .ck-button__toggle {\n\t\t\tbackground: var(--ck-color-switch-button-on-background);\n\n\t\t\t&:hover {\n\t\t\t\tbackground: var(--ck-color-switch-button-on-hover-background);\n\t\t\t}\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\t/*\n\t\t\t\t* Move the toggle switch to the right. It will be animated.\n\t\t\t\t*/\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\ttransform: translateX( var( --ck-switch-button-translation ) );\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{width:var(--ck-color-grid-tile-size);height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;border:0}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{display:none;color:var(--ck-color-color-grid-check-icon)}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css",
						],
						names: [],
						mappings:
							"AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBACC,oCAAqC,CACrC,qCAAsC,CACtC,wCAAyC,CACzC,yCAA0C,CAC1C,SAAU,CACV,8BAA+B,CAC/B,QAmCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCACC,YAAa,CACb,2CACD,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n\tdisplay: grid;\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-grid-tile-size: 24px;\n\n\t/* Not using global colors here because these may change but some colors in a pallette\n\t * require special treatment. For instance, this ensures no matter what the UI text color is,\n\t * the check icon will look good on the black color tile. */\n\t--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);\n}\n\n.ck.ck-color-grid {\n\tgrid-gap: 5px;\n\tpadding: 8px;\n}\n\n.ck.ck-color-grid__tile {\n\twidth: var(--ck-color-grid-tile-size);\n\theight: var(--ck-color-grid-tile-size);\n\tmin-width: var(--ck-color-grid-tile-size);\n\tmin-height: var(--ck-color-grid-tile-size);\n\tpadding: 0;\n\ttransition: .2s ease box-shadow;\n\tborder: 0;\n\n\t&.ck-disabled {\n\t\tcursor: unset;\n\t\ttransition: unset;\n\t}\n\n\t&.ck-color-table__color-tile_bordered {\n\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\tdisplay: none;\n\t\tcolor: var(--ck-color-color-grid-check-icon);\n\t}\n\n\t&.ck-on {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);\n\n\t\t& .ck.ck-icon {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t&.ck-on,\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\t/* Disable the default .ck-button\'s border ring. */\n\t\tborder: 0;\n\t}\n\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t}\n}\n\n.ck.ck-color-grid__label {\n\tpadding: 0 var(--ck-spacing-standard);\n}\n',
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					'.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-top-right-radius:unset;border-bottom-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-top-left-radius:unset;border-bottom-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-top-left-radius:unset;border-bottom-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-top-right-radius:unset;border-bottom-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{content:"";position:absolute;width:1px;height:100%;background-color:var(--ck-color-split-button-hover-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}',
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
						],
						names: [],
						mappings:
							"AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAIE,6BAA8B,CAC9B,gCAQF,CAbA,oIAUE,4BAA6B,CAC7B,+BAEF,CAEA,0CAGC,eAiBD,CApBA,oDAOE,4BAA6B,CAC7B,+BAYF,CApBA,oDAaE,6BAA8B,CAC9B,gCAMF,CAHC,8CACC,mCACD,CASA,0KACC,wDACD,CAIA,8JACC,UAAW,CACX,iBAAkB,CAClB,SAAU,CACV,WAAY,CACZ,0DACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCC7EA,eDuFA,CAVA,qHCzEC,qCDmFD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-splitbutton {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-splitbutton__action:focus {\n\t\tz-index: calc(var(--ck-z-default) + 1);\n\t}\n}\n\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-split-button-hover-background: hsl(0, 0%, 92%);\n\t--ck-color-split-button-hover-border: hsl(0, 0%, 70%);\n}\n\n.ck.ck-splitbutton {\n\t/*\n\t * Note: ck-rounded and ck-dir mixins don\'t go together (because they both use @nest).\n\t */\n\t&:hover > .ck-splitbutton__action,\n\t&.ck-splitbutton_open > .ck-splitbutton__action {\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the action button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the action button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\t}\n\n\t& > .ck-splitbutton__arrow {\n\t\t/* It\'s a text-less button and since the icon is positioned absolutely in such situation,\n\t\tit must get some arbitrary min-width. */\n\t\tmin-width: unset;\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the arrow button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the arrow button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t& svg {\n\t\t\twidth: var(--ck-dropdown-arrow-size);\n\t\t}\n\t}\n\n\t/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling\n\tas a whole. The background of both buttons should stand out and there should be a visual\n\tseparation between both buttons. */\n\t&.ck-splitbutton_open,\n\t&:hover {\n\t\t/* When the split button hovered as a whole, not as individual buttons. */\n\t\t& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {\n\t\t\tbackground: var(--ck-color-split-button-hover-background);\n\t\t}\n\n\t\t/* Splitbutton separator needs to be set with the ::after pseudoselector\n\t\tto display properly the borders on focus */\n\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\tcontent: \'\';\n\t\t\tposition: absolute;\n\t\t\twidth: 1px;\n\t\t\theight: 100%;\n\t\t\tbackground-color: var(--ck-color-split-button-hover-border);\n\t\t}\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tleft: -1px;\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tright: -1px;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Don\'t round the bottom left and right corners of the buttons when "open"\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-splitbutton_open {\n\t\t@mixin ck-rounded-corners {\n\t\t\t& > .ck-splitbutton__action {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t}\n\n\t\t\t& > .ck-splitbutton__arrow {\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;z-index:var(--ck-z-modal);max-width:var(--ck-dropdown-max-width);position:absolute}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{top:100%;bottom:auto}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{width:7em;overflow:hidden;text-overflow:ellipsis}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{box-shadow:var(--ck-drop-shadow),0 0;background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
						],
						names: [],
						mappings:
							"AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CACb,yBAA0B,CAC1B,sCAAuC,CAEvC,iBAyDD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSASC,QAAS,CACT,WACD,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CACC,gCAAiC,CAGjC,sCACD,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEACC,SAAU,CACV,eAAgB,CAChB,sBACD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eH8GD,CA5BA,qFG9EE,qCH0GF,CA5BA,uBEpFC,oCAA8B,CFwF9B,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CAGT,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-dropdown-max-width: 75vw;\n}\n\n.ck.ck-dropdown {\n\tdisplay: inline-block;\n\tposition: relative;\n\n\t& .ck-dropdown__arrow {\n\t\tpointer-events: none;\n\t\tz-index: var(--ck-z-default);\n\t}\n\n\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n\t& .ck-button.ck-dropdown__button {\n\t\twidth: 100%;\n\t}\n\n\t& .ck-dropdown__panel {\n\t\tdisplay: none;\n\t\tz-index: var(--ck-z-modal);\n\t\tmax-width: var(--ck-dropdown-max-width);\n\n\t\tposition: absolute;\n\n\t\t&.ck-dropdown__panel-visible {\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_n,\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_nme {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-dropdown__panel_se,\n\t\t&.ck-dropdown__panel_sw,\n\t\t&.ck-dropdown__panel_smw,\n\t\t&.ck-dropdown__panel_sme,\n\t\t&.ck-dropdown__panel_s {\n\t\t\t/*\n\t\t\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n\t\t\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\n\t\t\t */\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_se {\n\t\t\tleft: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\tright: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_s,\n\t\t&.ck-dropdown__panel_n {\n\t\t\t/* Positioning panels relative to the center of the button */\n\t\t\tleft: 50%;\n\t\t\ttransform: translateX(-50%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_smw {\n\t\t\t/* Positioning panels relative to the middle-west of the button */\n\t\t\tleft: 75%;\n\t\t\ttransform: translateX(-75%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nme,\n\t\t&.ck-dropdown__panel_sme {\n\t\t\t/* Positioning panels relative to the middle-east of the button */\n\t\t\tleft: 25%;\n\t\t\ttransform: translateX(-25%);\n\t\t}\n\t}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n\tz-index: calc( var(--ck-z-modal) + 1 );\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-dropdown {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-dropdown__arrow {\n\t\twidth: var(--ck-dropdown-arrow-size);\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-dropdown__arrow {\n\t\t\tright: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-dropdown__arrow {\n\t\t\tleft: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-dropdown__arrow {\n\t\t@mixin ck-disabled;\n\t}\n\n\t& .ck-button.ck-dropdown__button {\n\t\t@mixin ck-dir ltr {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-right: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t/* #23 */\n\t\t& .ck-button__label {\n\t\t\twidth: 7em;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t\t&.ck-disabled .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\n\t\t&.ck-on {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t&.ck-dropdown__button_label-width_auto .ck-button__label {\n\t\t\twidth: auto;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/8699 */\n\t\t&.ck-off:active,\n\t\t&.ck-on:active {\n\t\t\tbox-shadow: none;\n\t\t\t\n\t\t\t&:focus {\n\t\t\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-dropdown__panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tbackground: var(--ck-color-dropdown-panel-background);\n\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\tbottom: 0;\n\n\t/* Make sure the panel is at least as wide as the drop-down\'s button. */\n\tmin-width: 100%;\n\n\t/* Disabled corner border radius to be consistent with the .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-dropdown__panel_se {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_sw {\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_ne {\n\t\tborder-bottom-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_nw {\n\t\tborder-bottom-right-radius: 0;\n\t}\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-toolbar{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-flow:row nowrap;align-items:center}.ck.ck-toolbar>.ck-toolbar__items{display:flex;flex-flow:row wrap;align-items:center;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);padding:0 var(--ck-spacing-small);border:1px solid var(--ck-color-toolbar-border)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;width:1px;min-width:1px;background:var(--ck-color-toolbar-border);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{width:100%;margin:0;border-radius:0}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-right:var(--ck-spacing-small)}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
						],
						names: [],
						mappings:
							"AAOA,eCEC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBAAgB,CDFhB,YAAa,CACb,oBAAqB,CACrB,kBA6CD,CA3CC,kCACC,YAAa,CACb,kBAAmB,CACnB,kBAAmB,CACnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDoGD,CAvGA,qECOE,qCDgGF,CAvGA,eAGC,6CAA8C,CAC9C,iCAAkC,CAClC,+CAkGD,CAhGC,yCACC,kBAAmB,CACnB,SAAU,CACV,aAAc,CACd,yCAA0C,CAM1C,kCAAmC,CACnC,qCACD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAGC,kCAAmC,CACnC,qCACD,CAEA,mCAEC,SAaD,CAVC,0DAEC,UAAW,CAGX,QAAS,CAGT,eACD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAjGF,qCAqGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JACC,wBAAyB,CACzB,2BACD,CAGA,2JACC,yBAA0B,CAC1B,4BACD,CAID,qGACC,mCACD,CAGA,yLACC,mCACD,CAWA,qHACC,cACD,CAIC,6JACC,yBAA0B,CAC1B,4BACD,CAGA,2JACC,wBAAyB,CACzB,2BACD,CAID,qGACC,oCACD,CAGA,yLACC,oCACD",
						sourcesContent: [
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-flow: row nowrap;\n\talign-items: center;\n\n\t& > .ck-toolbar__items {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\talign-items: center;\n\t\tflex-grow: 1;\n\n\t}\n\n\t& .ck.ck-toolbar__separator {\n\t\tdisplay: inline-block;\n\n\t\t/*\n\t\t * A leading or trailing separator makes no sense (separates from nothing on one side).\n\t\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n\t\t * moved to another toolbar in the dropdown.\n\t\t */\n\t\t&:first-child,\n\t\t&:last-child {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\tflex-basis: 100%;\n\t}\n\n\t&.ck-toolbar_grouping > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t&.ck-toolbar_vertical > .ck-toolbar__items {\n\t\tflex-direction: column;\n\t}\n\n\t&.ck-toolbar_floating > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t& > .ck-dropdown__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-toolbar-background);\n\tpadding: 0 var(--ck-spacing-small);\n\tborder: 1px solid var(--ck-color-toolbar-border);\n\n\t& .ck.ck-toolbar__separator {\n\t\talign-self: stretch;\n\t\twidth: 1px;\n\t\tmin-width: 1px;\n\t\tbackground: var(--ck-color-toolbar-border);\n\n\t\t/*\n\t\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\n\t\t */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\theight: 0;\n\t}\n\n\t& > .ck-toolbar__items {\n\t\t& > *:not(.ck-toolbar__line-break) {\n\t\t\t/* (#11) Separate toolbar items. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\n\t\t/* Don\'t display a separator after an empty items container, for instance,\n\t\twhen all items were grouped */\n\t\t&:empty + .ck.ck-toolbar__separator {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t&.ck-toolbar_vertical {\n\t\t/* Items in a vertical toolbar span the entire width. */\n\t\tpadding: 0;\n\n\t\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\n\t\t& > .ck-toolbar__items > .ck {\n\t\t\t/* Items in a vertical toolbar should span the horizontal space. */\n\t\t\twidth: 100%;\n\n\t\t\t/* Items in a vertical toolbar should have no margin. */\n\t\t\tmargin: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\n\t\t\tborder-radius: 0;\n\t\t}\n\t}\n\n\t&.ck-toolbar_compact {\n\t\t/* No spacing around items. */\n\t\tpadding: 0;\n\n\t\t& > .ck-toolbar__items > * {\n\t\t\t/* Compact toolbar items have no spacing between them. */\n\t\t\tmargin: 0;\n\n\t\t\t/* "Middle" children should have no rounded corners. */\n\t\t\t&:not(:first-child):not(:last-child) {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/*\n\t\t * Dropdown button has asymmetric padding to fit the arrow.\n\t\t * This button has no arrow so let\'s revert that padding back to normal.\n\t\t */\n\t\t& > .ck.ck-button.ck-dropdown__button {\n\t\t\tpadding-left: var(--ck-spacing-tiny);\n\t\t}\n\t}\n\n\t/* A drop-down containing the nested toolbar with configured items. */\n\t& .ck-toolbar__nested-toolbar-dropdown {\n\t\t/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */\n\t\t& > .ck-dropdown__panel {\n\t\t\tmin-width: auto;\n\t\t}\n\n\t\t& > .ck-button > .ck-button__label {\n\t\t\tmax-width: 7em;\n\t\t\twidth: auto;\n\t\t}\n\t}\n\n\t@nest .ck-toolbar-container & {\n\t\tborder: 0;\n\t}\n}\n\n/* stylelint-disable */\n\n/*\n * Styles for RTL toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="rtl"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="rtl"] {\n\t& > .ck-toolbar__items > .ck {\n\t\tmargin-right: 0;\n\t}\n\n\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\n\t\t/* (#11) Separate toolbar items. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-left: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n/*\n * Styles for LTR toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="ltr"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="ltr"] {\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-right: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n}\n\n/* stylelint-enable */\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-list{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-direction:column}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{list-style-type:none;background:var(--ck-color-list-background)}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{min-height:unset;width:100%;text-align:left;border-radius:0;padding:calc(var(--ck-line-height-base)*0.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*0.4*var(--ck-font-size-base))}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{height:1px;width:100%;background:var(--ck-color-base-border)}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
						],
						names: [],
						mappings:
							"AAOA,YCEC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBAAgB,CDFhB,YAAa,CACb,qBAcD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAGC,oBAAqB,CACrB,0CACD,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BACC,gBAAiB,CACjB,UAAW,CACX,eAAgB,CAChB,eAAgB,CAKhB,mIAiCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBACC,UAAW,CACX,UAAW,CACX,sCACD",
						sourcesContent: [
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-direction: column;\n\n\t& .ck-list__item,\n\t& .ck-list__separator {\n\t\tdisplay: block;\n\t}\n\n\t/* Make sure that whatever child of the list item gets focus, it remains on the\n\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n\tadjacent list items. */\n\t& .ck-list__item > *:focus {\n\t\tposition: relative;\n\t\tz-index: var(--ck-z-default);\n\t}\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-list {\n\t@mixin ck-rounded-corners;\n\n\tlist-style-type: none;\n\tbackground: var(--ck-color-list-background);\n}\n\n.ck.ck-list__item {\n\tcursor: default;\n\tmin-width: 12em;\n\n\t& .ck-button {\n\t\tmin-height: unset;\n\t\twidth: 100%;\n\t\ttext-align: left;\n\t\tborder-radius: 0;\n\n\t\t/* List items should have the same height. Use absolute units to make sure it is so\n\t\t   because e.g. different heading styles may have different height\n\t\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\tpadding:\n\t\t\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\n\t\t\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\n\t\t& .ck-button__label {\n\t\t\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\t\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-button-on-background);\n\t\t\tcolor: var(--ck-color-list-button-on-text);\n\n\t\t\t&:active {\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-on-background-focus);\n\t\t\t}\n\n\t\t\t&:focus:not(.ck-switchbutton):not(.ck-disabled) {\n\t\t\t\tborder-color: var(--ck-color-base-background);\n\t\t\t}\n\t\t}\n\n\t\t&:hover:not(.ck-disabled) {\n\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t}\n\t}\n\n\t/* It\'s unnecessary to change the background/text of a switch toggle; it has different ways\n\tof conveying its state (like the switcher) */\n\t& .ck-switchbutton {\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-background);\n\t\t\tcolor: inherit;\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t\t\tcolor: inherit;\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-list__separator {\n\theight: 1px;\n\twidth: 100%;\n\tbackground: var(--ck-color-base-border);\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{width:max-content;max-width:var(--ck-toolbar-dropdown-max-width)}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css",
						],
						names: [],
						mappings:
							"AAKA,MACC,oCACD,CAEA,4CAEC,iBAAkB,CAClB,8CAOD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\n\t/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n\twidth: max-content;\n\tmax-width: var(--ck-toolbar-dropdown-max-width);\n\n\t& .ck-button {\n\t\t&:focus {\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n\tborder: 0;\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
						],
						names: [],
						mappings:
							"AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDIpC,wBAAyB,CACzB,2BAA4B,CAC5B,4BAEF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF",
						sourcesContent: [
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n\t/* Disabled radius of top-left border to be consistent with .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t/* Make sure the button belonging to the first/last child of the list goes well with the\n\tborder radius of the entire panel. */\n\t& .ck-list__item {\n\t\t&:first-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\n\t\t&:last-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-focused{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0}.ck.ck-editor__editable_inline{overflow:auto;padding:0 var(--ck-spacing-standard);border:1px solid transparent}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
						],
						names: [],
						mappings:
							"AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEERA,YAAa,CACb,2BAA2B,CCF3B,qCHYA,CAGD,+BACC,aAAc,CACd,oCAAqC,CACrC,4BA4BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD",
						sourcesContent: [
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n\t@mixin ck-rounded-corners;\n\n\t&.ck-focused {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n\n.ck.ck-editor__editable_inline {\n\toverflow: auto;\n\tpadding: 0 var(--ck-spacing-standard);\n\tborder: 1px solid transparent;\n\n\t&[dir="ltr"] {\n\t\ttext-align: left;\n\t}\n\n\t&[dir="rtl"] {\n\t\ttext-align: right;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n\t& > *:first-child {\n\t\tmargin-top: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\n\t& > *:last-child {\n\t\t/*\n\t\t * This value should match with the default margins of the block elements (like .media or .image)\n\t\t * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).\n\t\t */\n\t\tmargin-bottom: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n\t&.ck-blurred ::selection {\n\t\tbackground: var(--ck-color-editable-blur-selection);\n\t}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n\t&::after {\n\t\tborder-bottom-color: var(--ck-color-base-foreground);\n\t}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n\t&::after {\n\t\tborder-top-color: var(--ck-color-base-foreground);\n\t}\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css",
						],
						names: [],
						mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tdisplay: block;\n}\n\n.ck.ck-voice-label {\n\tdisplay: none;\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tfont-weight: bold;\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-form__header{display:flex;flex-direction:row;flex-wrap:nowrap;align-items:center;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{padding:var(--ck-spacing-small) var(--ck-spacing-large);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);border-bottom:1px solid var(--ck-color-base-border)}.ck.ck-form__header .ck-form__header__label{font-weight:700}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/formheader/formheader.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css",
						],
						names: [],
						mappings:
							"AAKA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,kBAAmB,CACnB,6BACD,CCNA,MACC,4BACD,CAEA,oBACC,uDAAwD,CACxD,mCAAoC,CACpC,wCAAyC,CACzC,mDAKD,CAHC,4CACC,eACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\talign-items: center;\n\tjustify-content: space-between;\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\theight: var(--ck-form-header-height);\n\tline-height: var(--ck-form-header-height);\n\tborder-bottom: 1px solid var(--ck-color-base-border);\n\n\t& .ck-form__header__label {\n\t\tfont-weight: bold;\n\t}\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);min-width:var(--ck-input-width);min-height:var(--ck-ui-component-min-height);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-input[readonly]{border:1px solid var(--ck-color-input-disabled-border);background:var(--ck-color-input-disabled-background);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{border-color:var(--ck-color-input-error-border);animation:ck-input-shake .3s ease both}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
						],
						names: [],
						mappings:
							"AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAC9C,6DAA8D,CAC9D,+BAAgC,CAGhC,4CAA6C,CAG7C,4DA0BD,CAxBC,mBEpBA,YAAa,CACb,2BAA2B,CCF3B,2CHwBA,CAEA,uBACC,sDAAuD,CACvD,oDAAqD,CACrD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBACC,+CAAgD,CAChD,sCAKD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD",
						sourcesContent: [
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-input-width: 18em;\n\n\t/* Backward compatibility. */\n\t--ck-input-text-width: var(--ck-input-width);\n}\n\n.ck.ck-input {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-input-background);\n\tborder: 1px solid var(--ck-color-input-border);\n\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n\tmin-width: var(--ck-input-width);\n\n\t/* This is important to stay of the same height as surrounding buttons */\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t&[readonly] {\n\t\tborder: 1px solid var(--ck-color-input-disabled-border);\n\t\tbackground: var(--ck-color-input-disabled-background);\n\t\tcolor: var(--ck-color-input-disabled-text);\n\n\t\t&:focus {\n\t\t\t/* The read-only input should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\tborder-color: var(--ck-color-input-error-border);\n\t\tanimation: ck-input-shake .3s ease both;\n\n\t\t&:focus {\n\t\t\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n\t\t}\n\t}\n}\n\n@keyframes ck-input-shake {\n\t20% {\n\t\ttransform: translateX(-2px);\n\t}\n\n\t40% {\n\t\ttransform: translateX(2px);\n\t}\n\n\t60% {\n\t\ttransform: translateX(-1px);\n\t}\n\n\t80% {\n\t\ttransform: translateX(1px);\n\t}\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{pointer-events:none;transform-origin:0 0;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);background:var(--ck-color-labeled-field-label-background);padding:0 calc(var(--ck-font-size-tiny)*0.5);line-height:normal;font-weight:400;text-overflow:ellipsis;overflow:hidden;max-width:100%;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));background:transparent;padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
						],
						names: [],
						mappings:
							"AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD8GD,CAzGA,2FCDE,qCD0GF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAWC,mBAAoB,CACpB,oBAAqB,CAGrB,6DAA+D,CAE/D,yDAA0D,CAC1D,4CAA8C,CAC9C,kBAAoB,CACpB,eAAmB,CAGnB,sBAAuB,CACvB,eAAgB,CAEhB,cAAe,CAEf,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,+HAYF,CAfA,oUAOE,wIAQF,CAfA,gTAWC,iEAAkE,CAElE,sBAAuB,CACvB,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\tdisplay: flex;\n\t\tposition: relative;\n\t}\n\n\t& .ck.ck-label {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t}\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);\n\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));\n\t--ck-color-labeled-field-label-background: var(--ck-color-base-background);\n}\n\n.ck.ck-labeled-field-view {\n\t@mixin ck-rounded-corners;\n\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\twidth: 100%;\n\n\t\t& > .ck.ck-label {\n\t\t\ttop: 0px;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tleft: 0px;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tright: 0px;\n\t\t\t}\n\n\t\t\tpointer-events: none;\n\t\t\ttransform-origin: 0 0;\n\n\t\t\t/* By default, display the label scaled down above the field. */\n\t\t\ttransform: translate(var(--ck-spacing-medium), -6px) scale(.75);\n\n\t\t\tbackground: var(--ck-color-labeled-field-label-background);\n\t\t\tpadding: 0 calc(.5 * var(--ck-font-size-tiny));\n\t\t\tline-height: initial;\n\t\t\tfont-weight: normal;\n\n\t\t\t/* Prevent overflow when the label is longer than the input */\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\n\t\t\tmax-width: 100%;\n\n\t\t\ttransition:\n\t\t\t\ttransform var(--ck-labeled-field-view-transition),\n\t\t\t\tpadding var(--ck-labeled-field-view-transition),\n\t\t\t\tbackground var(--ck-labeled-field-view-transition);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\t& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\n\t\t& .ck-input:not([readonly]) + .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t& .ck-labeled-field-view__status {\n\t\tfont-size: var(--ck-font-size-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\n\t\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\n\t\tThe status could be very long. */\n\t\twhite-space: normal;\n\n\t\t&.ck-labeled-field-view__status_error {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t/* Disabled fields and fields that have no focus should fade out. */\n\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\tcolor: var(--ck-color-input-disabled-text);\n\t}\n\n\t/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t@mixin ck-dir ltr {\n\t\t\ttransform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttransform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t/* Compensate for the default translate position. */\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));\n\n\t\tbackground: transparent;\n\t\tpadding: 0;\n\t}\n\n\t/*------ DropdownView integration ----------------------------------------------------------------------------------- */\n\n\t/* Make sure dropdown\' background color in any of dropdown\'s state does not collide with labeled field. */\n\t& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {\n\t\tbackground: transparent;\n\t}\n\n\t/* When the dropdown is "empty", the labeled field label replaces its label. */\n\t&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {\n\t\topacity: 0;\n\t}\n\n\t/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));\n\t}\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck .ck-balloon-rotator__navigation{display:flex;align-items:center;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-small)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css",
						],
						names: [],
						mappings:
							"AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCACC,oCAAqC,CACrC,kCAAmC,CACnC,qCACD,CAGA,iEACC,uCAAwC,CAGxC,mCACD,CAMA,2DACC,eACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n\tjustify-content: center;\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tbackground: var(--ck-color-toolbar-background);\n\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\n\tpadding: 0 var(--ck-spacing-small);\n\n\t/* Let's keep similar appearance to `ck-toolbar`. */\n\t& > * {\n\t\tmargin-right: var(--ck-spacing-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t/* Gives counter more breath than buttons. */\n\t& .ck-balloon-rotator__counter {\n\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t/* We need to use smaller margin because of previous button's right margin. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n.ck .ck-balloon-rotator__content {\n\n\t/* Disable default annotation shadow inside rotator with fake panels. */\n\t& .ck.ck-annotation-wrapper {\n\t\tbox-shadow: none;\n\t}\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);width:100%;height:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
						],
						names: [],
						mappings:
							"AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBCJC,oCAA8B,CDO9B,eAAgB,CAEhB,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CAEtC,UAAW,CACX,WACD,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n\tposition: absolute;\n\n\t/* Fake panels should be placed under main balloon content. */\n\tz-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n\tposition: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tz-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tz-index: 1;\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-fake-panel-offset-horizontal: 6px;\n\t--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\tborder-radius: var(--ck-border-radius);\n\n\twidth: 100%;\n\theight: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n\t--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{z-index:var(--ck-z-modal);position:fixed;top:0}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{top:auto;position:absolute}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{box-shadow:var(--ck-drop-shadow),0 0;border-width:0 1px 1px;border-top-left-radius:0;border-top-right-radius:0}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
						],
						names: [],
						mappings:
							"AAMC,qDACC,yBAA0B,CAC1B,cAAe,CACf,KACD,CAEA,kEACC,QAAS,CACT,iBACD,CCPA,qDCCA,oCAA8B,CDE7B,sBAAuB,CACvB,wBAAyB,CACzB,yBACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\tz-index: var(--ck-z-modal); /* #315 */\n\t\tposition: fixed;\n\t\ttop: 0;\n\t}\n\n\t& .ck-sticky-panel__content_sticky_bottom-limit {\n\t\ttop: auto;\n\t\tposition: absolute;\n\t}\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\t@mixin ck-drop-shadow;\n\n\t\tborder-width: 0 1px 1px;\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/blocktoolbar.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css",
						],
						names: [],
						mappings:
							"AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-block-toolbar-button {\n\tposition: absolute;\n\tz-index: var(--ck-z-default);\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-block-toolbar-button: var(--ck-color-text);\n\t--ck-block-toolbar-button-size: var(--ck-font-size-normal);\n}\n\n.ck.ck-block-toolbar-button {\n\tcolor: var(--ck-color-block-toolbar-button);\n\tfont-size: var(--ck-block-toolbar-size);\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					'.ck .ck-widget .ck-widget__type-around__button{display:block;position:absolute;overflow:hidden;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{position:absolute;top:50%;left:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{top:calc(var(--ck-widget-outline-thickness)*-0.5);left:min(10%,30px);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-0.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;position:absolute;top:1px;left:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;position:absolute;left:0;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{top:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{width:var(--ck-widget-type-around-button-size);height:var(--ck-widget-type-around-button-size);background:var(--ck-color-widget-type-around-button);border-radius:100px;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);opacity:0;pointer-events:none}.ck .ck-widget .ck-widget__type-around__button svg{width:10px;height:8px;transform:translate(-50%,-50%);transition:transform .5s ease;margin-top:1px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{width:calc(var(--ck-widget-type-around-button-size) - 2px);height:calc(var(--ck-widget-type-around-button-size) - 2px);border-radius:100px;background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3))}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{pointer-events:none;height:1px;animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;outline:1px solid hsla(0,0%,100%,.5);background:var(--ck-color-base-text)}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}',
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css",
						],
						names: [],
						mappings:
							"AASC,+CACC,aAAc,CACd,iBAAkB,CAClB,eAAgB,CAChB,2BAwBD,CAtBC,mDACC,iBAAkB,CAClB,OAAQ,CACR,QAAS,CACT,qCACD,CAEA,qFAEC,iDAAoD,CACpD,kBAAoB,CAEpB,0BACD,CAEA,oFAEC,oDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CACd,iBAAkB,CAClB,OAAQ,CACR,QAAS,CACT,qCACD,CAMD,2EACC,YAAa,CACb,iBAAkB,CAClB,MAAO,CACP,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHACC,qDAA0D,CAC1D,aACD,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CACC,8CAA+C,CAC/C,+CAAgD,CAChD,oDAAqD,CACrD,mBAAoB,CACpB,uMAAyM,CAb1M,SAAU,CACV,mBA0DA,CA1CC,mDACC,UAAW,CACX,UAAW,CACX,8BAA+B,CAC/B,6BAA8B,CAC9B,cAgBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLACC,0DAA2D,CAC3D,2DAA4D,CAC5D,mBAAoB,CACpB,uEACD,CAOD,8GACC,gBACD,CAKA,mDACC,mBAAoB,CACpB,UAAW,CACX,mFAAoF,CAMpF,oCAAwC,CACxC,oCACD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CASE,0jBACC,SACD,CASF,mPACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD",
						sourcesContent: [
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\toverflow: hidden;\n\t\tz-index: var(--ck-z-default);\n\n\t\t& svg {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\tz-index: calc(var(--ck-z-default) + 2);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_before {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tleft: min(10%, 30px);\n\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_after {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tright: min(10%, 30px);\n\n\t\t\ttransform: translateY(50%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t\ttop: 1px;\n\t\t\tleft: 1px;\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tdisplay: none;\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\t/*\n\t * When the widget is hovered the "fake caret" would normally be narrower than the\n\t * extra outline displayed around the widget. Let\'s extend the "fake caret" to match\n\t * the full width of the widget.\n\t */\n\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\n\t\tright: calc( -1 * var(--ck-widget-outline-thickness) );\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n}\n\n/*\n * Integration with the read-only mode of the editor.\n */\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the restricted editing mode (feature) of the editor.\n */\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\n */\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\n\tdisplay: none;\n}\n',
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-widget-type-around-button-size: 20px;\n\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\n\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\n\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\n\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\n\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\n\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\n}\n\n@define-mixin ck-widget-type-around-button-visible {\n\topacity: 1;\n\tpointer-events: auto;\n}\n\n@define-mixin ck-widget-type-around-button-hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\twidth: var(--ck-widget-type-around-button-size);\n\t\theight: var(--ck-widget-type-around-button-size);\n\t\tbackground: var(--ck-color-widget-type-around-button);\n\t\tborder-radius: 100px;\n\t\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t@mixin ck-widget-type-around-button-hidden;\n\n\t\t& svg {\n\t\t\twidth: 10px;\n\t\t\theight: 8px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t\ttransition: transform .5s ease;\n\t\t\tmargin-top: 1px;\n\n\t\t\t& * {\n\t\t\t\tstroke-dasharray: 10;\n\t\t\t\tstroke-dashoffset: 0;\n\n\t\t\t\tfill: none;\n\t\t\t\tstroke: var(--ck-color-widget-type-around-button-icon);\n\t\t\t\tstroke-width: 1.5px;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t}\n\n\t\t\t& line {\n\t\t\t\tstroke-dasharray: 7;\n\t\t\t}\n\t\t}\n\n\t\t&:hover {\n\t\t\t/*\n\t\t\t * Display the "sonar" around the button when hovered.\n\t\t\t */\n\t\t\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\n\n\t\t\t/*\n\t\t\t * Animate active button\'s icon.\n\t\t\t */\n\t\t\t& svg {\n\t\t\t\t& polyline {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-dash 2s linear;\n\t\t\t\t}\n\n\t\t\t\t& line {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Show type around buttons when the widget gets selected or being hovered.\n\t */\n\t&.ck-widget_selected,\n\t&:hover {\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-visible;\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\n\t * and still can be hovered).\n\t */\n\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\tbackground: var(--ck-color-widget-type-around-button-hover);\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\tbackground: var(--ck-color-widget-type-around-button-active);\n\n\t\t&::after {\n\t\t\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\tborder-radius: 100px;\n\t\t\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the "before" button when the widget has a selection handle. Because some space\n\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\n\t */\n\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\n\t\tmargin-left: 20px;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& .ck-widget__type-around__fake-caret {\n\t\tpointer-events: none;\n\t\theight: 1px;\n\t\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\n\n\t\t/*\n\t\t * The semi-transparent-outline+background combo improves the contrast\n\t\t * when the background underneath the fake caret is dark.\n\t\t */\n\t\toutline: solid 1px hsla(0, 0%, 100%, .5);\n\t\tbackground: var(--ck-color-base-text);\n\t}\n\n\t/*\n\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t * Despite the widget being physically selected in the model, its outline should disappear.\n\t */\n\t&.ck-widget_selected {\n\t\t&.ck-widget_type-around_show-fake-caret_before,\n\t\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t\toutline-color: transparent;\n\t\t}\n\t}\n\n\t&.ck-widget_type-around_show-fake-caret_before,\n\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t/*\n\t\t * When the "fake caret" is visible we simulate that the widget is not selected\n\t\t * (despite being physically selected), so the outline color should be for the\n\t\t * unselected widget.\n\t\t */\n\t\t&.ck-widget_selected:hover {\n\t\t\toutline-color: var(--ck-color-widget-hover-border);\n\t\t}\n\n\t\t/*\n\t\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\n\t\t */\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\n\t\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\n\t\t */\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t&.ck-widget_selected,\n\t\t\t&.ck-widget_selected:hover {\n\t\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\t\topacity: 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\n\t\t * hide the resize UI because it creates too much noise. It can be visible when the user\n\t\t * hovers the widget, though.\n\t\t */\n\t\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\n\t\t\topacity: 0\n\t\t}\n\t}\n}\n\n/*\n * Styles for the "before" button when the widget has a selection handle in an RTL environment.\n * The selection handler is aligned to the right side of the widget so there is no need to create\n * additional space for it next to the "before" button.\n */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {\n\tmargin-left: 0;\n\tmargin-right: 20px;\n}\n\n/*\n * Hide type around buttons when the widget is selected as a child of a selected\n * nested editable (e.g. mulit-cell table selection).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\n */\n.ck-editor__nested-editable.ck-editor__editable_selected {\n\t& .ck-widget {\n\t\t&.ck-widget_selected,\n\t\t&:hover {\n\t\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\n */\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\n\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\n\n\t& svg * {\n\t\tstroke: hsl(0,0%,60%);\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-dash {\n\t0% {\n\t\tstroke-dashoffset: 10;\n\t}\n\t20%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-tip-dash {\n\t0%, 20% {\n\t\tstroke-dashoffset: 7;\n\t}\n\t40%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-button-sonar {\n\t0% {\n\t\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n\t50% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\n\t}\n\t100% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n}\n\n@keyframes ck-widget-type-around-fake-caret-pulse {\n\t0% {\n\t\topacity: 1;\n\t}\n\t49% {\n\t\topacity: 1;\n\t}\n\t50% {\n\t\topacity: 0;\n\t}\n\t99% {\n\t\topacity: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t}\n}\n',
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);color:var(--ck-color-resizer-tooltip-text);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);font-size:var(--ck-font-size-tiny);display:block;padding:0 var(--ck-spacing-small);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{top:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{top:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{top:calc(var(--ck-resizer-tooltip-height)*-1);left:50%;transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-width:var(--ck-widget-outline-thickness);outline-style:solid;outline-color:transparent;transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;background-color:var(--ck-color-widget-editable-focus-background)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{padding:4px;box-sizing:border-box;background-color:transparent;opacity:0;transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;transform:translateY(-100%);left:calc(0px - var(--ck-widget-outline-thickness));top:0}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{width:var(--ck-widget-handler-icon-size);height:var(--ck-widget-handler-icon-size);color:var(--ck-color-widget-drag-handler-icon-color)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-focus-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widget.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
						],
						names: [],
						mappings:
							"AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CACtD,0CAA2C,CAC3C,qDAAsD,CACtD,6CAA8C,CAC9C,kCAAmC,CACnC,aAAc,CACd,iCAAkC,CAClC,uCAAwC,CACxC,4CAoCD,CAlCC,8NAKC,iBACD,CAEA,0CACC,oCAAqC,CACrC,qCACD,CAEA,2CACC,oCAAqC,CACrC,sCACD,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CACC,6CAAgD,CAChD,QAAS,CACT,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eACC,gDAAiD,CACjD,mBAAoB,CACpB,yBAA0B,CAC1B,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGC/BA,YAAa,CACb,2BAA2B,CCF3B,qCAA8B,CFqC7B,iEACD,CAIA,4EACC,WAAY,CACZ,qBAAsB,CAGtB,4BAA6B,CAC7B,SAAU,CAMV,6SAG6F,CAG7F,iEAAkE,CAGlE,2BAA4B,CAC5B,mDAAoD,CACpD,KAqBD,CAnBC,qFAEC,wCAAyC,CACzC,yCAA0C,CAC1C,oDASD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFACC,SAAU,CACV,oDACD,CAKC,oMACC,SAAU,CACV,6CAMD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-resizer: var(--ck-color-focus-border);\n\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n\n\t--ck-resizer-border-radius: var(--ck-border-radius);\n\t--ck-resizer-tooltip-offset: 10px;\n\t--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);\n}\n\n.ck .ck-widget {\n\t/* This is neccessary for type around UI to be positioned properly. */\n\tposition: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n\n\t& .ck-widget__selection-handle {\n\t\tposition: absolute;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the icon in not a subject to font-size or line-height to avoid\n\t\t\tunnecessary spacing around it. */\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n\n\t/* Show the selection handle when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n}\n\n.ck .ck-size-view {\n\tbackground: var(--ck-color-resizer-tooltip-background);\n\tcolor: var(--ck-color-resizer-tooltip-text);\n\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\n\tborder-radius: var(--ck-resizer-border-radius);\n\tfont-size: var(--ck-font-size-tiny);\n\tdisplay: block;\n\tpadding: 0 var(--ck-spacing-small);\n\theight: var(--ck-resizer-tooltip-height);\n\tline-height: var(--ck-resizer-tooltip-height);\n\n\t&.ck-orientation-top-left,\n\t&.ck-orientation-top-right,\n\t&.ck-orientation-bottom-right,\n\t&.ck-orientation-bottom-left,\n\t&.ck-orientation-above-center {\n\t\tposition: absolute;\n\t}\n\n\t&.ck-orientation-top-left {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-top-right {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-right {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-left {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t/* Class applied if the widget is too small to contain the size label */\n\t&.ck-orientation-above-center {\n\t\ttop: calc(var(--ck-resizer-tooltip-height) * -1);\n\t\tleft: 50%;\n\t\ttransform: translate(-50%);\n\t}\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n\t--ck-widget-outline-thickness: 3px;\n\t--ck-widget-handler-icon-size: 16px;\n\t--ck-widget-handler-animation-duration: 200ms;\n\t--ck-widget-handler-animation-curve: ease;\n\n\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n\toutline-width: var(--ck-widget-outline-thickness);\n\toutline-style: solid;\n\toutline-color: transparent;\n\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n\t}\n\n\t&:hover {\n\t\toutline-color: var(--ck-color-widget-hover-border);\n\t}\n}\n\n.ck .ck-editor__nested-editable {\n\tborder: 1px solid transparent;\n\n\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n\tThese styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n\t&.ck-editor__nested-editable_focused,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\t\tbackground-color: var(--ck-color-widget-editable-focus-background);\n\t}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t& .ck-widget__selection-handle {\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\n\t\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n\t\tbackground-color: transparent;\n\t\topacity: 0;\n\n\t\t/* Transition:\n\t\t   * background-color for the .ck-widget_selected state change,\n\t\t   * visibility for hiding the handler,\n\t\t   * opacity for the proper look of the icon when the handler disappears. */\n\t\ttransition:\n\t\t\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t/* Make only top corners round. */\n\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n\t\t/* Place the drag handler outside the widget wrapper. */\n\t\ttransform: translateY(-100%);\n\t\tleft: calc(0px - var(--ck-widget-outline-thickness));\n\t\ttop: 0;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n\t\t\twidth: var(--ck-widget-handler-icon-size);\n\t\t\theight: var(--ck-widget-handler-icon-size);\n\t\t\tcolor: var(--ck-color-widget-drag-handler-icon-color);\n\n\t\t\t/* The "selected" part of the icon is invisible by default */\n\t\t\t& .ck-icon__selected-indicator {\n\t\t\t\topacity: 0;\n\n\t\t\t\t/* Note: The animation is longer on purpose. Simply feels better. */\n\t\t\t\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\n\t\t\t}\n\t\t}\n\n\t\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n\t\t&:hover .ck-icon .ck-icon__selected-indicator {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\topacity: 1;\n\t\tbackground-color: var(--ck-color-widget-hover-border);\n\t}\n\n\t/* Show the selection handler when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\t& > .ck-widget__selection-handle {\n\t\t\topacity: 1;\n\t\t\tbackground-color: var(--ck-color-focus-border);\n\n\t\t\t/* When the widget is selected, notify the user using the proper look of the icon. */\n\t\t\t& .ck-icon .ck-icon__selected-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n\tleft: auto;\n\tright: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n\ttransition: none;\n\n\t&:not(.ck-widget_selected) {\n\t\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\n\t\t *\n\t\t * Leave the unit because this custom property is used in calc() by other features.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\n\t\t */\n\t\t--ck-widget-outline-thickness: 0px;\n\t}\n\n\t&.ck-widget_with-selection-handle {\n\t\t& .ck-widget__selection-handle,\n\t\t& .ck-widget__selection-handle:hover {\n\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t}\n\t}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline-color: var(--ck-color-widget-blurred-border);\n\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t& > .ck-widget__selection-handle,\n\t\t\t& > .ck-widget__selection-handle:hover {\n\t\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n\tIn fact, anything with overflow: hidden.\n\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\n\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					'.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;position:relative;pointer-events:none}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-0.5);top:calc(var(--ck-clipboard-drop-target-dot-height)*-0.5);border:1px solid var(--ck-clipboard-drop-target-color);background:var(--ck-clipboard-drop-target-color);margin-left:-1px}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{content:"";width:0;height:0;display:block;position:absolute;left:50%;top:calc(var(--ck-clipboard-drop-target-dot-height)*-0.5);transform:translateX(-50%);border-left:calc(var(--ck-clipboard-drop-target-dot-width)*0.5) solid transparent;border-bottom:0 solid transparent;border-right:calc(var(--ck-clipboard-drop-target-dot-width)*0.5) solid transparent;border-top:calc(var(--ck-clipboard-drop-target-dot-height)) solid var(--ck-clipboard-drop-target-color)}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}',
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-clipboard/theme/clipboard.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css",
						],
						names: [],
						mappings:
							"AASC,8DACC,cAAe,CACf,iBAAkB,CAClB,mBAMD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CCzBF,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEACC,4DAA8D,CAC9D,yDAA2D,CAC3D,sDAAuD,CACvD,gDAAiD,CACjD,gBAkBD,CAfC,yEACC,UAAW,CACX,OAAQ,CACR,QAAS,CAET,aAAc,CACd,iBAAkB,CAClB,QAAS,CACT,yDAA2D,CAE3D,0BAA2B,CAG3B,iFAAmB,CAAnB,iCAAmB,CAAnB,kFAAmB,CAAnB,uGACD,CA2DF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: inline;\n\t\tposition: relative;\n\t\tpointer-events: none;\n\n\t\t& span {\n\t\t\tposition: absolute;\n\t\t\twidth: 0;\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\t& > .ck-widget__selection-handle {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t& > .ck-widget__type-around {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-clipboard-drop-target-dot-width: 12px;\n\t--ck-clipboard-drop-target-dot-height: 8px;\n\t--ck-clipboard-drop-target-color: var(--ck-color-focus-border)\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\t& span {\n\t\t\tbottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tbackground: var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-left: -1px;\n\n\t\t\t/* The triangle above the marker */\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: 50%;\n\t\t\t\ttop: calc(var(--ck-clipboard-drop-target-dot-height) * -.5);\n\n\t\t\t\ttransform: translateX(-50%);\n\t\t\t\tborder-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;\n\t\t\t\tborder-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t// Horizontal drop target (between blocks).\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: block;\n\t\tposition: relative;\n\t\twidth: 100%;\n\t\theight: 0;\n\t\tmargin: 0;\n\t\ttext-align: initial;\n\n\t\t& .ck-clipboard-drop-target__line {\n\t\t\tposition: absolute;\n\t\t\twidth: 100%;\n\t\t\theight: 0;\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-top: -1px;\n\n\t\t\t&::before {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent transparent transparent var(--ck-clipboard-drop-target-color);\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) 0 var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent var(--ck-clipboard-drop-target-color) transparent transparent;\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size)) var(--ck-clipboard-drop-target-dot-size) 0;\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\t/*\n\t * Styles of the widget that it a drop target.\n\t */\n\t& .ck-widget.ck-clipboard-drop-target-range {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\tzoom: 0.6;\n\t\toutline: none !important;\n\t}\n}\n',
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;position:absolute;pointer-events:none;left:0;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{position:absolute;pointer-events:all}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{width:var(--ck-resizer-size);height:var(--ck-resizer-size);background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{top:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{top:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgetresize.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css",
						],
						names: [],
						mappings:
							"AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CACb,iBAAkB,CAGlB,mBAAoB,CAEpB,MAAO,CACP,KACD,CAGC,2EACC,aACD,CAGD,gCACC,iBAAkB,CAGlB,kBAWD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCACC,4BAA6B,CAC7B,6BAA8B,CAC9B,uCAAwC,CACxC,gDAA6D,CAC7D,6CAqBD,CAnBC,oEACC,4BAA6B,CAC7B,6BACD,CAEA,qEACC,4BAA6B,CAC7B,8BACD,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n}\n\n.ck .ck-widget__resizer {\n\tdisplay: none;\n\tposition: absolute;\n\n\t/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n\tpointer-events: none;\n\n\tleft: 0;\n\ttop: 0;\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n\t& > .ck-widget__resizer {\n\t\tdisplay: block;\n\t}\n}\n\n.ck .ck-widget__resizer__handle {\n\tposition: absolute;\n\n\t/* Resizers are the only UI elements that should interfere with a pointer device. */\n\tpointer-events: all;\n\n\t&.ck-widget__resizer__handle-top-left,\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tcursor: nwse-resize;\n\t}\n\n\t&.ck-widget__resizer__handle-top-right,\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tcursor: nesw-resize;\n\t}\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-resizer-size: 10px;\n\n\t/* Set the resizer with a 50% offset. */\n\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n\t--ck-resizer-border-width: 1px;\n}\n\n.ck .ck-widget__resizer {\n\toutline: 1px solid var(--ck-color-resizer);\n}\n\n.ck .ck-widget__resizer__handle {\n\twidth: var(--ck-resizer-size);\n\theight: var(--ck-resizer-size);\n\tbackground: var(--ck-color-focus-border);\n\tborder: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n\tborder-radius: var(--ck-resizer-border-radius);\n\n\t&.ck-widget__resizer__handle-top-left {\n\t\ttop: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-top-right {\n\t\ttop: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck-content blockquote{overflow:hidden;padding-right:1.5em;padding-left:1.5em;margin-left:0;margin-right:0;font-style:italic;border-left:5px solid #ccc}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-block-quote/theme/blockquote.css",
						],
						names: [],
						mappings:
							"AAKA,uBAEC,eAAgB,CAGhB,mBAAoB,CACpB,kBAAmB,CAEnB,aAAc,CACd,cAAe,CACf,iBAAkB,CAClB,0BACD,CAEA,gCACC,aAAc,CACd,2BACD",
						sourcesContent: [
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content blockquote {\n\t/* See #12 */\n\toverflow: hidden;\n\n\t/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */\n\tpadding-right: 1.5em;\n\tpadding-left: 1.5em;\n\n\tmargin-left: 0;\n\tmargin-right: 0;\n\tfont-style: italic;\n\tborder-left: solid 5px hsl(0, 0%, 80%);\n}\n\n.ck-content[dir="rtl"] blockquote {\n\tborder-left: 0;\n\tborder-right: solid 5px hsl(0, 0%, 80%);\n}\n',
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck-content code{background-color:hsla(0,0%,78%,.3);padding:.15em;border-radius:2px}.ck.ck-editor__editable .ck-code_selected{background-color:hsla(0,0%,78%,.5)}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-basic-styles/theme/code.css",
						],
						names: [],
						mappings:
							"AAKA,iBACC,kCAAuC,CACvC,aAAc,CACd,iBACD,CAEA,0CACC,kCACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content code {\n\tbackground-color: hsla(0, 0%, 78%, 0.3);\n\tpadding: .15em;\n\tborder-radius: 2px;\n}\n\n.ck.ck-editor__editable .ck-code_selected  {\n\tbackground-color: hsla(0, 0%, 78%, 0.5);\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck-content pre{padding:1em;color:#353535;background:hsla(0,0%,78%,.3);border:1px solid #c4c4c4;border-radius:2px;text-align:left;direction:ltr;tab-size:4;white-space:pre-wrap;font-style:normal;min-width:200px}.ck-content pre code{background:unset;padding:0;border-radius:0}.ck.ck-editor__editable pre{position:relative}.ck.ck-editor__editable pre[data-language]:after{content:attr(data-language);position:absolute}:root{--ck-color-code-block-label-background:#757575}.ck.ck-editor__editable pre[data-language]:after{top:-1px;right:10px;background:var(--ck-color-code-block-label-background);font-size:10px;font-family:var(--ck-font-face);line-height:16px;padding:var(--ck-spacing-tiny) var(--ck-spacing-medium);color:#fff;white-space:nowrap}.ck.ck-code-block-dropdown .ck-dropdown__panel{max-height:250px;overflow-y:auto;overflow-x:hidden}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-code-block/theme/codeblock.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-code-block/codeblock.css",
						],
						names: [],
						mappings:
							"AAKA,gBACC,WAAY,CACZ,aAAwB,CACxB,4BAAiC,CACjC,wBAAiC,CACjC,iBAAkB,CAGlB,eAAgB,CAChB,aAAc,CAEd,UAAW,CACX,oBAAqB,CAGrB,iBAAkB,CAGlB,eAOD,CALC,qBACC,gBAAiB,CACjB,SAAU,CACV,eACD,CAGD,4BACC,iBAMD,CAJC,iDACC,2BAA4B,CAC5B,iBACD,CCjCD,MACC,8CACD,CAEA,iDACC,QAAS,CACT,UAAW,CACX,sDAAuD,CAEvD,cAAe,CACf,+BAAgC,CAChC,gBAAiB,CACjB,uDAAwD,CACxD,UAAuB,CACvB,kBACD,CAEA,+CAEC,gBAAiB,CACjB,eAAgB,CAChB,iBACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content pre {\n\tpadding: 1em;\n\tcolor: hsl(0, 0%, 20.8%);\n\tbackground: hsla(0, 0%, 78%, 0.3);\n\tborder: 1px solid hsl(0, 0%, 77%);\n\tborder-radius: 2px;\n\n\t/* Code block are language direction–agnostic. */\n\ttext-align: left;\n\tdirection: ltr;\n\n\ttab-size: 4;\n\twhite-space: pre-wrap;\n\n\t/* Don't inherit the style, e.g. when in a block quote. */\n\tfont-style: normal;\n\n\t/* Don't let the code be squashed e.g. when in a table cell. */\n\tmin-width: 200px;\n\n\t& code {\n\t\tbackground: unset;\n\t\tpadding: 0;\n\t\tborder-radius: 0;\n\t}\n}\n\n.ck.ck-editor__editable pre {\n\tposition: relative;\n\n\t&[data-language]::after {\n\t\tcontent: attr(data-language);\n\t\tposition: absolute;\n\t}\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-code-block-label-background: hsl(0, 0%, 46%);\n}\n\n.ck.ck-editor__editable pre[data-language]::after {\n\ttop: -1px;\n\tright: 10px;\n\tbackground: var(--ck-color-code-block-label-background);\n\n\tfont-size: 10px;\n\tfont-family: var(--ck-font-face);\n\tline-height: 16px;\n\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-medium);\n\tcolor: hsl(0, 0%, 100%);\n\twhite-space: nowrap;\n}\n\n.ck.ck-code-block-dropdown .ck-dropdown__panel {\n\t/* There could be dozens of languages available. Use scroll to prevent a 10e6px dropdown. */\n\tmax-height: 250px;\n\toverflow-y: auto;\n\toverflow-x: hidden;\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-heading/theme/heading.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css",
						],
						names: [],
						mappings:
							"AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD",
						sourcesContent: [
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-heading_heading1 {\n\tfont-size: 20px;\n}\n\n.ck.ck-heading_heading2 {\n\tfont-size: 17px;\n}\n\n.ck.ck-heading_heading3 {\n\tfont-size: 14px;\n}\n\n.ck[class*="ck-heading_heading"] {\n\tfont-weight: bold;\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Resize dropdown's button label. */\n.ck.ck-dropdown.ck-heading-dropdown {\n\t& .ck-dropdown__button .ck-button__label {\n\t\twidth: 8em;\n\t}\n\n\t& .ck-dropdown__panel .ck-list__item {\n\t\tmin-width: 18em;\n\t}\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck-editor__editable .ck-horizontal-line{display:flow-root}.ck-content hr{margin:15px 0;height:4px;background:#dedede;border:0}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-horizontal-line/theme/horizontalline.css",
						],
						names: [],
						mappings:
							"AAMA,yCAEC,iBACD,CAEA,eACC,aAAc,CACd,UAAW,CACX,kBAA2B,CAC3B,QACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n\n.ck-editor__editable .ck-horizontal-line {\n\t/* Necessary to render properly next to floated objects, e.g. side image case. */\n\tdisplay: flow-root;\n}\n\n.ck-content hr {\n\tmargin: 15px 0;\n\theight: 4px;\n\tbackground: hsl(0, 0%, 87%);\n\tborder: 0;\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-image/theme/textalternativeform.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
						],
						names: [],
						mappings:
							"AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD",
						sourcesContent: [
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-text-alternative-form {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					'.ck-vertical-form .ck-button:after{content:"";width:0;position:absolute;right:-1px;top:-1px;bottom:-1px;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{content:"";width:0;position:absolute;right:-1px;top:-1px;bottom:-1px;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*0.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-large);border-radius:0}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}',
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/responsive-form/responsiveform.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css",
						],
						names: [],
						mappings:
							"AAQC,mCACC,UAAW,CACX,OAAQ,CACR,iBAAkB,CAClB,UAAW,CACX,QAAS,CACT,WAAY,CACZ,SACD,CAEA,yCACC,YACD,CCdA,oCDoBE,wCACC,UAAW,CACX,OAAQ,CACR,iBAAkB,CAClB,UAAW,CACX,QAAS,CACT,WAAY,CACZ,SACD,CAEA,8CACC,YACD,CC9BF,CCAD,qDACC,kDACD,CAEA,uBACC,+BAmED,CAjEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,qCA8CF,CA5CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAKA,0DACC,kDACD,CAGD,iGAEC,kCAAmC,CACnC,kCAAmC,CACnC,eAiBD,CAfC,yHACC,gDACD,CARD,0OAeE,aAMF,CAJE,+IACC,kDACD,CDpEH",
						sourcesContent: [
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck-vertical-form .ck-button {\n\t&::after {\n\t\tcontent: "";\n\t\twidth: 0;\n\t\tposition: absolute;\n\t\tright: -1px;\n\t\ttop: -1px;\n\t\tbottom: -1px;\n\t\tz-index: 1;\n\t}\n\n\t&:focus::after {\n\t\tdisplay: none;\n\t}\n}\n\n.ck.ck-responsive-form {\n\t@mixin ck-media-phone {\n\t\t& .ck-button {\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: -1px;\n\t\t\t\ttop: -1px;\n\t\t\t\tbottom: -1px;\n\t\t\t\tz-index: 1;\n\t\t\t}\n\n\t\t\t&:focus::after {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\n\tborder-right: 1px solid var(--ck-color-base-border);\n}\n\n.ck.ck-responsive-form {\n\tpadding: var(--ck-spacing-large);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& > :not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& > :not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tpadding: 0;\n\t\twidth: calc(.8 * var(--ck-input-width));\n\n\t\t& .ck-labeled-field-view {\n\t\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) 0;\n\n\t\t\t& .ck-input-text {\n\t\t\t\tmin-width: 0;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\n\t\t\t/* Let the long error messages wrap in the narrow form. */\n\t\t\t& .ck-labeled-field-view__error {\n\t\t\t\twhite-space: normal;\n\t\t\t}\n\t\t}\n\n\t\t/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\t&::after {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\n\t\t& > .ck-button:nth-last-child(1),\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\tpadding: var(--ck-spacing-standard);\n\t\t\tmargin-top: var(--ck-spacing-large);\n\t\t\tborder-radius: 0;\n\n\t\t\t&:not(:focus) {\n\t\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n',
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck-content .image{display:table;clear:both;text-align:center;margin:.9em auto;min-width:50px}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{display:inline-flex;max-width:100%;align-items:flex-start}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{padding-left:inherit;padding-right:inherit;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ck.ck-editor__editable .image-inline.ck-widget_selected,.ck.ck-editor__editable .image.ck-widget_selected{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-image/theme/image.css",
						],
						names: [],
						mappings:
							"AAMC,mBACC,aAAc,CACd,UAAW,CACX,iBAAkB,CAKlB,gBAAkB,CAGlB,cAeD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD,CAGD,0BAMC,mBAAoB,CAGpB,cAAe,CAGf,sBAiBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEACC,oBAAqB,CACrB,qBAAsB,CAMtB,kBAAmB,CACnB,eAAgB,CAChB,sBACD,CAWA,2GACC,SAUD,CAHC,qEACC,YACD,CAOA,0FACC,cACD",
						sourcesContent: [
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content {\n\t& .image {\n\t\tdisplay: table;\n\t\tclear: both;\n\t\ttext-align: center;\n\n\t\t/* Make sure there is some space between the content and the image. Center image by default. */\n\t\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\t \tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\t\tmargin: 0.9em auto;\n\n\t\t/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\n\t\tmin-width: 50px;\n\n\t\t& img {\n\t\t\t/* Prevent unnecessary margins caused by line-height (see #44). */\n\t\t\tdisplay: block;\n\n\t\t\t/* Center the image if its width is smaller than the content\'s width. */\n\t\t\tmargin: 0 auto;\n\n\t\t\t/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\n\t\t\tmax-width: 100%;\n\n\t\t\t/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */\n\t\t\tmin-width: 100%\n\t\t}\n\t}\n\n\t& .image-inline {\n\t\t/*\n\t\t * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).\n\t\t * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.\n\t\t * This strange behavior does not happen with inline-flex.\n\t\t */\n\t\tdisplay: inline-flex;\n\n\t\t/* While being resized, don\'t allow the image to exceed the width of the editing root. */\n\t\tmax-width: 100%;\n\n\t\t/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */\n\t\talign-items: flex-start;\n\n\t\t/* When the picture is present it must act as a flex container to let the img resize properly */\n\t\t& picture {\n\t\t\tdisplay: flex;\n\t\t}\n\n\t\t/* When the picture is present, it must act like a resizable img. */\n\t\t& picture,\n\t\t& img {\n\t\t\t/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */\n\t\t\tflex-grow: 1;\n\t\t\tflex-shrink: 1;\n\n\t\t\t/* Prevents overflowing the editing root boundaries when an inline image is very wide. */\n\t\t\tmax-width: 100%;\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Inhertit the content styles padding of the <figcaption> in case the integration overrides `text-align: center`\n\t * of `.image` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native\n\t * caret does, and not at the edge of <figcaption>.\n\t */\n\t& .image > figcaption.ck-placeholder::before {\n\t\tpadding-left: inherit;\n\t\tpadding-right: inherit;\n\n\t\t/*\n\t\t * Make sure the image caption placeholder doesn\'t overflow the placeholder area.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9162.\n\t\t */\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t}\n\n\n\t/*\n\t * Make sure the selected inline image always stays on top of its siblings.\n\t * See https://github.com/ckeditor/ckeditor5/issues/9108.\n\t */\n\t& .image.ck-widget_selected {\n\t\tz-index: 1;\n\t}\n\n\t& .image-inline.ck-widget_selected {\n\t\tz-index: 1;\n\n\t\t/*\n\t\t * Make sure the native browser selection style is not displayed.\n\t\t * Inline image widgets have their own styles for the selected state and\n\t\t * leaving this up to the browser is asking for a visual collision.\n\t\t */\n\t\t& ::selection {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t/* The inline image nested in the table should have its original size if not resized.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\n\t& td,\n\t& th {\n\t\t& .image-inline img {\n\t\t\tmax-width: none;\n\t\t}\n\t}\n}\n',
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					":root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highligted-background:#fd0}.ck-content .image>figcaption{display:table-caption;caption-side:bottom;word-break:break-word;color:var(--ck-color-image-caption-text);background-color:var(--ck-color-image-caption-background);padding:.6em;font-size:.75em;outline-offset:-1px}.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highligted-background)}to{background-color:var(--ck-color-image-caption-background)}}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imagecaption.css",
						],
						names: [],
						mappings:
							"AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,mDACD,CAGA,8BACC,qBAAsB,CACtB,mBAAoB,CACpB,qBAAsB,CACtB,wCAAyC,CACzC,yDAA0D,CAC1D,YAAa,CACb,eAAgB,CAChB,mBACD,CAGA,qEACC,iDACD,CAEA,sCACC,GACC,oEACD,CAEA,GACC,yDACD,CACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-caption-background: hsl(0, 0%, 97%);\n\t--ck-color-image-caption-text: hsl(0, 0%, 20%);\n\t--ck-color-image-caption-highligted-background: hsl(52deg 100% 50%);\n}\n\n/* Content styles */\n.ck-content .image > figcaption {\n\tdisplay: table-caption;\n\tcaption-side: bottom;\n\tword-break: break-word;\n\tcolor: var(--ck-color-image-caption-text);\n\tbackground-color: var(--ck-color-image-caption-background);\n\tpadding: .6em;\n\tfont-size: .75em;\n\toutline-offset: -1px;\n}\n\n/* Editing styles */\n.ck.ck-editor__editable .image > figcaption.image__caption_highlighted {\n\tanimation: ck-image-caption-highlight .6s ease-out;\n}\n\n@keyframes ck-image-caption-highlight {\n\t0% {\n\t\tbackground-color: var(--ck-color-image-caption-highligted-background);\n\t}\n\n\t100% {\n\t\tbackground-color: var(--ck-color-image-caption-background);\n\t}\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{height:100%;border-right:1px solid var(--ck-color-base-text);margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/link.css",
						],
						names: [],
						mappings:
							"AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCACC,WAAY,CACZ,gDAAiD,CACjD,iBAAkB,CAClB,oCACD",
						sourcesContent: [
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Class added to span element surrounding currently selected link. */\n.ck .ck-link_selected {\n\tbackground: var(--ck-color-link-selected-background);\n\n\t/* Give linked inline images some outline to let the user know they are also part of the link. */\n\t& span.image-inline {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);\n\t}\n}\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when an input\n * in the link UI has focus (the browser does not render the native selection in this state).\n */\n.ck .ck-fake-link-selection {\n\tbackground: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-link-selection_collapsed {\n\theight: 100%;\n\tborder-right: 1px solid var(--ck-color-base-text);\n\tmargin-right: -1px;\n\toutline: solid 1px hsla(0, 0%, 100%, .5);\n}\n',
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{padding:0;min-width:var(--ck-input-width)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical>.ck-button{padding:var(--ck-spacing-standard);margin:0;width:50%;border-radius:0}.ck.ck-link-form_layout-vertical>.ck-button:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form_layout-vertical>.ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkform.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css",
						],
						names: [],
						mappings:
							"AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCACC,SAAU,CACV,+BA+CD,CA7CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CACC,kCAAmC,CACnC,QAAS,CACT,SAAU,CACV,eAiBD,CAfC,wDACC,gDACD,CARD,4GAeE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAUD,CARC,wEACC,SAAU,CACV,UAKD,CAHC,8EACC,eACD",
						sourcesContent: [
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-form {\n\tdisplay: flex;\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tdisplay: block;\n\n\t/*\n\t * Whether the form is in the responsive mode or not, if there are decorator buttons\n\t * keep the top margin of action buttons medium.\n\t */\n\t& .ck-button {\n\t\t&.ck-button-save,\n\t\t&.ck-button-cancel {\n\t\t\tmargin-top: var(--ck-spacing-medium);\n\t\t}\n\t}\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tpadding: 0;\n\tmin-width: var(--ck-input-width);\n\n\t& .ck-labeled-field-view {\n\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);\n\n\t\t& .ck-input-text {\n\t\t\tmin-width: 0;\n\t\t\twidth: 100%;\n\t\t}\n\t}\n\n\t& > .ck-button {\n\t\tpadding: var(--ck-spacing-standard);\n\t\tmargin: 0;\n\t\twidth: 50%;\n\t\tborder-radius: 0;\n\n\t\t&:not(:focus) {\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t}\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: 0;\n\n\t\t\t&:last-of-type {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Using additional `.ck` class for stronger CSS specificity than `.ck.ck-link-form > :not(:first-child)`. */\n\t& .ck.ck-list {\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\n\t\t& .ck-button.ck-switchbutton {\n\t\t\tpadding: 0;\n\t\t\twidth: 100%;\n\n\t\t\t&:hover {\n\t\t\t\tbackground: none;\n\t\t\t}\n\t\t}\n\t}\n}\n',
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{padding:0 var(--ck-spacing-medium);color:var(--ck-color-link-default);text-overflow:ellipsis;cursor:pointer;max-width:var(--ck-input-width);min-width:3em;text-align:center}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{min-width:0;max-width:100%}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkactions.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css",
						],
						names: [],
						mappings:
							"AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCIA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EACC,kCAAmC,CACnC,kCAAmC,CACnC,sBAAuB,CACvB,cAAe,CAIf,+BAAgC,CAChC,aAAc,CACd,iBAKD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDtDD,oCC0DC,wDACC,8DAMD,CAJC,0EACC,WAAY,CACZ,cACD,CAGD,gJAME,aAEF,CDzED",
						sourcesContent: [
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-link-actions__preview {\n\t\tdisplay: inline-block;\n\n\t\t& .ck-button__label {\n\t\t\toverflow: hidden;\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-link-actions__preview {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\t& .ck-button.ck-link-actions__preview {\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\n\t\t& .ck-button__label {\n\t\t\tpadding: 0 var(--ck-spacing-medium);\n\t\t\tcolor: var(--ck-color-link-default);\n\t\t\ttext-overflow: ellipsis;\n\t\t\tcursor: pointer;\n\n\t\t\t/* Match the box model of the link editor form\'s input so the balloon\n\t\t\tdoes not change width when moving between actions and the form. */\n\t\t\tmax-width: var(--ck-input-width);\n\t\t\tmin-width: 3em;\n\t\t\ttext-align: center;\n\n\t\t\t&:hover {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\n\t\t&,\n\t\t&:hover,\n\t\t&:focus,\n\t\t&:active {\n\t\t\tbackground: none;\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&:focus {\n\t\t\t& .ck-button__label {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-button:not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-button:not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\t& .ck-button.ck-link-actions__preview {\n\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\n\t\t\t& .ck-button__label {\n\t\t\t\tmin-width: 0;\n\t\t\t\tmax-width: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-collapsible.ck-collapsible_collapsed>.ck-collapsible__children{display:none}:root{--ck-collapsible-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-collapsible>.ck.ck-button{width:100%;font-weight:700;padding:var(--ck-spacing-medium) var(--ck-spacing-large);border-radius:0;color:inherit}.ck.ck-collapsible>.ck.ck-button:focus{background:transparent}.ck.ck-collapsible>.ck.ck-button:active,.ck.ck-collapsible>.ck.ck-button:hover:not(:focus),.ck.ck-collapsible>.ck.ck-button:not(:focus){background:transparent;border-color:transparent;box-shadow:none}.ck.ck-collapsible>.ck.ck-button>.ck-icon{margin-right:var(--ck-spacing-medium);width:var(--ck-collapsible-arrow-size)}.ck.ck-collapsible>.ck-collapsible__children{padding:0 var(--ck-spacing-large) var(--ck-spacing-large)}.ck.ck-collapsible.ck-collapsible_collapsed>.ck.ck-button .ck-icon{transform:rotate(-90deg)}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-list/theme/collapsible.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/collapsible.css",
						],
						names: [],
						mappings:
							"AAMC,sEACC,YACD,CCHD,MACC,yDACD,CAGC,iCACC,UAAW,CACX,eAAiB,CACjB,wDAAyD,CACzD,eAAgB,CAChB,aAgBD,CAdC,uCACC,sBACD,CAEA,wIACC,sBAAuB,CACvB,wBAAyB,CACzB,eACD,CAEA,0CACC,qCAAsC,CACtC,sCACD,CAGD,6CACC,yDACD,CAGC,mEACC,wBACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-collapsible.ck-collapsible_collapsed {\n\t& > .ck-collapsible__children {\n\t\tdisplay: none;\n\t}\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-collapsible-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-collapsible {\n\t& > .ck.ck-button {\n\t\twidth: 100%;\n\t\tfont-weight: bold;\n\t\tpadding: var(--ck-spacing-medium) var(--ck-spacing-large);\n\t\tborder-radius: 0;\n\t\tcolor: inherit;\n\n\t\t&:focus {\n\t\t\tbackground: transparent;\n\t\t}\n\n\t\t&:active, &:not(:focus), &:hover:not(:focus) {\n\t\t\tbackground: transparent;\n\t\t\tborder-color: transparent;\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t& > .ck-icon {\n\t\t\tmargin-right: var(--ck-spacing-medium);\n\t\t\twidth: var(--ck-collapsible-arrow-size);\n\t\t}\n\t}\n\n\t& > .ck-collapsible__children {\n\t\tpadding: 0 var(--ck-spacing-large) var(--ck-spacing-large);\n\t}\n\n\t&.ck-collapsible_collapsed {\n\t\t& > .ck.ck-button .ck-icon {\n\t\t\ttransform: rotate(-90deg);\n\t\t}\n\t}\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-list-properties.ck-list-properties_without-styles{padding:var(--ck-spacing-large)}.ck.ck-list-properties.ck-list-properties_without-styles>*{min-width:14em}.ck.ck-list-properties.ck-list-properties_without-styles>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-list-styles-list{grid-template-columns:repeat(4,auto)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible{border-top:1px solid var(--ck-color-base-border)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*{width:100%}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties .ck.ck-numbered-list-properties__start-index .ck-input{min-width:auto;width:100%}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order{background:transparent;padding-left:0;padding-right:0;margin-bottom:calc(var(--ck-spacing-tiny)*-1)}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:active,.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:hover{box-shadow:none;border-color:transparent;background:none}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/listproperties.css",
						],
						names: [],
						mappings:
							"AAOC,yDACC,+BASD,CAPC,2DACC,cAKD,CAHC,6DACC,qCACD,CASD,wFACC,oCACD,CAGA,mFACC,gDAWD,CARE,+GACC,UAKD,CAHC,iHACC,qCACD,CAMJ,8EACC,cAAe,CACf,UACD,CAEA,uEACC,sBAAuB,CACvB,cAAe,CACf,eAAgB,CAChB,6CAOD,CALC,2JACC,eAAgB,CAChB,wBAAyB,CACzB,eACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-properties {\n\t/* When there are no list styles and there is no collapsible. */\n\t&.ck-list-properties_without-styles {\n\t\tpadding: var(--ck-spacing-large);\n\n\t\t& > * {\n\t\t\tmin-width: 14em;\n\n\t\t\t& + * {\n\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * When the numbered list property fields (start at, reversed) should be displayed,\n\t * more horizontal space is needed. Reconfigure the style grid to create that space.\n\t */\n\t&.ck-list-properties_with-numbered-properties {\n\t\t& > .ck-list-styles-list {\n\t\t\tgrid-template-columns: repeat( 4, auto );\n\t\t}\n\n\t\t/* When list styles are rendered and property fields are in a collapsible. */\n\t\t& > .ck-collapsible {\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\n\t\t\t& > .ck-collapsible__children {\n\t\t\t\t& > * {\n\t\t\t\t\twidth: 100%;\n\n\t\t\t\t\t& + * {\n\t\t\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-numbered-list-properties__start-index .ck-input {\n\t\tmin-width: auto;\n\t\twidth: 100%;\n\t}\n\n\t& .ck.ck-numbered-list-properties__reversed-order {\n\t\tbackground: transparent;\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\t\tmargin-bottom: calc(-1 * var(--ck-spacing-tiny));\n\n\t\t&:active, &:hover {\n\t\t\tbox-shadow: none;\n\t\t\tborder-color: transparent;\n\t\t\tbackground: none;\n\t\t}\n\t}\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					".ck.ck-list-styles-list{display:grid}.ck-content ol{list-style-type:decimal}.ck-content ol ol{list-style-type:lower-latin}.ck-content ol ol ol{list-style-type:lower-roman}.ck-content ol ol ol ol{list-style-type:upper-latin}.ck-content ol ol ol ol ol{list-style-type:upper-roman}.ck-content ul{list-style-type:circle}.ck-content ul ul{list-style-type:disc}.ck-content ul ul ul,.ck-content ul ul ul ul{list-style-type:square}:root{--ck-list-style-button-size:44px}.ck.ck-list-styles-list{grid-template-columns:repeat(3,auto);row-gap:var(--ck-spacing-medium);column-gap:var(--ck-spacing-medium);padding:var(--ck-spacing-large)}.ck.ck-list-styles-list .ck-button{padding:0;margin:0;box-sizing:content-box}.ck.ck-list-styles-list .ck-button,.ck.ck-list-styles-list .ck-button .ck-icon{width:var(--ck-list-style-button-size);height:var(--ck-list-style-button-size)}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-list/theme/liststyles.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/liststyles.css",
						],
						names: [],
						mappings:
							"AAKA,wBACC,YACD,CAEA,eACC,uBAiBD,CAfC,kBACC,2BAaD,CAXC,qBACC,2BASD,CAPC,wBACC,2BAKD,CAHC,2BACC,2BACD,CAMJ,eACC,sBAaD,CAXC,kBACC,oBASD,CAJE,6CACC,sBACD,CCnCH,MACC,gCACD,CAEA,wBACC,oCAAwC,CACxC,gCAAiC,CACjC,mCAAoC,CACpC,+BA0BD,CAxBC,mCAIC,SAAU,CAMV,QAAS,CAOT,sBAMD,CAJC,+EAjBA,sCAAuC,CACvC,uCAmBA",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-styles-list {\n\tdisplay: grid;\n}\n\n.ck-content ol {\n\tlist-style-type: decimal;\n\n\t& ol {\n\t\tlist-style-type: lower-latin;\n\n\t\t& ol {\n\t\t\tlist-style-type: lower-roman;\n\n\t\t\t& ol {\n\t\t\t\tlist-style-type: upper-latin;\n\n\t\t\t\t& ol {\n\t\t\t\t\tlist-style-type: upper-roman;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck-content ul {\n\tlist-style-type: circle;\n\n\t& ul {\n\t\tlist-style-type: disc;\n\n\t\t& ul {\n\t\t\tlist-style-type: square;\n\n\t\t\t& ul {\n\t\t\t\tlist-style-type: square;\n\t\t\t}\n\t\t}\n\t}\n}\n",
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-list-style-button-size: 44px;\n}\n\n.ck.ck-list-styles-list {\n\tgrid-template-columns: repeat( 3, auto );\n\trow-gap: var(--ck-spacing-medium);\n\tcolumn-gap: var(--ck-spacing-medium);\n\tpadding: var(--ck-spacing-large);\n\n\t& .ck-button {\n\t\t/* Make the button look like a thumbnail (the icon "takes it all"). */\n\t\twidth: var(--ck-list-style-button-size);\n\t\theight: var(--ck-list-style-button-size);\n\t\tpadding: 0;\n\n\t\t/*\n\t\t * Buttons are aligned by the grid so disable default button margins to not collide with the\n\t\t * gaps in the grid.\n\t\t */\n\t\tmargin: 0;\n\n\t\t/*\n\t\t * Make sure the button border (which is displayed on focus, BTW) does not steal pixels\n\t\t * from the button dimensions and, as a result, decrease the size of the icon\n\t\t * (which becomes blurry as it scales down).\n\t\t */\n\t\tbox-sizing: content-box;\n\n\t\t& .ck-icon {\n\t\t\twidth: var(--ck-list-style-button-size);\n\t\t\theight: var(--ck-list-style-button-size);\n\t\t}\n\t}\n}\n',
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					":root{--ck-mention-list-max-height:300px}.ck.ck-mentions{max-height:var(--ck-mention-list-max-height);overflow-y:auto;overflow-x:hidden;overscroll-behavior:contain}.ck.ck-mentions>.ck-list__item{overflow:hidden;flex-shrink:0}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-mention/theme/mentionui.css",
						],
						names: [],
						mappings:
							"AAKA,MACC,kCACD,CAEA,gBACC,4CAA6C,CAE7C,eAAgB,CAIhB,iBAAkB,CAElB,2BAQD,CAJC,+BACC,eAAgB,CAChB,aACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-mention-list-max-height: 300px;\n}\n\n.ck.ck-mentions {\n\tmax-height: var(--ck-mention-list-max-height);\n\n\toverflow-y: auto;\n\n\t/* Prevent unnecessary horizontal scrollbar in Safari\n\thttps://github.com/ckeditor/ckeditor5-mention/issues/41 */\n\toverflow-x: hidden;\n\n\toverscroll-behavior: contain;\n\n\t/* Prevent unnecessary vertical scrollbar in Safari\n\thttps://github.com/ckeditor/ckeditor5-mention/issues/41 */\n\t& > .ck-list__item {\n\t\toverflow: hidden;\n\t\tflex-shrink: 0;\n\t}\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					":root{--ck-color-mention-background:rgba(153,0,48,0.1);--ck-color-mention-text:#990030}.ck-content .mention{background:var(--ck-color-mention-background);color:var(--ck-color-mention-text)}",
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-mention/mention.css",
						],
						names: [],
						mappings:
							"AAKA,MACC,gDAAwD,CACxD,+BACD,CAEA,qBACC,6CAA8C,CAC9C,kCACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-mention-background: hsla(341, 100%, 30%, 0.1);\n\t--ck-color-mention-text: hsl(341, 100%, 30%);\n}\n\n.ck-content .mention {\n\tbackground: var(--ck-color-mention-background);\n\tcolor: var(--ck-color-mention-text);\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					'.ck-source-editing-area{position:relative;overflow:hidden}.ck-source-editing-area:after,.ck-source-editing-area textarea{padding:var(--ck-spacing-large);margin:0;border:1px solid transparent;line-height:var(--ck-line-height-base);font-size:var(--ck-font-size-normal);font-family:monospace;white-space:pre-wrap}.ck-source-editing-area:after{content:attr(data-value) " ";visibility:hidden;display:block}.ck-source-editing-area textarea{position:absolute;width:100%;height:100%;resize:none;outline:none;overflow:hidden;box-sizing:border-box;border-color:var(--ck-color-base-border);border-radius:0}.ck-rounded-corners .ck-source-editing-area textarea,.ck-source-editing-area textarea.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck-source-editing-area textarea:not([readonly]):focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0}',
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-source-editing/theme/sourceediting.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
							"webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
						],
						names: [],
						mappings:
							"AASA,wBACC,iBAAkB,CAClB,eACD,CAEA,+DAEC,+BAAgC,CAChC,QAAS,CACT,4BAA6B,CAC7B,sCAAuC,CACvC,oCAAqC,CACrC,qBAAsB,CACtB,oBACD,CAEA,8BACC,4BAA6B,CAC7B,iBAAkB,CAClB,aACD,CAEA,iCACC,iBAAkB,CAClB,UAAW,CACX,WAAY,CACZ,WAAY,CACZ,YAAa,CACb,eAAgB,CAChB,qBAAsB,CAEtB,wCAAyC,CC7BzC,eDwCD,CApBA,yGChBE,qCAAsC,CD4BtC,wBAAyB,CACzB,yBAOF,CAJC,uDErCA,YAAa,CACb,2BAA2B,CCF3B,qCHyCA",
						sourcesContent: [
							'/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css";\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css";\n\n.ck-source-editing-area {\n\tposition: relative;\n\toverflow: hidden;\n}\n\n.ck-source-editing-area::after,\n.ck-source-editing-area textarea {\n\tpadding: var(--ck-spacing-large);\n\tmargin: 0;\n\tborder: 1px solid transparent;\n\tline-height: var(--ck-line-height-base);\n\tfont-size: var(--ck-font-size-normal);\n\tfont-family: monospace;\n\twhite-space: pre-wrap;\n}\n\n.ck-source-editing-area::after {\n\tcontent: attr(data-value) " ";\n\tvisibility: hidden;\n\tdisplay: block;\n}\n\n.ck-source-editing-area textarea {\n\tposition: absolute;\n\twidth: 100%;\n\theight: 100%;\n\tresize: none;\n\toutline: none;\n\toverflow: hidden;\n\tbox-sizing: border-box;\n\n\tborder-color: var(--ck-color-base-border);\n\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&:not([readonly]):focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n',
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				var o = n(2),
					i = n.n(o),
					r = n(3),
					s = n.n(r)()(i.a);
				s.push([
					t.i,
					':root{--ck-todo-list-checkmark-size:16px}.ck-content .todo-list{list-style:none}.ck-content .todo-list li{margin-bottom:5px}.ck-content .todo-list li .todo-list{margin-top:5px}.ck-content .todo-list .todo-list__label>input{-webkit-appearance:none;display:inline-block;position:relative;width:var(--ck-todo-list-checkmark-size);height:var(--ck-todo-list-checkmark-size);vertical-align:middle;border:0;left:-25px;margin-right:-15px;right:0;margin-left:0}.ck-content .todo-list .todo-list__label>input:before{display:block;position:absolute;box-sizing:border-box;content:"";width:100%;height:100%;border:1px solid #333;border-radius:2px;transition:box-shadow .25s ease-in-out,background .25s ease-in-out,border .25s ease-in-out}.ck-content .todo-list .todo-list__label>input:after{display:block;position:absolute;box-sizing:content-box;pointer-events:none;content:"";left:calc(var(--ck-todo-list-checkmark-size)/3);top:calc(var(--ck-todo-list-checkmark-size)/5.3);width:calc(var(--ck-todo-list-checkmark-size)/5.3);height:calc(var(--ck-todo-list-checkmark-size)/2.6);border-left:0 solid transparent;border-bottom:calc(var(--ck-todo-list-checkmark-size)/8) solid transparent;border-right:calc(var(--ck-todo-list-checkmark-size)/8) solid transparent;border-top:0 solid transparent;transform:rotate(45deg)}.ck-content .todo-list .todo-list__label>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-content .todo-list .todo-list__label>input[checked]:after{border-color:#fff}.ck-content .todo-list .todo-list__label .todo-list__label__description{vertical-align:middle}[dir=rtl] .todo-list .todo-list__label>input{left:0;margin-right:0;right:-25px;margin-left:-15px}.ck-editor__editable .todo-list .todo-list__label>input{cursor:pointer}.ck-editor__editable .todo-list .todo-list__label>input:hover:before{box-shadow:0 0 0 5px rgba(0,0,0,.1)}',
					"",
					{
						version: 3,
						sources: [
							"webpack://./node_modules/@ckeditor/ckeditor5-list/theme/todolist.css",
						],
						names: [],
						mappings:
							"AAKA,MACC,kCACD,CAEA,uBACC,eA0ED,CAxEC,0BACC,iBAKD,CAHC,qCACC,cACD,CAIA,+CACC,uBAAwB,CACxB,oBAAqB,CACrB,iBAAkB,CAClB,wCAAyC,CACzC,yCAA0C,CAC1C,qBAAsB,CAGtB,QAAS,CAGT,UAAW,CACX,kBAAmB,CACnB,OAAQ,CACR,aA0CD,CAxCC,sDACC,aAAc,CACd,iBAAkB,CAClB,qBAAsB,CACtB,UAAW,CACX,UAAW,CACX,WAAY,CACZ,qBAAiC,CACjC,iBAAkB,CAClB,0FACD,CAEA,qDACC,aAAc,CACd,iBAAkB,CAClB,sBAAuB,CACvB,mBAAoB,CACpB,UAAW,CAGX,+CAAoD,CACpD,gDAAqD,CACrD,kDAAuD,CACvD,mDAAwD,CAGxD,+BAA+G,CAA/G,0EAA+G,CAA/G,yEAA+G,CAA/G,8BAA+G,CAC/G,uBACD,CAGC,+DACC,kBAA8B,CAC9B,oBACD,CAEA,8DACC,iBACD,CAIF,wEACC,qBACD,CAKF,6CACC,MAAO,CACP,cAAe,CACf,WAAY,CACZ,iBACD,CAMA,wDACC,cAKD,CAHC,qEACC,mCACD",
						sourcesContent: [
							"/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-todo-list-checkmark-size: 16px;\n}\n\n.ck-content .todo-list {\n\tlist-style: none;\n\n\t& li {\n\t\tmargin-bottom: 5px;\n\n\t\t& .todo-list {\n\t\t\tmargin-top: 5px;\n\t\t}\n\t}\n\n\t& .todo-list__label {\n\t\t& > input {\n\t\t\t-webkit-appearance: none;\n\t\t\tdisplay: inline-block;\n\t\t\tposition: relative;\n\t\t\twidth: var(--ck-todo-list-checkmark-size);\n\t\t\theight: var(--ck-todo-list-checkmark-size);\n\t\t\tvertical-align: middle;\n\n\t\t\t/* Needed on iOS */\n\t\t\tborder: 0;\n\n\t\t\t/* LTR styles */\n\t\t\tleft: -25px;\n\t\t\tmargin-right: -15px;\n\t\t\tright: 0;\n\t\t\tmargin-left: 0;\n\n\t\t\t&::before {\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tbox-sizing: border-box;\n\t\t\t\tcontent: '';\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t\tborder: 1px solid hsl(0, 0%, 20%);\n\t\t\t\tborder-radius: 2px;\n\t\t\t\ttransition: 250ms ease-in-out box-shadow, 250ms ease-in-out background, 250ms ease-in-out border;\n\t\t\t}\n\n\t\t\t&::after {\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tbox-sizing: content-box;\n\t\t\t\tpointer-events: none;\n\t\t\t\tcontent: '';\n\n\t\t\t\t/* Calculate tick position, size and border-width proportional to the checkmark size. */\n\t\t\t\tleft: calc( var(--ck-todo-list-checkmark-size) / 3 );\n\t\t\t\ttop: calc( var(--ck-todo-list-checkmark-size) / 5.3 );\n\t\t\t\twidth: calc( var(--ck-todo-list-checkmark-size) / 5.3 );\n\t\t\t\theight: calc( var(--ck-todo-list-checkmark-size) / 2.6 );\n\t\t\t\tborder-style: solid;\n\t\t\t\tborder-color: transparent;\n\t\t\t\tborder-width: 0 calc( var(--ck-todo-list-checkmark-size) / 8 ) calc( var(--ck-todo-list-checkmark-size) / 8 ) 0;\n\t\t\t\ttransform: rotate(45deg);\n\t\t\t}\n\n\t\t\t&[checked] {\n\t\t\t\t&::before {\n\t\t\t\t\tbackground: hsl(126, 64%, 41%);\n\t\t\t\t\tborder-color: hsl(126, 64%, 41%);\n\t\t\t\t}\n\n\t\t\t\t&::after {\n\t\t\t\t\tborder-color: hsl(0, 0%, 100%);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t& .todo-list__label__description {\n\t\t\tvertical-align: middle;\n\t\t}\n\t}\n}\n\n/* RTL styles */\n[dir=\"rtl\"] .todo-list .todo-list__label > input {\n\tleft: 0;\n\tmargin-right: 0;\n\tright: -25px;\n\tmargin-left: -15px;\n}\n\n/*\n * To-do list should be interactive only during the editing\n * (https://github.com/ckeditor/ckeditor5/issues/2090).\n */\n.ck-editor__editable .todo-list .todo-list__label > input {\n\tcursor: pointer;\n\n\t&:hover::before {\n\t\tbox-shadow: 0 0 0 5px hsla(0, 0%, 0%, 0.1);\n\t}\n}\n",
						],
						sourceRoot: "",
					},
				]),
					(e.a = s);
			},
			function (t, e, n) {
				"use strict";
				(function (t) {
					var e = n(9);
					function o() {}
					function i(t) {
						return t();
					}
					function r() {
						return Object.create(null);
					}
					function s(t) {
						t.forEach(i);
					}
					function a(t) {
						return "function" == typeof t;
					}
					function c(t, e) {
						return t != t
							? e == e
							: t !== e ||
									(t && "object" == typeof t) ||
									"function" == typeof t;
					}
					let l, d;
					function u(t, e) {
						return (
							l || (l = document.createElement("a")), (l.href = e), t === l.href
						);
					}
					function h(t, e) {
						t.appendChild(e);
					}
					function p(t, e, n) {
						t.insertBefore(e, n || null);
					}
					function g(t) {
						t.parentNode.removeChild(t);
					}
					function f(t) {
						return document.createElement(t);
					}
					function m(t) {
						return document.createTextNode(t);
					}
					function k(t, e, n, o) {
						return (
							t.addEventListener(e, n, o), () => t.removeEventListener(e, n, o)
						);
					}
					function b(t, e, n) {
						null == n
							? t.removeAttribute(e)
							: t.getAttribute(e) !== n && t.setAttribute(e, n);
					}
					function w(t, e) {
						(e = "" + e), t.wholeText !== e && (t.data = e);
					}
					function A(t, e) {
						t.value = null == e ? "" : e;
					}
					function _(t, e, n, o) {
						null === n
							? t.style.removeProperty(e)
							: t.style.setProperty(e, n, o ? "important" : "");
					}
					function C(t) {
						d = t;
					}
					const v = [],
						y = [],
						x = [],
						D = [],
						E = Promise.resolve();
					let S = !1;
					function B() {
						S || ((S = !0), E.then(I));
					}
					function T(t) {
						x.push(t);
					}
					const P = new Set();
					let F = 0;
					function I() {
						const t = d;
						do {
							for (; F < v.length; ) {
								const t = v[F];
								F++, C(t), z(t.$$);
							}
							for (C(null), v.length = 0, F = 0; y.length; ) y.pop()();
							for (let t = 0; t < x.length; t += 1) {
								const e = x[t];
								P.has(e) || (P.add(e), e());
							}
							x.length = 0;
						} while (v.length);
						for (; D.length; ) D.pop()();
						(S = !1), P.clear(), C(t);
					}
					function z(t) {
						if (null !== t.fragment) {
							t.update(), s(t.before_update);
							const e = t.dirty;
							(t.dirty = [-1]),
								t.fragment && t.fragment.p(t.ctx, e),
								t.after_update.forEach(T);
						}
					}
					const R = new Set();
					const O =
						"undefined" != typeof window
							? window
							: "undefined" != typeof globalThis
								? globalThis
								: t;
					function M(t, e) {
						t.d(1), e.delete(t.key);
					}
					function N(t, e, n, o, i, r, s, a, c, l, d, u) {
						let h = t.length,
							p = r.length,
							g = h;
						const f = {};
						for (; g--; ) f[t[g].key] = g;
						const m = [],
							k = new Map(),
							b = new Map();
						for (g = p; g--; ) {
							const t = u(i, r, g),
								a = n(t);
							let c = s.get(a);
							c ? o && c.p(t, e) : ((c = l(a, t)), c.c()),
								k.set(a, (m[g] = c)),
								a in f && b.set(a, Math.abs(g - f[a]));
						}
						const w = new Set(),
							A = new Set();
						function _(t) {
							!(function (t, e) {
								t && t.i && (R.delete(t), t.i(e));
							})(t, 1),
								t.m(a, d),
								s.set(t.key, t),
								(d = t.first),
								p--;
						}
						for (; h && p; ) {
							const e = m[p - 1],
								n = t[h - 1],
								o = e.key,
								i = n.key;
							e === n
								? ((d = e.first), h--, p--)
								: k.has(i)
									? !s.has(o) || w.has(o)
										? _(e)
										: A.has(i)
											? h--
											: b.get(o) > b.get(i)
												? (A.add(o), _(e))
												: (w.add(i), h--)
									: (c(n, s), h--);
						}
						for (; h--; ) {
							const e = t[h];
							k.has(e.key) || c(e, s);
						}
						for (; p; ) _(m[p - 1]);
						return m;
					}
					function V(t, e, n, c, l, u, h, p = [-1]) {
						const g = d;
						C(t);
						const f = (t.$$ = {
							fragment: null,
							ctx: null,
							props: u,
							update: o,
							not_equal: l,
							bound: r(),
							on_mount: [],
							on_destroy: [],
							on_disconnect: [],
							before_update: [],
							after_update: [],
							context: new Map(g ? g.$$.context : []),
							callbacks: r(),
							dirty: p,
							skip_bound: !1,
							root: e.target || g.$$.root,
						});
						h && h(f.root);
						let m = !1;
						(f.ctx = n
							? n(t, e.props || {}, (e, n, ...o) => {
									const i = o.length ? o[0] : n;
									return (
										f.ctx &&
											l(f.ctx[e], (f.ctx[e] = i)) &&
											(!f.skip_bound && f.bound[e] && f.bound[e](i),
											m &&
												(function (t, e) {
													-1 === t.$$.dirty[0] &&
														(v.push(t), B(), t.$$.dirty.fill(0)),
														(t.$$.dirty[(e / 31) | 0] |= 1 << (e % 31));
												})(t, e)),
										n
									);
								})
							: []),
							f.update(),
							(m = !0),
							s(f.before_update),
							(f.fragment = !!c && c(f.ctx)),
							e.target &&
								(f.fragment && f.fragment.c(),
								(function (t, e, n, o) {
									const {
										fragment: r,
										on_mount: c,
										on_destroy: l,
										after_update: d,
									} = t.$$;
									r && r.m(e, n),
										o ||
											T(() => {
												const e = c.map(i).filter(a);
												l ? l.push(...e) : s(e), (t.$$.on_mount = []);
											}),
										d.forEach(T);
								})(t, e.target, void 0, void 0),
								I()),
							C(g);
					}
					class L {
						$destroy() {
							!(function (t, e) {
								const n = t.$$;
								null !== n.fragment &&
									(s(n.on_destroy),
									n.fragment && n.fragment.d(e),
									(n.on_destroy = n.fragment = null),
									(n.ctx = []));
							})(this, 1),
								(this.$destroy = o);
						}
						$on(t, e) {
							const n = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
							return (
								n.push(e),
								() => {
									const t = n.indexOf(e);
									-1 !== t && n.splice(t, 1);
								}
							);
						}
						$set(t) {
							var e;
							this.$$set &&
								((e = t), 0 !== Object.keys(e).length) &&
								((this.$$.skip_bound = !0),
								this.$$set(t),
								(this.$$.skip_bound = !1));
						}
					}
					const j = [
							[-1, "✨", "custom"],
							[0, "😀", "smileys-emotion"],
							[1, "👋", "people-body"],
							[3, "🐱", "animals-nature"],
							[4, "🍎", "food-drink"],
							[5, "🏠️", "travel-places"],
							[6, "⚽", "activities"],
							[7, "📝", "objects"],
							[8, "⛔️", "symbols"],
							[9, "🏁", "flags"],
						].map(([t, e, n]) => ({ id: t, emoji: e, name: n })),
						H = j.slice(1),
						$ = j[0],
						q =
							"function" == typeof requestIdleCallback
								? requestIdleCallback
								: setTimeout;
					function U(t) {
						return t.unicode.includes("‍");
					}
					const W = {
							"🫠": 14,
							"🥲": 13.1,
							"🥻": 12.1,
							"🥰": 11,
							"🤩": 5,
							"👱‍♀️": 4,
							"🤣": 3,
							"👁️‍🗨️": 2,
							"😀": 1,
							"😐️": 0.7,
							"😃": 0.6,
						},
						K = [
							"😊",
							"😒",
							"♥️",
							"👍️",
							"😍",
							"😂",
							"😭",
							"☺️",
							"😔",
							"😩",
							"😏",
							"💕",
							"🙌",
							"😘",
						],
						G =
							'"Twemoji Mozilla","Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji","EmojiOne Color","Android Emoji",sans-serif',
						J = (t, e) => (t < e ? -1 : t > e ? 1 : 0),
						Y = (t, e) => {
							const n = document.createElement("canvas");
							n.width = n.height = 1;
							const o = n.getContext("2d");
							return (
								(o.textBaseline = "top"),
								(o.font = `100px ${G}`),
								(o.fillStyle = e),
								o.scale(0.01, 0.01),
								o.fillText(t, 0, 0),
								o.getImageData(0, 0, 1, 1).data
							);
						};
					function Q(t) {
						const e = Y(t, "#000"),
							n = Y(t, "#fff");
						return (
							e &&
							n &&
							((t, e) => {
								const n = [...t].join(",");
								return n === [...e].join(",") && !n.startsWith("0,0,0,");
							})(e, n)
						);
					}
					const X = new Promise((t) =>
							q(() =>
								t(
									(function () {
										const t = Object.entries(W);
										try {
											for (const [e, n] of t) if (Q(e)) return n;
										} catch (t) {}
										return t[0][1];
									})(),
								),
							),
						),
						Z = new Map();
					function tt(t) {
						t.preventDefault(), t.stopPropagation();
					}
					function et(t, e, n) {
						return (
							(e += t ? -1 : 1) < 0
								? (e = n.length - 1)
								: e >= n.length && (e = 0),
							e
						);
					}
					function nt(t, e) {
						const n = new Set(),
							o = [];
						for (const i of t) {
							const t = e(i);
							n.has(t) || (n.add(t), o.push(i));
						}
						return o;
					}
					const ot = requestAnimationFrame;
					let it,
						rt = "function" == typeof ResizeObserver;
					function st(t) {
						{
							const e = document.createRange();
							return (
								e.selectNode(t.firstChild), e.getBoundingClientRect().width
							);
						}
					}
					const { Map: at } = O;
					function ct(t, e, n) {
						const o = t.slice();
						return (o[63] = e[n]), (o[65] = n), o;
					}
					function lt(t, e, n) {
						const o = t.slice();
						return (o[66] = e[n]), (o[65] = n), o;
					}
					function dt(t, e, n) {
						const o = t.slice();
						return (o[63] = e[n]), (o[65] = n), o;
					}
					function ut(t, e, n) {
						const o = t.slice();
						return (o[69] = e[n]), o;
					}
					function ht(t, e, n) {
						const o = t.slice();
						return (o[72] = e[n]), (o[65] = n), o;
					}
					function pt(t, e) {
						let n,
							o,
							i,
							r,
							s,
							a,
							c,
							l = e[72] + "";
						return {
							key: t,
							first: null,
							c() {
								(n = f("div")),
									(o = m(l)),
									b(n, "id", (i = "skintone-" + e[65])),
									b(
										n,
										"class",
										(r =
											"emoji hide-focus " + (e[65] === e[20] ? "active" : "")),
									),
									b(n, "aria-selected", (s = e[65] === e[20])),
									b(n, "role", "option"),
									b(n, "title", (a = e[0].skinTones[e[65]])),
									b(n, "tabindex", "-1"),
									b(n, "aria-label", (c = e[0].skinTones[e[65]])),
									(this.first = n);
							},
							m(t, e) {
								p(t, n, e), h(n, o);
							},
							p(t, d) {
								(e = t),
									512 & d[0] && l !== (l = e[72] + "") && w(o, l),
									512 & d[0] &&
										i !== (i = "skintone-" + e[65]) &&
										b(n, "id", i),
									1049088 & d[0] &&
										r !==
											(r =
												"emoji hide-focus " +
												(e[65] === e[20] ? "active" : "")) &&
										b(n, "class", r),
									1049088 & d[0] &&
										s !== (s = e[65] === e[20]) &&
										b(n, "aria-selected", s),
									513 & d[0] &&
										a !== (a = e[0].skinTones[e[65]]) &&
										b(n, "title", a),
									513 & d[0] &&
										c !== (c = e[0].skinTones[e[65]]) &&
										b(n, "aria-label", c);
							},
							d(t) {
								t && g(n);
							},
						};
					}
					function gt(t, e) {
						let n,
							o,
							i,
							r,
							s,
							a,
							c,
							l,
							d,
							u = e[69].emoji + "";
						function A() {
							return e[49](e[69]);
						}
						return {
							key: t,
							first: null,
							c() {
								(n = f("button")),
									(o = f("div")),
									(i = m(u)),
									b(o, "class", "nav-emoji emoji"),
									b(n, "role", "tab"),
									b(n, "class", "nav-button"),
									b(n, "aria-controls", (r = "tab-" + e[69].id)),
									b(n, "aria-label", (s = e[0].categories[e[69].name])),
									b(n, "aria-selected", (a = !e[4] && e[13].id === e[69].id)),
									b(n, "title", (c = e[0].categories[e[69].name])),
									(this.first = n);
							},
							m(t, e) {
								p(t, n, e),
									h(n, o),
									h(o, i),
									l || ((d = k(n, "click", A)), (l = !0));
							},
							p(t, o) {
								(e = t),
									4096 & o[0] && u !== (u = e[69].emoji + "") && w(i, u),
									4096 & o[0] &&
										r !== (r = "tab-" + e[69].id) &&
										b(n, "aria-controls", r),
									4097 & o[0] &&
										s !== (s = e[0].categories[e[69].name]) &&
										b(n, "aria-label", s),
									12304 & o[0] &&
										a !== (a = !e[4] && e[13].id === e[69].id) &&
										b(n, "aria-selected", a),
									4097 & o[0] &&
										c !== (c = e[0].categories[e[69].name]) &&
										b(n, "title", c);
							},
							d(t) {
								t && g(n), (l = !1), d();
							},
						};
					}
					function ft(t) {
						let e, n;
						return {
							c() {
								(e = f("img")),
									b(e, "class", "custom-emoji"),
									u(e.src, (n = t[63].url)) || b(e, "src", n),
									b(e, "alt", ""),
									b(e, "loading", "lazy");
							},
							m(t, n) {
								p(t, e, n);
							},
							p(t, o) {
								32768 & o[0] && !u(e.src, (n = t[63].url)) && b(e, "src", n);
							},
							d(t) {
								t && g(e);
							},
						};
					}
					function mt(t) {
						let e,
							n = t[27](t[63], t[8]) + "";
						return {
							c() {
								e = m(n);
							},
							m(t, n) {
								p(t, e, n);
							},
							p(t, o) {
								33024 & o[0] && n !== (n = t[27](t[63], t[8]) + "") && w(e, n);
							},
							d(t) {
								t && g(e);
							},
						};
					}
					function kt(t, e) {
						let n, o, i, r, s, a, c;
						function l(t, e) {
							return t[63].unicode ? mt : ft;
						}
						let d = l(e),
							u = d(e);
						return {
							key: t,
							first: null,
							c() {
								(n = f("button")),
									u.c(),
									b(n, "role", (o = e[4] ? "option" : "menuitem")),
									b(n, "aria-selected", (i = e[4] ? e[65] == e[5] : "")),
									b(n, "aria-label", (r = e[28](e[63], e[8]))),
									b(n, "title", (s = e[63].title)),
									b(
										n,
										"class",
										(a = "emoji " + (e[4] && e[65] === e[5] ? "active" : "")),
									),
									b(n, "id", (c = "emo-" + e[63].id)),
									(this.first = n);
							},
							m(t, e) {
								p(t, n, e), u.m(n, null);
							},
							p(t, h) {
								d === (d = l((e = t))) && u
									? u.p(e, h)
									: (u.d(1), (u = d(e)), u && (u.c(), u.m(n, null))),
									16 & h[0] &&
										o !== (o = e[4] ? "option" : "menuitem") &&
										b(n, "role", o),
									32816 & h[0] &&
										i !== (i = e[4] ? e[65] == e[5] : "") &&
										b(n, "aria-selected", i),
									33024 & h[0] &&
										r !== (r = e[28](e[63], e[8])) &&
										b(n, "aria-label", r),
									32768 & h[0] && s !== (s = e[63].title) && b(n, "title", s),
									32816 & h[0] &&
										a !==
											(a =
												"emoji " + (e[4] && e[65] === e[5] ? "active" : "")) &&
										b(n, "class", a),
									32768 & h[0] &&
										c !== (c = "emo-" + e[63].id) &&
										b(n, "id", c);
							},
							d(t) {
								t && g(n), u.d();
							},
						};
					}
					function bt(t, e) {
						let n,
							o,
							i,
							r,
							s,
							a,
							c,
							l,
							d =
								(e[4]
									? e[0].searchResultsLabel
									: e[66].category
										? e[66].category
										: e[15].length > 1
											? e[0].categories.custom
											: e[0].categories[e[13].name]) + "",
							u = [],
							k = new at(),
							A = e[66].emojis;
						const _ = (t) => t[63].id;
						for (let t = 0; t < A.length; t += 1) {
							let n = dt(e, A, t),
								o = _(n);
							k.set(o, (u[t] = kt(o, n)));
						}
						return {
							key: t,
							first: null,
							c() {
								(n = f("div")), (o = m(d)), (s = f("div"));
								for (let t = 0; t < u.length; t += 1) u[t].c();
								b(n, "id", (i = "menu-label-" + e[65])),
									b(
										n,
										"class",
										(r =
											"category " +
											(1 === e[15].length && "" === e[15][0].category
												? "gone"
												: "")),
									),
									b(n, "aria-hidden", "true"),
									b(s, "class", "emoji-menu"),
									b(s, "role", (a = e[4] ? "listbox" : "menu")),
									b(s, "aria-labelledby", (c = "menu-label-" + e[65])),
									b(s, "id", (l = e[4] ? "search-results" : "")),
									(this.first = n);
							},
							m(t, e) {
								p(t, n, e), h(n, o), p(t, s, e);
								for (let t = 0; t < u.length; t += 1) u[t].m(s, null);
							},
							p(t, h) {
								(e = t),
									40977 & h[0] &&
										d !==
											(d =
												(e[4]
													? e[0].searchResultsLabel
													: e[66].category
														? e[66].category
														: e[15].length > 1
															? e[0].categories.custom
															: e[0].categories[e[13].name]) + "") &&
										w(o, d),
									32768 & h[0] &&
										i !== (i = "menu-label-" + e[65]) &&
										b(n, "id", i),
									32768 & h[0] &&
										r !==
											(r =
												"category " +
												(1 === e[15].length && "" === e[15][0].category
													? "gone"
													: "")) &&
										b(n, "class", r),
									402686256 & h[0] &&
										((A = e[66].emojis),
										(u = N(u, h, _, 1, e, A, k, s, M, kt, null, dt))),
									16 & h[0] &&
										a !== (a = e[4] ? "listbox" : "menu") &&
										b(s, "role", a),
									32768 & h[0] &&
										c !== (c = "menu-label-" + e[65]) &&
										b(s, "aria-labelledby", c),
									16 & h[0] &&
										l !== (l = e[4] ? "search-results" : "") &&
										b(s, "id", l);
							},
							d(t) {
								t && g(n), t && g(s);
								for (let t = 0; t < u.length; t += 1) u[t].d();
							},
						};
					}
					function wt(t) {
						let e, n;
						return {
							c() {
								(e = f("img")),
									b(e, "class", "custom-emoji"),
									u(e.src, (n = t[63].url)) || b(e, "src", n),
									b(e, "alt", ""),
									b(e, "loading", "lazy");
							},
							m(t, n) {
								p(t, e, n);
							},
							p(t, o) {
								1024 & o[0] && !u(e.src, (n = t[63].url)) && b(e, "src", n);
							},
							d(t) {
								t && g(e);
							},
						};
					}
					function At(t) {
						let e,
							n = t[27](t[63], t[8]) + "";
						return {
							c() {
								e = m(n);
							},
							m(t, n) {
								p(t, e, n);
							},
							p(t, o) {
								1280 & o[0] && n !== (n = t[27](t[63], t[8]) + "") && w(e, n);
							},
							d(t) {
								t && g(e);
							},
						};
					}
					function _t(t, e) {
						let n, o, i, r;
						function s(t, e) {
							return t[63].unicode ? At : wt;
						}
						let a = s(e),
							c = a(e);
						return {
							key: t,
							first: null,
							c() {
								(n = f("button")),
									c.c(),
									b(n, "role", "menuitem"),
									b(n, "aria-label", (o = e[28](e[63], e[8]))),
									b(n, "title", (i = e[63].title)),
									b(n, "class", "emoji"),
									b(n, "id", (r = "fav-" + e[63].id)),
									(this.first = n);
							},
							m(t, e) {
								p(t, n, e), c.m(n, null);
							},
							p(t, l) {
								a === (a = s((e = t))) && c
									? c.p(e, l)
									: (c.d(1), (c = a(e)), c && (c.c(), c.m(n, null))),
									1280 & l[0] &&
										o !== (o = e[28](e[63], e[8])) &&
										b(n, "aria-label", o),
									1024 & l[0] && i !== (i = e[63].title) && b(n, "title", i),
									1024 & l[0] && r !== (r = "fav-" + e[63].id) && b(n, "id", r);
							},
							d(t) {
								t && g(n), c.d();
							},
						};
					}
					function Ct(t) {
						let e,
							n,
							i,
							r,
							c,
							l,
							d,
							u,
							C,
							v,
							y,
							x,
							D,
							E,
							S,
							B,
							T,
							P,
							F,
							I,
							z,
							R,
							O,
							V,
							L,
							j,
							H,
							$,
							q,
							U,
							W,
							K,
							G,
							J,
							Y,
							Q,
							X,
							Z,
							tt,
							et,
							nt,
							ot,
							it,
							rt,
							st = t[0].searchLabel + "",
							dt = t[0].searchDescription + "",
							ft = t[0].skinToneDescription + "",
							mt = [],
							kt = new at(),
							wt = [],
							At = new at(),
							Ct = [],
							vt = new at(),
							yt = [],
							xt = new at(),
							Dt = t[9];
						const Et = (t) => t[72];
						for (let e = 0; e < Dt.length; e += 1) {
							let n = ht(t, Dt, e),
								o = Et(n);
							kt.set(o, (mt[e] = pt(o, n)));
						}
						let St = t[12];
						const Bt = (t) => t[69].id;
						for (let e = 0; e < St.length; e += 1) {
							let n = ut(t, St, e),
								o = Bt(n);
							At.set(o, (wt[e] = gt(o, n)));
						}
						let Tt = t[15];
						const Pt = (t) => t[66].category;
						for (let e = 0; e < Tt.length; e += 1) {
							let n = lt(t, Tt, e),
								o = Pt(n);
							vt.set(o, (Ct[e] = bt(o, n)));
						}
						let Ft = t[10];
						const It = (t) => t[63].id;
						for (let e = 0; e < Ft.length; e += 1) {
							let n = ct(t, Ft, e),
								o = It(n);
							xt.set(o, (yt[e] = _t(o, n)));
						}
						return {
							c() {
								(e = f("section")),
									(n = f("div")),
									(i = f("div")),
									(r = f("div")),
									(c = f("input")),
									(C = f("label")),
									(v = m(st)),
									(y = f("span")),
									(x = m(dt)),
									(D = f("div")),
									(E = f("button")),
									(S = m(t[21])),
									(P = f("span")),
									(F = m(ft)),
									(I = f("div"));
								for (let t = 0; t < mt.length; t += 1) mt[t].c();
								L = f("div");
								for (let t = 0; t < wt.length; t += 1) wt[t].c();
								(H = f("div")),
									($ = f("div")),
									(q = f("div")),
									(U = m(t[18])),
									(K = f("div")),
									(G = f("div"));
								for (let t = 0; t < Ct.length; t += 1) Ct[t].c();
								Z = f("div");
								for (let t = 0; t < yt.length; t += 1) yt[t].c();
								(nt = f("button")),
									(nt.textContent = "😀"),
									b(n, "class", "pad-top"),
									b(c, "id", "search"),
									b(c, "class", "search"),
									b(c, "type", "search"),
									b(c, "role", "combobox"),
									b(c, "enterkeyhint", "search"),
									b(c, "placeholder", (l = t[0].searchLabel)),
									b(c, "autocapitalize", "none"),
									b(c, "autocomplete", "off"),
									b(c, "spellcheck", "true"),
									b(c, "aria-expanded", (d = !(!t[4] || !t[1].length))),
									b(c, "aria-controls", "search-results"),
									b(c, "aria-describedby", "search-description"),
									b(c, "aria-autocomplete", "list"),
									b(
										c,
										"aria-activedescendant",
										(u = t[26] ? `emo-${t[26]}` : ""),
									),
									b(C, "class", "sr-only"),
									b(C, "for", "search"),
									b(y, "id", "search-description"),
									b(y, "class", "sr-only"),
									b(r, "class", "search-wrapper"),
									b(E, "id", "skintone-button"),
									b(E, "class", (B = "emoji " + (t[6] ? "hide-focus" : ""))),
									b(E, "aria-label", t[23]),
									b(E, "title", t[23]),
									b(E, "aria-describedby", "skintone-description"),
									b(E, "aria-haspopup", "listbox"),
									b(E, "aria-expanded", t[6]),
									b(E, "aria-controls", "skintone-list"),
									b(
										D,
										"class",
										(T =
											"skintone-button-wrapper " + (t[19] ? "expanded" : "")),
									),
									b(P, "id", "skintone-description"),
									b(P, "class", "sr-only"),
									b(I, "id", "skintone-list"),
									b(
										I,
										"class",
										(z = "skintone-list " + (t[6] ? "" : "hidden no-animate")),
									),
									_(
										I,
										"transform",
										"translateY(" +
											(t[6]
												? 0
												: "calc(-1 * var(--num-skintones) * var(--total-emoji-size))") +
											")",
									),
									b(I, "role", "listbox"),
									b(I, "aria-label", (R = t[0].skinTonesLabel)),
									b(I, "aria-activedescendant", (O = "skintone-" + t[20])),
									b(I, "aria-hidden", (V = !t[6])),
									b(i, "class", "search-row"),
									b(L, "class", "nav"),
									b(L, "role", "tablist"),
									_(
										L,
										"grid-template-columns",
										"repeat(" + t[12].length + ", 1fr)",
									),
									b(L, "aria-label", (j = t[0].categoriesLabel)),
									b($, "class", "indicator"),
									_(
										$,
										"transform",
										"translateX(" + (t[24] ? -1 : 1) * t[11] * 100 + "%)",
									),
									b(H, "class", "indicator-wrapper"),
									b(q, "class", (W = "message " + (t[18] ? "" : "gone"))),
									b(q, "role", "alert"),
									b(q, "aria-live", "polite"),
									b(
										K,
										"class",
										(J = "tabpanel " + (!t[14] || t[18] ? "gone" : "")),
									),
									b(K, "role", (Y = t[4] ? "region" : "tabpanel")),
									b(
										K,
										"aria-label",
										(Q = t[4]
											? t[0].searchResultsLabel
											: t[0].categories[t[13].name]),
									),
									b(K, "id", (X = t[4] ? "" : `tab-${t[13].id}`)),
									b(K, "tabindex", "0"),
									b(
										Z,
										"class",
										(tt = "favorites emoji-menu " + (t[18] ? "gone" : "")),
									),
									b(Z, "role", "menu"),
									b(Z, "aria-label", (et = t[0].favoritesLabel)),
									_(Z, "padding-inline-end", t[25] + "px"),
									b(nt, "aria-hidden", "true"),
									b(nt, "tabindex", "-1"),
									b(nt, "class", "abs-pos hidden emoji"),
									b(e, "class", "picker"),
									b(e, "aria-label", (ot = t[0].regionLabel)),
									b(e, "style", t[22]);
							},
							m(s, l) {
								p(s, e, l),
									h(e, n),
									h(e, i),
									h(i, r),
									h(r, c),
									A(c, t[2]),
									h(r, C),
									h(C, v),
									h(r, y),
									h(y, x),
									h(i, D),
									h(D, E),
									h(E, S),
									h(i, P),
									h(P, F),
									h(i, I);
								for (let t = 0; t < mt.length; t += 1) mt[t].m(I, null);
								t[48](I), h(e, L);
								for (let t = 0; t < wt.length; t += 1) wt[t].m(L, null);
								h(e, H), h(H, $), h(e, q), h(q, U), h(e, K), h(K, G);
								for (let t = 0; t < Ct.length; t += 1) Ct[t].m(G, null);
								t[50](K), h(e, Z);
								for (let t = 0; t < yt.length; t += 1) yt[t].m(Z, null);
								var d;
								h(e, nt),
									t[51](nt),
									t[52](e),
									it ||
										((rt = [
											k(c, "input", t[47]),
											k(c, "keydown", t[30]),
											k(E, "click", t[35]),
											k(I, "focusout", t[38]),
											k(I, "click", t[34]),
											k(I, "keydown", t[36]),
											k(I, "keyup", t[37]),
											k(L, "keydown", t[32]),
											((d = t[29].call(null, G)),
											d && a(d.destroy) ? d.destroy : o),
											k(K, "click", t[33]),
											k(Z, "click", t[33]),
										]),
										(it = !0));
							},
							p(t, n) {
								1 & n[0] &&
									l !== (l = t[0].searchLabel) &&
									b(c, "placeholder", l),
									18 & n[0] &&
										d !== (d = !(!t[4] || !t[1].length)) &&
										b(c, "aria-expanded", d),
									67108864 & n[0] &&
										u !== (u = t[26] ? `emo-${t[26]}` : "") &&
										b(c, "aria-activedescendant", u),
									4 & n[0] && A(c, t[2]),
									1 & n[0] && st !== (st = t[0].searchLabel + "") && w(v, st),
									1 & n[0] &&
										dt !== (dt = t[0].searchDescription + "") &&
										w(x, dt),
									2097152 & n[0] && w(S, t[21]),
									64 & n[0] &&
										B !== (B = "emoji " + (t[6] ? "hide-focus" : "")) &&
										b(E, "class", B),
									8388608 & n[0] && b(E, "aria-label", t[23]),
									8388608 & n[0] && b(E, "title", t[23]),
									64 & n[0] && b(E, "aria-expanded", t[6]),
									524288 & n[0] &&
										T !==
											(T =
												"skintone-button-wrapper " +
												(t[19] ? "expanded" : "")) &&
										b(D, "class", T),
									1 & n[0] &&
										ft !== (ft = t[0].skinToneDescription + "") &&
										w(F, ft),
									1049089 & n[0] &&
										((Dt = t[9]),
										(mt = N(mt, n, Et, 1, t, Dt, kt, I, M, pt, null, ht))),
									64 & n[0] &&
										z !==
											(z =
												"skintone-list " + (t[6] ? "" : "hidden no-animate")) &&
										b(I, "class", z),
									64 & n[0] &&
										_(
											I,
											"transform",
											"translateY(" +
												(t[6]
													? 0
													: "calc(-1 * var(--num-skintones) * var(--total-emoji-size))") +
												")",
										),
									1 & n[0] &&
										R !== (R = t[0].skinTonesLabel) &&
										b(I, "aria-label", R),
									1048576 & n[0] &&
										O !== (O = "skintone-" + t[20]) &&
										b(I, "aria-activedescendant", O),
									64 & n[0] && V !== (V = !t[6]) && b(I, "aria-hidden", V),
									(12305 & n[0]) | (1 & n[1]) &&
										((St = t[12]),
										(wt = N(wt, n, Bt, 1, t, St, At, L, M, gt, null, ut))),
									4096 & n[0] &&
										_(
											L,
											"grid-template-columns",
											"repeat(" + t[12].length + ", 1fr)",
										),
									1 & n[0] &&
										j !== (j = t[0].categoriesLabel) &&
										b(L, "aria-label", j),
									16779264 & n[0] &&
										_(
											$,
											"transform",
											"translateX(" + (t[24] ? -1 : 1) * t[11] * 100 + "%)",
										),
									262144 & n[0] && w(U, t[18]),
									262144 & n[0] &&
										W !== (W = "message " + (t[18] ? "" : "gone")) &&
										b(q, "class", W),
									402694449 & n[0] &&
										((Tt = t[15]),
										(Ct = N(Ct, n, Pt, 1, t, Tt, vt, G, M, bt, null, lt))),
									278528 & n[0] &&
										J !== (J = "tabpanel " + (!t[14] || t[18] ? "gone" : "")) &&
										b(K, "class", J),
									16 & n[0] &&
										Y !== (Y = t[4] ? "region" : "tabpanel") &&
										b(K, "role", Y),
									8209 & n[0] &&
										Q !==
											(Q = t[4]
												? t[0].searchResultsLabel
												: t[0].categories[t[13].name]) &&
										b(K, "aria-label", Q),
									8208 & n[0] &&
										X !== (X = t[4] ? "" : `tab-${t[13].id}`) &&
										b(K, "id", X),
									402654464 & n[0] &&
										((Ft = t[10]),
										(yt = N(yt, n, It, 1, t, Ft, xt, Z, M, _t, null, ct))),
									262144 & n[0] &&
										tt !==
											(tt = "favorites emoji-menu " + (t[18] ? "gone" : "")) &&
										b(Z, "class", tt),
									1 & n[0] &&
										et !== (et = t[0].favoritesLabel) &&
										b(Z, "aria-label", et),
									33554432 & n[0] && _(Z, "padding-inline-end", t[25] + "px"),
									1 & n[0] &&
										ot !== (ot = t[0].regionLabel) &&
										b(e, "aria-label", ot),
									4194304 & n[0] && b(e, "style", t[22]);
							},
							i: o,
							o: o,
							d(n) {
								n && g(e);
								for (let t = 0; t < mt.length; t += 1) mt[t].d();
								t[48](null);
								for (let t = 0; t < wt.length; t += 1) wt[t].d();
								for (let t = 0; t < Ct.length; t += 1) Ct[t].d();
								t[50](null);
								for (let t = 0; t < yt.length; t += 1) yt[t].d();
								t[51](null), t[52](null), (it = !1), s(rt);
							},
						};
					}
					function vt(t, e, n) {
						let o,
							i,
							r,
							s,
							a,
							c,
							l,
							d,
							u,
							h,
							{ skinToneEmoji: p } = e,
							{ i18n: g } = e,
							{ database: f } = e,
							{ customEmoji: m } = e,
							{ customCategorySorting: k } = e,
							b = [],
							w = [],
							A = "",
							_ = "",
							C = !1,
							v = -1,
							x = !1,
							D = !1,
							S = 0,
							T = 0,
							P = "",
							F = [],
							I = [],
							z = 8,
							R = !1,
							O = 0,
							M = 0,
							N = H,
							V = !1;
						const L = (t) => {
								o.getRootNode().getElementById(t).focus();
							},
							j = (t, e) => {
								o.dispatchEvent(
									new CustomEvent(t, { detail: e, bubbles: !0, composed: !0 }),
								);
							},
							W = (t, e) => (e && t.skins && t.skins[e]) || t.unicode,
							J = (t) => /^skintone-/.test(t.id);
						function Y(t) {
							const e = o.getRootNode();
							!(function (t, e, n) {
								for (const o of t) {
									const t = st(n(o));
									void 0 === it && (it = st(e));
									const i = t / 1.8 < it;
									Z.set(o.unicode, i);
								}
							})(t, i, (t) => e.getElementById(`emo-${t.id}`)),
								n(1, b);
						}
						function Q(t) {
							return !t.unicode || !U(t) || Z.get(t.unicode);
						}
						async function at(t) {
							const e = await X;
							return t.filter(({ version: t }) => !t || t <= e);
						}
						async function ct(t) {
							return (function (t, e) {
								const n = (t) => {
									const n = {};
									for (const o of t)
										"number" == typeof o.tone &&
											o.version <= e &&
											(n[o.tone] = o.unicode);
									return n;
								};
								return t.map(
									({
										unicode: t,
										skins: e,
										shortcodes: o,
										url: i,
										name: r,
										category: s,
									}) => ({
										unicode: t,
										name: r,
										shortcodes: o,
										url: i,
										category: s,
										id: t || r,
										skins: e && n(e),
										title: (o || []).join(", "),
									}),
								);
							})(t, await X);
						}
						function lt(t) {
							n(2, (A = "")),
								n(44, (_ = "")),
								n(5, (v = -1)),
								n(11, (M = N.findIndex((e) => e.id === t.id)));
						}
						async function dt(t) {
							const e = await f.getEmojiByUnicodeOrName(t),
								n = [...b, ...I].find((e) => e.id === t),
								o = n.unicode && W(n, S);
							await f.incrementFavoriteEmojiCount(t),
								j("emoji-click", {
									emoji: e,
									skinTone: S,
									...(o && { unicode: o }),
									...(n.name && { name: n.name }),
								});
						}
						async function ut(t) {
							const { target: e } = t;
							if (!J(e)) return;
							tt(t);
							const o = parseInt(e.id.slice(9), 10);
							n(8, (S = o)),
								n(6, (x = !1)),
								L("skintone-button"),
								j("skin-tone-change", { skinTone: o }),
								f.setPreferredSkinTone(o);
						}
						X.then((t) => {
							t || n(18, (s = g.emojiUnsupportedMessage));
						});
						return (
							(t.$$set = (t) => {
								"skinToneEmoji" in t && n(40, (p = t.skinToneEmoji)),
									"i18n" in t && n(0, (g = t.i18n)),
									"database" in t && n(39, (f = t.database)),
									"customEmoji" in t && n(41, (m = t.customEmoji)),
									"customCategorySorting" in t &&
										n(42, (k = t.customCategorySorting));
							}),
							(t.$$.update = () => {
								if (
									(1280 & t.$$.dirty[1] &&
										m &&
										f &&
										n(39, (f.customEmoji = m), f),
									(1 & t.$$.dirty[0]) | (256 & t.$$.dirty[1]))
								) {
									async function e() {
										let t = !1;
										const e = setTimeout(() => {
											(t = !0), n(18, (s = g.loadingMessage));
										}, 1e3);
										try {
											await f.ready(), n(14, (V = !0));
										} catch (t) {
											console.error(t), n(18, (s = g.networkErrorMessage));
										} finally {
											clearTimeout(e), t && ((t = !1), n(18, (s = "")));
										}
									}
									f && e();
								}
								if (
									((6144 & t.$$.dirty[0]) | (1024 & t.$$.dirty[1]) &&
										(m && m.length
											? n(12, (N = [$, ...H]))
											: N !== H && (M && n(11, M--, M), n(12, (N = H)))),
									4 & t.$$.dirty[0] &&
										q(() => {
											n(44, (_ = (A || "").trim())), n(5, (v = -1));
										}),
									6144 & t.$$.dirty[0] && n(13, (u = N[M])),
									(24576 & t.$$.dirty[0]) | (8192 & t.$$.dirty[1]))
								) {
									async function o() {
										if (V) {
											if (_.length >= 2) {
												const t = _,
													e = await (async function (t) {
														return ct(
															await at(await f.getEmojiBySearchQuery(t)),
														);
													})(t);
												t === _ && (n(1, (b = e)), n(4, (C = !0)));
											} else if (u) {
												const t = u.id,
													e = await (async function (t) {
														if (void 0 === t) return [];
														const e = -1 === t ? m : await f.getEmojiByGroup(t);
														return ct(await at(e));
													})(t);
												t === u.id && (n(1, (b = e)), n(4, (C = !1)));
											}
										} else n(1, (b = [])), n(4, (C = !1));
									}
									o();
								}
								if (
									(4112 & t.$$.dirty[0] &&
										n(
											22,
											(l = `\n  --font-family: ${G};\n  --num-groups: ${N.length}; \n  --indicator-opacity: ${C ? 0 : 1}; \n  --num-skintones: 6;`),
										),
									(16384 & t.$$.dirty[0]) | (256 & t.$$.dirty[1]))
								) {
									async function i() {
										V && n(8, (S = await f.getPreferredSkinTone()));
									}
									i();
								}
								if (
									(512 & t.$$.dirty[1] &&
										n(
											9,
											(F = Array(6)
												.fill()
												.map((t, e) =>
													(function (t, e) {
														if (0 === e) return t;
														const n = t.indexOf("‍");
														return -1 !== n
															? t.substring(0, n) +
																	String.fromCodePoint(127995 + e - 1) +
																	t.substring(n)
															: (t.endsWith("️") &&
																	(t = t.substring(0, t.length - 1)),
																t +
																	"\ud83c" +
																	String.fromCodePoint(57339 + e - 1));
													})(p, e),
												)),
										),
									768 & t.$$.dirty[0] && n(21, (c = F[S])),
									257 & t.$$.dirty[0] &&
										n(
											23,
											(P = g.skinToneLabel.replace(
												"{skinTone}",
												g.skinTones[S],
											)),
										),
									(16384 & t.$$.dirty[0]) | (256 & t.$$.dirty[1]))
								) {
									async function y() {
										n(
											45,
											(d = (
												await Promise.all(
													K.map((t) => f.getEmojiByUnicodeOrName(t)),
												)
											).filter(Boolean)),
										);
									}
									V && y();
								}
								if ((16384 & t.$$.dirty[0]) | (49408 & t.$$.dirty[1])) {
									async function E() {
										const t = await f.getTopFavoriteEmoji(z),
											e = await ct(
												nt([...t, ...d], (t) => t.unicode || t.name).slice(
													0,
													z,
												),
											);
										n(10, (I = e));
									}
									V && d && E();
								}
								if (10 & t.$$.dirty[0]) {
									const B = b
										.filter((t) => t.unicode)
										.filter((t) => U(t) && !Z.has(t.unicode));
									B.length
										? ot(() => Y(B))
										: (n(1, (b = b.filter(Q))),
											ot(() => {
												(r || {}).scrollTop = 0;
											}));
								}
								if (
									(t.$$.dirty[0],
									t.$$.dirty[1],
									(18 & t.$$.dirty[0]) | (2048 & t.$$.dirty[1]))
								) {
									function T() {
										if (C) return [{ category: "", emojis: b }];
										const t = new Map();
										for (const e of b) {
											const n = e.category || "";
											let o = t.get(n);
											o || ((o = []), t.set(n, o)), o.push(e);
										}
										return [...t.entries()]
											.map(([t, e]) => ({ category: t, emojis: e }))
											.sort((t, e) => k(t.category, e.category));
									}
									n(15, (w = T()));
								}
								34 & t.$$.dirty[0] && n(26, (h = -1 !== v && b[v].id)),
									192 & t.$$.dirty[0] &&
										(x
											? a.addEventListener(
													"transitionend",
													() => {
														n(19, (D = !0));
													},
													{ once: !0 },
												)
											: n(19, (D = !1)));
							}),
							[
								g,
								b,
								A,
								r,
								C,
								v,
								x,
								a,
								S,
								F,
								I,
								M,
								N,
								u,
								V,
								w,
								o,
								i,
								s,
								D,
								T,
								c,
								l,
								P,
								R,
								O,
								h,
								W,
								(t, e) => {
									return ((n = [t.name || W(t, e), ...(t.shortcodes || [])]),
									nt(n, (t) => t)).join(", ");
									var n;
								},
								function (t) {
									return (function (t, e) {
										let n;
										return (
											rt
												? ((n = new ResizeObserver((t) =>
														e(t[0].contentRect.width),
													)),
													n.observe(t))
												: ot(() => e(t.getBoundingClientRect().width)),
											{
												destroy() {
													n && n.disconnect();
												},
											}
										);
									})(t, (e) => {
										{
											const i = getComputedStyle(o),
												r = parseInt(i.getPropertyValue("--num-columns"), 10),
												s = "rtl" === i.getPropertyValue("direction"),
												a = t.parentElement.getBoundingClientRect().width - e;
											n(46, (z = r)), n(25, (O = a)), n(24, (R = s));
										}
									});
								},
								function (t) {
									if (!C || !b.length) return;
									const e = (e) => {
										tt(t), n(5, (v = et(e, v, b)));
									};
									switch (t.key) {
										case "ArrowDown":
											return e(!1);
										case "ArrowUp":
											return e(!0);
										case "Enter":
											if (-1 !== v) return tt(t), dt(b[v].id);
											b.length && n(5, (v = 0));
									}
								},
								lt,
								function (t) {
									const { target: e, key: n } = t,
										o = (e) => {
											e && (tt(t), e.focus());
										};
									switch (n) {
										case "ArrowLeft":
											return o(e.previousSibling);
										case "ArrowRight":
											return o(e.nextSibling);
										case "Home":
											return o(e.parentElement.firstChild);
										case "End":
											return o(e.parentElement.lastChild);
									}
								},
								async function (t) {
									const { target: e } = t;
									if (!e.classList.contains("emoji")) return;
									tt(t), dt(e.id.substring(4));
								},
								ut,
								async function (t) {
									n(6, (x = !x)),
										n(20, (T = S)),
										x && (tt(t), ot(() => L(`skintone-${T}`)));
								},
								function (t) {
									if (!x) return;
									const e = async (e) => {
										tt(t), n(20, (T = e)), await (B(), E), L(`skintone-${T}`);
									};
									switch (t.key) {
										case "ArrowUp":
											return e(et(!0, T, F));
										case "ArrowDown":
											return e(et(!1, T, F));
										case "Home":
											return e(0);
										case "End":
											return e(F.length - 1);
										case "Enter":
											return ut(t);
										case "Escape":
											return tt(t), n(6, (x = !1)), L("skintone-button");
									}
								},
								function (t) {
									if (x) return " " === t.key ? ut(t) : void 0;
								},
								async function (t) {
									const { relatedTarget: e } = t;
									(e && J(e)) || n(6, (x = !1));
								},
								f,
								p,
								m,
								k,
								!0,
								_,
								d,
								z,
								function () {
									(A = this.value), n(2, A);
								},
								function (t) {
									y[t ? "unshift" : "push"](() => {
										(a = t), n(7, a);
									});
								},
								(t) => lt(t),
								function (t) {
									y[t ? "unshift" : "push"](() => {
										(r = t), n(3, r);
									});
								},
								function (t) {
									y[t ? "unshift" : "push"](() => {
										(i = t), n(17, i);
									});
								},
								function (t) {
									y[t ? "unshift" : "push"](() => {
										(o = t), n(16, o);
									});
								},
							]
						);
					}
					class yt extends L {
						constructor(t) {
							super(),
								V(
									this,
									t,
									vt,
									Ct,
									c,
									{
										skinToneEmoji: 40,
										i18n: 0,
										database: 39,
										customEmoji: 41,
										customCategorySorting: 42,
									},
									null,
									[-1, -1, -1],
								);
						}
					}
					var xt = {
						categoriesLabel: "Categories",
						emojiUnsupportedMessage:
							"Your browser does not support color emoji.",
						favoritesLabel: "Favorites",
						loadingMessage: "Loading…",
						networkErrorMessage: "Could not load emoji.",
						regionLabel: "Emoji picker",
						searchDescription:
							"When search results are available, press up or down to select and enter to choose.",
						searchLabel: "Search",
						searchResultsLabel: "Search results",
						skinToneDescription:
							"When expanded, press up or down to select and enter to choose.",
						skinToneLabel: "Choose a skin tone (currently {skinTone})",
						skinTonesLabel: "Skin tones",
						skinTones: [
							"Default",
							"Light",
							"Medium-Light",
							"Medium",
							"Medium-Dark",
							"Dark",
						],
						categories: {
							custom: "Custom",
							"smileys-emotion": "Smileys and emoticons",
							"people-body": "People and body",
							"animals-nature": "Animals and nature",
							"food-drink": "Food and drink",
							"travel-places": "Travel and places",
							activities: "Activities",
							objects: "Objects",
							symbols: "Symbols",
							flags: "Flags",
						},
					};
					const Dt = [
						"customEmoji",
						"customCategorySorting",
						"database",
						"dataSource",
						"i18n",
						"locale",
						"skinToneEmoji",
					];
					class Et extends HTMLElement {
						constructor(t) {
							super(), this.attachShadow({ mode: "open" });
							const e = document.createElement("style");
							(e.textContent =
								":host{--emoji-size:1.375rem;--emoji-padding:0.5rem;--category-emoji-size:var(--emoji-size);--category-emoji-padding:var(--emoji-padding);--indicator-height:3px;--input-border-radius:0.5rem;--input-border-size:1px;--input-font-size:1rem;--input-line-height:1.5;--input-padding:0.25rem;--num-columns:8;--outline-size:2px;--border-size:1px;--skintone-border-radius:1rem;--category-font-size:1rem;display:flex;width:min-content;height:400px}:host,:host(.light){color-scheme:light;--background:#fff;--border-color:#e0e0e0;--indicator-color:#385ac1;--input-border-color:#999;--input-font-color:#111;--input-placeholder-color:#999;--outline-color:#999;--category-font-color:#111;--button-active-background:#e6e6e6;--button-hover-background:#d9d9d9}:host(.dark){color-scheme:dark;--background:#222;--border-color:#444;--indicator-color:#5373ec;--input-border-color:#ccc;--input-font-color:#efefef;--input-placeholder-color:#ccc;--outline-color:#fff;--category-font-color:#efefef;--button-active-background:#555555;--button-hover-background:#484848}@media (prefers-color-scheme:dark){:host{color-scheme:dark;--background:#222;--border-color:#444;--indicator-color:#5373ec;--input-border-color:#ccc;--input-font-color:#efefef;--input-placeholder-color:#ccc;--outline-color:#fff;--category-font-color:#efefef;--button-active-background:#555555;--button-hover-background:#484848}}:host([hidden]){display:none}button{margin:0;padding:0;border:0;background:0 0;box-shadow:none;-webkit-tap-highlight-color:transparent}button::-moz-focus-inner{border:0}input{padding:0;margin:0;line-height:1.15;font-family:inherit}input[type=search]{-webkit-appearance:none}:focus{outline:var(--outline-color) solid var(--outline-size);outline-offset:calc(-1*var(--outline-size))}:host([data-js-focus-visible]) :focus:not([data-focus-visible-added]){outline:0}:focus:not(:focus-visible){outline:0}.hide-focus{outline:0}*{box-sizing:border-box}.picker{contain:content;display:flex;flex-direction:column;background:var(--background);border:var(--border-size) solid var(--border-color);width:100%;height:100%;overflow:hidden;--total-emoji-size:calc(var(--emoji-size) + (2 * var(--emoji-padding)));--total-category-emoji-size:calc(var(--category-emoji-size) + (2 * var(--category-emoji-padding)))}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.hidden{opacity:0;pointer-events:none}.abs-pos{position:absolute;left:0;top:0}.gone{display:none!important}.skintone-button-wrapper,.skintone-list{background:var(--background);z-index:3}.skintone-button-wrapper.expanded{z-index:1}.skintone-list{position:absolute;inset-inline-end:0;top:0;z-index:2;overflow:visible;border-bottom:var(--border-size) solid var(--border-color);border-radius:0 0 var(--skintone-border-radius) var(--skintone-border-radius);will-change:transform;transition:transform .2s ease-in-out;transform-origin:center 0}@media (prefers-reduced-motion:reduce){.skintone-list{transition-duration:.001s}}@supports not (inset-inline-end:0){.skintone-list{right:0}}.skintone-list.no-animate{transition:none}.tabpanel{overflow-y:auto;-webkit-overflow-scrolling:touch;will-change:transform;min-height:0;flex:1;contain:content}.emoji-menu{display:grid;grid-template-columns:repeat(var(--num-columns),var(--total-emoji-size));justify-content:space-around;align-items:flex-start;width:100%}.category{padding:var(--emoji-padding);font-size:var(--category-font-size);color:var(--category-font-color)}.custom-emoji,.emoji,button.emoji{height:var(--total-emoji-size);width:var(--total-emoji-size)}.emoji,button.emoji{font-size:var(--emoji-size);display:flex;align-items:center;justify-content:center;border-radius:100%;line-height:1;overflow:hidden;font-family:var(--font-family);cursor:pointer}@media (hover:hover) and (pointer:fine){.emoji:hover,button.emoji:hover{background:var(--button-hover-background)}}.emoji.active,.emoji:active,button.emoji.active,button.emoji:active{background:var(--button-active-background)}.custom-emoji{padding:var(--emoji-padding);object-fit:contain;pointer-events:none;background-repeat:no-repeat;background-position:center center;background-size:var(--emoji-size) var(--emoji-size)}.nav,.nav-button{align-items:center}.nav{display:grid;justify-content:space-between;contain:content}.nav-button{display:flex;justify-content:center}.nav-emoji{font-size:var(--category-emoji-size);width:var(--total-category-emoji-size);height:var(--total-category-emoji-size)}.indicator-wrapper{display:flex;border-bottom:1px solid var(--border-color)}.indicator{width:calc(100%/var(--num-groups));height:var(--indicator-height);opacity:var(--indicator-opacity);background-color:var(--indicator-color);will-change:transform,opacity;transition:opacity .1s linear,transform .25s ease-in-out}@media (prefers-reduced-motion:reduce){.indicator{will-change:opacity;transition:opacity .1s linear}}.pad-top,input.search{background:var(--background);width:100%}.pad-top{height:var(--emoji-padding);z-index:3}.search-row{display:flex;align-items:center;position:relative;padding-inline-start:var(--emoji-padding);padding-bottom:var(--emoji-padding)}.search-wrapper{flex:1;min-width:0}input.search{padding:var(--input-padding);border-radius:var(--input-border-radius);border:var(--input-border-size) solid var(--input-border-color);color:var(--input-font-color);font-size:var(--input-font-size);line-height:var(--input-line-height)}input.search::placeholder{color:var(--input-placeholder-color)}.favorites{display:flex;flex-direction:row;border-top:var(--border-size) solid var(--border-color);contain:content}.message{padding:var(--emoji-padding)}"),
								this.shadowRoot.appendChild(e),
								(this._ctx = {
									locale: "en",
									dataSource:
										"https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json",
									skinToneEmoji: "🖐️",
									customCategorySorting: J,
									customEmoji: null,
									i18n: xt,
									...t,
								});
							for (const t of Dt)
								"database" !== t &&
									Object.prototype.hasOwnProperty.call(this, t) &&
									((this._ctx[t] = this[t]), delete this[t]);
							this._dbFlush();
						}
						connectedCallback() {
							this._cmp = new yt({ target: this.shadowRoot, props: this._ctx });
						}
						disconnectedCallback() {
							this._cmp.$destroy(), (this._cmp = void 0);
							const { database: t } = this._ctx;
							t && t.close().catch((t) => console.error(t));
						}
						static get observedAttributes() {
							return ["locale", "data-source", "skin-tone-emoji"];
						}
						attributeChangedCallback(t, e, n) {
							this._set(
								t.replace(/-([a-z])/g, (t, e) => e.toUpperCase()),
								n,
							);
						}
						_set(t, e) {
							(this._ctx[t] = e),
								this._cmp && this._cmp.$set({ [t]: e }),
								["locale", "dataSource"].includes(t) && this._dbFlush();
						}
						_dbCreate() {
							const { locale: t, dataSource: n, database: o } = this._ctx;
							(o && o.locale === t && o.dataSource === n) ||
								this._set("database", new e.a({ locale: t, dataSource: n }));
						}
						_dbFlush() {
							Promise.resolve().then(() => this._dbCreate());
						}
					}
					const St = {};
					for (const t of Dt)
						St[t] = {
							get() {
								return "database" === t && this._dbCreate(), this._ctx[t];
							},
							set(e) {
								if ("database" === t) throw new Error("database is read-only");
								this._set(t, e);
							},
						};
					Object.defineProperties(Et.prototype, St),
						customElements.get("emoji-picker") ||
							customElements.define("emoji-picker", Et);
				}).call(this, n(13));
			},
			function (t, e, n) {
				"use strict";
				e.a = function () {
					return !1;
				};
			},
			function (t, e) {},
			function (t, e, n) {
				"use strict";
				n.r(e);
				var o = function () {
					return function t() {
						t.called = !0;
					};
				};
				class i {
					constructor(t, e) {
						(this.source = t),
							(this.name = e),
							(this.path = []),
							(this.stop = o()),
							(this.off = o());
					}
				}
				const r = new Array(256)
					.fill("")
					.map((t, e) => ("0" + e.toString(16)).slice(-2));
				function s() {
					const t = (4294967296 * Math.random()) >>> 0,
						e = (4294967296 * Math.random()) >>> 0,
						n = (4294967296 * Math.random()) >>> 0,
						o = (4294967296 * Math.random()) >>> 0;
					return (
						"e" +
						r[(t >> 0) & 255] +
						r[(t >> 8) & 255] +
						r[(t >> 16) & 255] +
						r[(t >> 24) & 255] +
						r[(e >> 0) & 255] +
						r[(e >> 8) & 255] +
						r[(e >> 16) & 255] +
						r[(e >> 24) & 255] +
						r[(n >> 0) & 255] +
						r[(n >> 8) & 255] +
						r[(n >> 16) & 255] +
						r[(n >> 24) & 255] +
						r[(o >> 0) & 255] +
						r[(o >> 8) & 255] +
						r[(o >> 16) & 255] +
						r[(o >> 24) & 255]
					);
				}
				var a = {
					get(t = "normal") {
						return "number" != typeof t ? this[t] || this.normal : t;
					},
					highest: 1e5,
					high: 1e3,
					normal: 0,
					low: -1e3,
					lowest: -1e5,
				};
				function c(t, e) {
					const n = a.get(e.priority);
					for (let o = 0; o < t.length; o++)
						if (a.get(t[o].priority) < n) return void t.splice(o, 0, e);
					t.push(e);
				}
				n(8);
				var l = n(0);
				const d = Symbol("listeningTo"),
					u = Symbol("emitterId"),
					h = Symbol("delegations");
				function p(t) {
					return class extends t {
						on(t, e, n) {
							this.listenTo(this, t, e, n);
						}
						once(t, e, n) {
							let o = !1;
							this.listenTo(
								this,
								t,
								(t, ...n) => {
									o || ((o = !0), t.off(), e.call(this, t, ...n));
								},
								n,
							);
						}
						off(t, e) {
							this.stopListening(this, t, e);
						}
						listenTo(t, e, n, o = {}) {
							let i, r;
							this[d] || (this[d] = {});
							const s = this[d];
							m(t) || f(t);
							const a = m(t);
							(i = s[a]) || (i = s[a] = { emitter: t, callbacks: {} }),
								(r = i.callbacks[e]) || (r = i.callbacks[e] = []),
								r.push(n),
								(function (t, e, n, o, i) {
									e._addEventListener
										? e._addEventListener(n, o, i)
										: t._addEventListener.call(e, n, o, i);
								})(this, t, e, n, o);
						}
						stopListening(t, e, n) {
							const o = this[d];
							let i = t && m(t);
							const r = o && i ? o[i] : void 0,
								s = r && e ? r.callbacks[e] : void 0;
							if (!(!o || (t && !r) || (e && !s)))
								if (n) {
									_(this, t, e, n);
									-1 !== s.indexOf(n) &&
										(1 === s.length ? delete r.callbacks[e] : _(this, t, e, n));
								} else if (s) {
									for (; (n = s.pop()); ) _(this, t, e, n);
									delete r.callbacks[e];
								} else if (r) {
									for (e in r.callbacks) this.stopListening(t, e);
									delete o[i];
								} else {
									for (i in o) this.stopListening(o[i].emitter);
									delete this[d];
								}
						}
						fire(t, ...e) {
							try {
								const n = t instanceof i ? t : new i(this, t),
									o = n.name;
								let r = w(this, o);
								if ((n.path.push(this), r)) {
									const t = [n, ...e];
									r = Array.from(r);
									for (
										let e = 0;
										e < r.length &&
										(r[e].callback.apply(this, t),
										n.off.called &&
											(delete n.off.called,
											this._removeEventListener(o, r[e].callback)),
										!n.stop.called);
										e++
									);
								}
								const s = this[h];
								if (s) {
									const t = s.get(o),
										i = s.get("*");
									t && A(t, n, e), i && A(i, n, e);
								}
								return n.return;
							} catch (t) {
								l.a.rethrowUnexpectedError(t, this);
							}
						}
						delegate(...t) {
							return {
								to: (e, n) => {
									this[h] || (this[h] = new Map()),
										t.forEach((t) => {
											const o = this[h].get(t);
											o ? o.set(e, n) : this[h].set(t, new Map([[e, n]]));
										});
								},
							};
						}
						stopDelegating(t, e) {
							if (this[h])
								if (t)
									if (e) {
										const n = this[h].get(t);
										n && n.delete(e);
									} else this[h].delete(t);
								else this[h].clear();
						}
						_addEventListener(t, e, n) {
							!(function (t, e) {
								const n = k(t);
								if (n[e]) return;
								let o = e,
									i = null;
								const r = [];
								for (; "" !== o && !n[o]; )
									(n[o] = { callbacks: [], childEvents: [] }),
										r.push(n[o]),
										i && n[o].childEvents.push(i),
										(i = o),
										(o = o.substr(0, o.lastIndexOf(":")));
								if ("" !== o) {
									for (const t of r) t.callbacks = n[o].callbacks.slice();
									n[o].childEvents.push(i);
								}
							})(this, t);
							const o = b(this, t),
								i = { callback: e, priority: a.get(n.priority) };
							for (const t of o) c(t, i);
						}
						_removeEventListener(t, e) {
							const n = b(this, t);
							for (const t of n)
								for (let n = 0; n < t.length; n++)
									t[n].callback == e && (t.splice(n, 1), n--);
						}
					};
				}
				const g = p(Object);
				function f(t, e) {
					t[u] || (t[u] = e || s());
				}
				function m(t) {
					return t[u];
				}
				function k(t) {
					return (
						t._events || Object.defineProperty(t, "_events", { value: {} }),
						t._events
					);
				}
				function b(t, e) {
					const n = k(t)[e];
					if (!n) return [];
					let o = [n.callbacks];
					for (let e = 0; e < n.childEvents.length; e++) {
						const i = b(t, n.childEvents[e]);
						o = o.concat(i);
					}
					return o;
				}
				function w(t, e) {
					let n;
					return t._events && (n = t._events[e]) && n.callbacks.length
						? n.callbacks
						: e.indexOf(":") > -1
							? w(t, e.substr(0, e.lastIndexOf(":")))
							: null;
				}
				function A(t, e, n) {
					for (let [o, r] of t) {
						r ? "function" == typeof r && (r = r(e.name)) : (r = e.name);
						const t = new i(e.source, r);
						(t.path = [...e.path]), o.fire(t, ...n);
					}
				}
				function _(t, e, n, o) {
					e._removeEventListener
						? e._removeEventListener(n, o)
						: t._removeEventListener.call(e, n, o);
				}
				[
					"on",
					"once",
					"off",
					"listenTo",
					"stopListening",
					"fire",
					"delegate",
					"stopDelegating",
					"_addEventListener",
					"_removeEventListener",
				].forEach((t) => {
					p[t] = g.prototype[t];
				});
				var C = function (t) {
					var e = typeof t;
					return null != t && ("object" == e || "function" == e);
				};
				const v = Symbol("observableProperties"),
					y = Symbol("boundObservables"),
					x = Symbol("boundProperties"),
					D = Symbol("decoratedMethods"),
					E = Symbol("decoratedOriginal");
				function S(t) {
					return class extends t {
						set(t, e) {
							if (C(t))
								return void Object.keys(t).forEach((e) => {
									this.set(e, t[e]);
								}, this);
							T(this);
							const n = this[v];
							if (t in this && !n.has(t))
								throw new l.a("observable-set-cannot-override", this);
							Object.defineProperty(this, t, {
								enumerable: !0,
								configurable: !0,
								get: () => n.get(t),
								set(e) {
									const o = n.get(t);
									let i = this.fire(`set:${t}`, t, e, o);
									void 0 === i && (i = e),
										(o === i && n.has(t)) ||
											(n.set(t, i), this.fire(`change:${t}`, t, i, o));
								},
							}),
								(this[t] = e);
						}
						bind(...t) {
							if (!t.length || !I(t))
								throw new l.a("observable-bind-wrong-properties", this);
							if (new Set(t).size !== t.length)
								throw new l.a("observable-bind-duplicate-properties", this);
							T(this);
							const e = this[x];
							t.forEach((t) => {
								if (e.has(t)) throw new l.a("observable-bind-rebind", this);
							});
							const n = new Map();
							return (
								t.forEach((t) => {
									const o = { property: t, to: [] };
									e.set(t, o), n.set(t, o);
								}),
								{
									to: P,
									toMany: F,
									_observable: this,
									_bindProperties: t,
									_to: [],
									_bindings: n,
								}
							);
						}
						unbind(...t) {
							if (!this[v]) return;
							const e = this[x],
								n = this[y];
							if (t.length) {
								if (!I(t))
									throw new l.a("observable-unbind-wrong-properties", this);
								t.forEach((t) => {
									const o = e.get(t);
									o &&
										(o.to.forEach(([t, e]) => {
											const i = n.get(t),
												r = i[e];
											r.delete(o),
												r.size || delete i[e],
												Object.keys(i).length ||
													(n.delete(t), this.stopListening(t, "change"));
										}),
										e.delete(t));
								});
							} else
								n.forEach((t, e) => {
									this.stopListening(e, "change");
								}),
									n.clear(),
									e.clear();
						}
						decorate(t) {
							T(this);
							const e = this[t];
							if (!e)
								throw new l.a(
									"observablemixin-cannot-decorate-undefined",
									this,
									{ object: this, methodName: t },
								);
							this.on(t, (t, n) => {
								t.return = e.apply(this, n);
							}),
								(this[t] = function (...e) {
									return this.fire(t, e);
								}),
								(this[t][E] = e),
								this[D] || (this[D] = []),
								this[D].push(t);
						}
						stopListening(t, e, n) {
							if (!t && this[D]) {
								for (const t of this[D]) this[t] = this[t][E];
								delete this[D];
							}
							g.prototype.stopListening.call(this, t, e, n);
						}
					};
				}
				const B = S(g);
				function T(t) {
					t[v] ||
						(Object.defineProperty(t, v, { value: new Map() }),
						Object.defineProperty(t, y, { value: new Map() }),
						Object.defineProperty(t, x, { value: new Map() }));
				}
				function P(...t) {
					const e = (function (...t) {
							if (!t.length)
								throw new l.a("observable-bind-to-parse-error", null);
							const e = { to: [] };
							let n;
							"function" == typeof t[t.length - 1] && (e.callback = t.pop());
							return (
								t.forEach((t) => {
									if ("string" == typeof t) n.properties.push(t);
									else {
										if ("object" != typeof t)
											throw new l.a("observable-bind-to-parse-error", null);
										(n = { observable: t, properties: [] }), e.to.push(n);
									}
								}),
								e
							);
						})(...t),
						n = Array.from(this._bindings.keys()),
						o = n.length;
					if (!e.callback && e.to.length > 1)
						throw new l.a("observable-bind-to-no-callback", this);
					if (o > 1 && e.callback)
						throw new l.a("observable-bind-to-extra-callback", this);
					var i;
					e.to.forEach((t) => {
						if (t.properties.length && t.properties.length !== o)
							throw new l.a("observable-bind-to-properties-length", this);
						t.properties.length || (t.properties = this._bindProperties);
					}),
						(this._to = e.to),
						e.callback && (this._bindings.get(n[0]).callback = e.callback),
						(i = this._observable),
						this._to.forEach((t) => {
							const e = i[y];
							let n;
							e.get(t.observable) ||
								i.listenTo(t.observable, "change", (o, r) => {
									(n = e.get(t.observable)[r]),
										n &&
											n.forEach((t) => {
												z(i, t.property);
											});
								});
						}),
						(function (t) {
							let e;
							t._bindings.forEach((n, o) => {
								t._to.forEach((i) => {
									(e =
										i.properties[
											n.callback ? 0 : t._bindProperties.indexOf(o)
										]),
										n.to.push([i.observable, e]),
										(function (t, e, n, o) {
											const i = t[y],
												r = i.get(n),
												s = r || {};
											s[o] || (s[o] = new Set());
											s[o].add(e), r || i.set(n, s);
										})(t._observable, n, i.observable, e);
								});
							});
						})(this),
						this._bindProperties.forEach((t) => {
							z(this._observable, t);
						});
				}
				function F(t, e, n) {
					if (this._bindings.size > 1)
						throw new l.a("observable-bind-to-many-not-one-binding", this);
					this.to(
						...(function (t, e) {
							const n = t.map((t) => [t, e]);
							return Array.prototype.concat.apply([], n);
						})(t, e),
						n,
					);
				}
				function I(t) {
					return t.every((t) => "string" == typeof t);
				}
				function z(t, e) {
					const n = t[x].get(e);
					let o;
					n.callback
						? (o = n.callback.apply(
								t,
								n.to.map((t) => t[0][t[1]]),
							))
						: ((o = n.to[0]), (o = o[0][o[1]])),
						Object.prototype.hasOwnProperty.call(t, e)
							? (t[e] = o)
							: t.set(e, o);
				}
				[
					"set",
					"bind",
					"unbind",
					"decorate",
					"on",
					"once",
					"off",
					"listenTo",
					"stopListening",
					"fire",
					"delegate",
					"stopDelegating",
					"_addEventListener",
					"_removeEventListener",
				].forEach((t) => {
					S[t] = B.prototype[t];
				});
				class R extends B {
					constructor(t) {
						super(),
							(this.editor = t),
							this.set("isEnabled", !0),
							(this._disableStack = new Set());
					}
					forceDisabled(t) {
						this._disableStack.add(t),
							1 == this._disableStack.size &&
								(this.on("set:isEnabled", O, { priority: "highest" }),
								(this.isEnabled = !1));
					}
					clearForceDisabled(t) {
						this._disableStack.delete(t),
							0 == this._disableStack.size &&
								(this.off("set:isEnabled", O), (this.isEnabled = !0));
					}
					destroy() {
						this.stopListening();
					}
					static get isContextPlugin() {
						return !1;
					}
				}
				function O(t) {
					(t.return = !1), t.stop();
				}
				class M extends B {
					constructor(t) {
						super(),
							(this.editor = t),
							this.set("value", void 0),
							this.set("isEnabled", !1),
							(this._affectsData = !0),
							(this._disableStack = new Set()),
							this.decorate("execute"),
							this.listenTo(this.editor.model.document, "change", () => {
								this.refresh();
							}),
							this.on(
								"execute",
								(t) => {
									this.isEnabled || t.stop();
								},
								{ priority: "high" },
							),
							this.listenTo(t, "change:isReadOnly", (t, e, n) => {
								n && this.affectsData
									? this.forceDisabled("readOnlyMode")
									: this.clearForceDisabled("readOnlyMode");
							});
					}
					get affectsData() {
						return this._affectsData;
					}
					set affectsData(t) {
						this._affectsData = t;
					}
					refresh() {
						this.isEnabled = !0;
					}
					forceDisabled(t) {
						this._disableStack.add(t),
							1 == this._disableStack.size &&
								(this.on("set:isEnabled", N, { priority: "highest" }),
								(this.isEnabled = !1));
					}
					clearForceDisabled(t) {
						this._disableStack.delete(t),
							0 == this._disableStack.size &&
								(this.off("set:isEnabled", N), this.refresh());
					}
					execute(...t) {}
					destroy() {
						this.stopListening();
					}
				}
				function N(t) {
					(t.return = !1), t.stop();
				}
				var V = n(5),
					L = V.a.Symbol,
					j = Object.prototype,
					H = j.hasOwnProperty,
					$ = j.toString,
					q = L ? L.toStringTag : void 0;
				var U = function (t) {
						var e = H.call(t, q),
							n = t[q];
						try {
							t[q] = void 0;
							var o = !0;
						} catch (t) {}
						var i = $.call(t);
						return o && (e ? (t[q] = n) : delete t[q]), i;
					},
					W = Object.prototype.toString;
				var K = function (t) {
						return W.call(t);
					},
					G = L ? L.toStringTag : void 0;
				var J = function (t) {
					return null == t
						? void 0 === t
							? "[object Undefined]"
							: "[object Null]"
						: G && G in Object(t)
							? U(t)
							: K(t);
				};
				var Y = function (t, e) {
						return function (n) {
							return t(e(n));
						};
					},
					Q = Y(Object.getPrototypeOf, Object);
				var X = function (t) {
						return null != t && "object" == typeof t;
					},
					Z = Function.prototype,
					tt = Object.prototype,
					et = Z.toString,
					nt = tt.hasOwnProperty,
					ot = et.call(Object);
				var it = function (t) {
					if (!X(t) || "[object Object]" != J(t)) return !1;
					var e = Q(t);
					if (null === e) return !0;
					var n = nt.call(e, "constructor") && e.constructor;
					return "function" == typeof n && n instanceof n && et.call(n) == ot;
				};
				var rt = function () {
					(this.__data__ = []), (this.size = 0);
				};
				var st = function (t, e) {
					return t === e || (t != t && e != e);
				};
				var at = function (t, e) {
						for (var n = t.length; n--; ) if (st(t[n][0], e)) return n;
						return -1;
					},
					ct = Array.prototype.splice;
				var lt = function (t) {
					var e = this.__data__,
						n = at(e, t);
					return (
						!(n < 0) &&
						(n == e.length - 1 ? e.pop() : ct.call(e, n, 1), --this.size, !0)
					);
				};
				var dt = function (t) {
					var e = this.__data__,
						n = at(e, t);
					return n < 0 ? void 0 : e[n][1];
				};
				var ut = function (t) {
					return at(this.__data__, t) > -1;
				};
				var ht = function (t, e) {
					var n = this.__data__,
						o = at(n, t);
					return o < 0 ? (++this.size, n.push([t, e])) : (n[o][1] = e), this;
				};
				function pt(t) {
					var e = -1,
						n = null == t ? 0 : t.length;
					for (this.clear(); ++e < n; ) {
						var o = t[e];
						this.set(o[0], o[1]);
					}
				}
				(pt.prototype.clear = rt),
					(pt.prototype.delete = lt),
					(pt.prototype.get = dt),
					(pt.prototype.has = ut),
					(pt.prototype.set = ht);
				var gt = pt;
				var ft = function () {
					(this.__data__ = new gt()), (this.size = 0);
				};
				var mt = function (t) {
					var e = this.__data__,
						n = e.delete(t);
					return (this.size = e.size), n;
				};
				var kt = function (t) {
					return this.__data__.get(t);
				};
				var bt = function (t) {
					return this.__data__.has(t);
				};
				var wt,
					At = function (t) {
						if (!C(t)) return !1;
						var e = J(t);
						return (
							"[object Function]" == e ||
							"[object GeneratorFunction]" == e ||
							"[object AsyncFunction]" == e ||
							"[object Proxy]" == e
						);
					},
					_t = V.a["__core-js_shared__"],
					Ct = (wt = /[^.]+$/.exec((_t && _t.keys && _t.keys.IE_PROTO) || ""))
						? "Symbol(src)_1." + wt
						: "";
				var vt = function (t) {
						return !!Ct && Ct in t;
					},
					yt = Function.prototype.toString;
				var xt = function (t) {
						if (null != t) {
							try {
								return yt.call(t);
							} catch (t) {}
							try {
								return t + "";
							} catch (t) {}
						}
						return "";
					},
					Dt = /^\[object .+?Constructor\]$/,
					Et = Function.prototype,
					St = Object.prototype,
					Bt = Et.toString,
					Tt = St.hasOwnProperty,
					Pt = RegExp(
						"^" +
							Bt.call(Tt)
								.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
								.replace(
									/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
									"$1.*?",
								) +
							"$",
					);
				var Ft = function (t) {
					return !(!C(t) || vt(t)) && (At(t) ? Pt : Dt).test(xt(t));
				};
				var It = function (t, e) {
					return null == t ? void 0 : t[e];
				};
				var zt = function (t, e) {
						var n = It(t, e);
						return Ft(n) ? n : void 0;
					},
					Rt = zt(V.a, "Map"),
					Ot = zt(Object, "create");
				var Mt = function () {
					(this.__data__ = Ot ? Ot(null) : {}), (this.size = 0);
				};
				var Nt = function (t) {
						var e = this.has(t) && delete this.__data__[t];
						return (this.size -= e ? 1 : 0), e;
					},
					Vt = Object.prototype.hasOwnProperty;
				var Lt = function (t) {
						var e = this.__data__;
						if (Ot) {
							var n = e[t];
							return "__lodash_hash_undefined__" === n ? void 0 : n;
						}
						return Vt.call(e, t) ? e[t] : void 0;
					},
					jt = Object.prototype.hasOwnProperty;
				var Ht = function (t) {
					var e = this.__data__;
					return Ot ? void 0 !== e[t] : jt.call(e, t);
				};
				var $t = function (t, e) {
					var n = this.__data__;
					return (
						(this.size += this.has(t) ? 0 : 1),
						(n[t] = Ot && void 0 === e ? "__lodash_hash_undefined__" : e),
						this
					);
				};
				function qt(t) {
					var e = -1,
						n = null == t ? 0 : t.length;
					for (this.clear(); ++e < n; ) {
						var o = t[e];
						this.set(o[0], o[1]);
					}
				}
				(qt.prototype.clear = Mt),
					(qt.prototype.delete = Nt),
					(qt.prototype.get = Lt),
					(qt.prototype.has = Ht),
					(qt.prototype.set = $t);
				var Ut = qt;
				var Wt = function () {
					(this.size = 0),
						(this.__data__ = {
							hash: new Ut(),
							map: new (Rt || gt)(),
							string: new Ut(),
						});
				};
				var Kt = function (t) {
					var e = typeof t;
					return "string" == e ||
						"number" == e ||
						"symbol" == e ||
						"boolean" == e
						? "__proto__" !== t
						: null === t;
				};
				var Gt = function (t, e) {
					var n = t.__data__;
					return Kt(e) ? n["string" == typeof e ? "string" : "hash"] : n.map;
				};
				var Jt = function (t) {
					var e = Gt(this, t).delete(t);
					return (this.size -= e ? 1 : 0), e;
				};
				var Yt = function (t) {
					return Gt(this, t).get(t);
				};
				var Qt = function (t) {
					return Gt(this, t).has(t);
				};
				var Xt = function (t, e) {
					var n = Gt(this, t),
						o = n.size;
					return n.set(t, e), (this.size += n.size == o ? 0 : 1), this;
				};
				function Zt(t) {
					var e = -1,
						n = null == t ? 0 : t.length;
					for (this.clear(); ++e < n; ) {
						var o = t[e];
						this.set(o[0], o[1]);
					}
				}
				(Zt.prototype.clear = Wt),
					(Zt.prototype.delete = Jt),
					(Zt.prototype.get = Yt),
					(Zt.prototype.has = Qt),
					(Zt.prototype.set = Xt);
				var te = Zt;
				var ee = function (t, e) {
					var n = this.__data__;
					if (n instanceof gt) {
						var o = n.__data__;
						if (!Rt || o.length < 199)
							return o.push([t, e]), (this.size = ++n.size), this;
						n = this.__data__ = new te(o);
					}
					return n.set(t, e), (this.size = n.size), this;
				};
				function ne(t) {
					var e = (this.__data__ = new gt(t));
					this.size = e.size;
				}
				(ne.prototype.clear = ft),
					(ne.prototype.delete = mt),
					(ne.prototype.get = kt),
					(ne.prototype.has = bt),
					(ne.prototype.set = ee);
				var oe = ne;
				var ie = function (t, e) {
						for (
							var n = -1, o = null == t ? 0 : t.length;
							++n < o && !1 !== e(t[n], n, t);
						);
						return t;
					},
					re = (function () {
						try {
							var t = zt(Object, "defineProperty");
							return t({}, "", {}), t;
						} catch (t) {}
					})();
				var se = function (t, e, n) {
						"__proto__" == e && re
							? re(t, e, {
									configurable: !0,
									enumerable: !0,
									value: n,
									writable: !0,
								})
							: (t[e] = n);
					},
					ae = Object.prototype.hasOwnProperty;
				var ce = function (t, e, n) {
					var o = t[e];
					(ae.call(t, e) && st(o, n) && (void 0 !== n || e in t)) ||
						se(t, e, n);
				};
				var le = function (t, e, n, o) {
					var i = !n;
					n || (n = {});
					for (var r = -1, s = e.length; ++r < s; ) {
						var a = e[r],
							c = o ? o(n[a], t[a], a, n, t) : void 0;
						void 0 === c && (c = t[a]), i ? se(n, a, c) : ce(n, a, c);
					}
					return n;
				};
				var de = function (t, e) {
					for (var n = -1, o = Array(t); ++n < t; ) o[n] = e(n);
					return o;
				};
				var ue = function (t) {
						return X(t) && "[object Arguments]" == J(t);
					},
					he = Object.prototype,
					pe = he.hasOwnProperty,
					ge = he.propertyIsEnumerable,
					fe = ue(
						(function () {
							return arguments;
						})(),
					)
						? ue
						: function (t) {
								return X(t) && pe.call(t, "callee") && !ge.call(t, "callee");
							},
					me = fe,
					ke = Array.isArray,
					be = n(6),
					we = /^(?:0|[1-9]\d*)$/;
				var Ae = function (t, e) {
					var n = typeof t;
					return (
						!!(e = null == e ? 9007199254740991 : e) &&
						("number" == n || ("symbol" != n && we.test(t))) &&
						t > -1 &&
						t % 1 == 0 &&
						t < e
					);
				};
				var _e = function (t) {
						return (
							"number" == typeof t &&
							t > -1 &&
							t % 1 == 0 &&
							t <= 9007199254740991
						);
					},
					Ce = {};
				(Ce["[object Float32Array]"] =
					Ce["[object Float64Array]"] =
					Ce["[object Int8Array]"] =
					Ce["[object Int16Array]"] =
					Ce["[object Int32Array]"] =
					Ce["[object Uint8Array]"] =
					Ce["[object Uint8ClampedArray]"] =
					Ce["[object Uint16Array]"] =
					Ce["[object Uint32Array]"] =
						!0),
					(Ce["[object Arguments]"] =
						Ce["[object Array]"] =
						Ce["[object ArrayBuffer]"] =
						Ce["[object Boolean]"] =
						Ce["[object DataView]"] =
						Ce["[object Date]"] =
						Ce["[object Error]"] =
						Ce["[object Function]"] =
						Ce["[object Map]"] =
						Ce["[object Number]"] =
						Ce["[object Object]"] =
						Ce["[object RegExp]"] =
						Ce["[object Set]"] =
						Ce["[object String]"] =
						Ce["[object WeakMap]"] =
							!1);
				var ve = function (t) {
					return X(t) && _e(t.length) && !!Ce[J(t)];
				};
				var ye = function (t) {
						return function (e) {
							return t(e);
						};
					},
					xe = n(7),
					De = xe.a && xe.a.isTypedArray,
					Ee = De ? ye(De) : ve,
					Se = Object.prototype.hasOwnProperty;
				var Be = function (t, e) {
						var n = ke(t),
							o = !n && me(t),
							i = !n && !o && Object(be.a)(t),
							r = !n && !o && !i && Ee(t),
							s = n || o || i || r,
							a = s ? de(t.length, String) : [],
							c = a.length;
						for (var l in t)
							(!e && !Se.call(t, l)) ||
								(s &&
									("length" == l ||
										(i && ("offset" == l || "parent" == l)) ||
										(r &&
											("buffer" == l ||
												"byteLength" == l ||
												"byteOffset" == l)) ||
										Ae(l, c))) ||
								a.push(l);
						return a;
					},
					Te = Object.prototype;
				var Pe = function (t) {
						var e = t && t.constructor;
						return t === (("function" == typeof e && e.prototype) || Te);
					},
					Fe = Y(Object.keys, Object),
					Ie = Object.prototype.hasOwnProperty;
				var ze = function (t) {
					if (!Pe(t)) return Fe(t);
					var e = [];
					for (var n in Object(t))
						Ie.call(t, n) && "constructor" != n && e.push(n);
					return e;
				};
				var Re = function (t) {
					return null != t && _e(t.length) && !At(t);
				};
				var Oe = function (t) {
					return Re(t) ? Be(t) : ze(t);
				};
				var Me = function (t, e) {
					return t && le(e, Oe(e), t);
				};
				var Ne = function (t) {
						var e = [];
						if (null != t) for (var n in Object(t)) e.push(n);
						return e;
					},
					Ve = Object.prototype.hasOwnProperty;
				var Le = function (t) {
					if (!C(t)) return Ne(t);
					var e = Pe(t),
						n = [];
					for (var o in t)
						("constructor" != o || (!e && Ve.call(t, o))) && n.push(o);
					return n;
				};
				var je = function (t) {
					return Re(t) ? Be(t, !0) : Le(t);
				};
				var He = function (t, e) {
						return t && le(e, je(e), t);
					},
					$e = n(11);
				var qe = function (t, e) {
					var n = -1,
						o = t.length;
					for (e || (e = Array(o)); ++n < o; ) e[n] = t[n];
					return e;
				};
				var Ue = function (t, e) {
					for (
						var n = -1, o = null == t ? 0 : t.length, i = 0, r = [];
						++n < o;
					) {
						var s = t[n];
						e(s, n, t) && (r[i++] = s);
					}
					return r;
				};
				var We = function () {
						return [];
					},
					Ke = Object.prototype.propertyIsEnumerable,
					Ge = Object.getOwnPropertySymbols,
					Je = Ge
						? function (t) {
								return null == t
									? []
									: ((t = Object(t)),
										Ue(Ge(t), function (e) {
											return Ke.call(t, e);
										}));
							}
						: We;
				var Ye = function (t, e) {
					return le(t, Je(t), e);
				};
				var Qe = function (t, e) {
						for (var n = -1, o = e.length, i = t.length; ++n < o; )
							t[i + n] = e[n];
						return t;
					},
					Xe = Object.getOwnPropertySymbols
						? function (t) {
								for (var e = []; t; ) Qe(e, Je(t)), (t = Q(t));
								return e;
							}
						: We;
				var Ze = function (t, e) {
					return le(t, Xe(t), e);
				};
				var tn = function (t, e, n) {
					var o = e(t);
					return ke(t) ? o : Qe(o, n(t));
				};
				var en = function (t) {
					return tn(t, Oe, Je);
				};
				var nn = function (t) {
						return tn(t, je, Xe);
					},
					on = zt(V.a, "DataView"),
					rn = zt(V.a, "Promise"),
					sn = zt(V.a, "Set"),
					an = zt(V.a, "WeakMap"),
					cn = "[object Map]",
					ln = "[object Promise]",
					dn = "[object Set]",
					un = "[object WeakMap]",
					hn = "[object DataView]",
					pn = xt(on),
					gn = xt(Rt),
					fn = xt(rn),
					mn = xt(sn),
					kn = xt(an),
					bn = J;
				((on && bn(new on(new ArrayBuffer(1))) != hn) ||
					(Rt && bn(new Rt()) != cn) ||
					(rn && bn(rn.resolve()) != ln) ||
					(sn && bn(new sn()) != dn) ||
					(an && bn(new an()) != un)) &&
					(bn = function (t) {
						var e = J(t),
							n = "[object Object]" == e ? t.constructor : void 0,
							o = n ? xt(n) : "";
						if (o)
							switch (o) {
								case pn:
									return hn;
								case gn:
									return cn;
								case fn:
									return ln;
								case mn:
									return dn;
								case kn:
									return un;
							}
						return e;
					});
				var wn = bn,
					An = Object.prototype.hasOwnProperty;
				var _n = function (t) {
						var e = t.length,
							n = new t.constructor(e);
						return (
							e &&
								"string" == typeof t[0] &&
								An.call(t, "index") &&
								((n.index = t.index), (n.input = t.input)),
							n
						);
					},
					Cn = V.a.Uint8Array;
				var vn = function (t) {
					var e = new t.constructor(t.byteLength);
					return new Cn(e).set(new Cn(t)), e;
				};
				var yn = function (t, e) {
						var n = e ? vn(t.buffer) : t.buffer;
						return new t.constructor(n, t.byteOffset, t.byteLength);
					},
					xn = /\w*$/;
				var Dn = function (t) {
						var e = new t.constructor(t.source, xn.exec(t));
						return (e.lastIndex = t.lastIndex), e;
					},
					En = L ? L.prototype : void 0,
					Sn = En ? En.valueOf : void 0;
				var Bn = function (t) {
					return Sn ? Object(Sn.call(t)) : {};
				};
				var Tn = function (t, e) {
					var n = e ? vn(t.buffer) : t.buffer;
					return new t.constructor(n, t.byteOffset, t.length);
				};
				var Pn = function (t, e, n) {
						var o = t.constructor;
						switch (e) {
							case "[object ArrayBuffer]":
								return vn(t);
							case "[object Boolean]":
							case "[object Date]":
								return new o(+t);
							case "[object DataView]":
								return yn(t, n);
							case "[object Float32Array]":
							case "[object Float64Array]":
							case "[object Int8Array]":
							case "[object Int16Array]":
							case "[object Int32Array]":
							case "[object Uint8Array]":
							case "[object Uint8ClampedArray]":
							case "[object Uint16Array]":
							case "[object Uint32Array]":
								return Tn(t, n);
							case "[object Map]":
							case "[object Set]":
								return new o();
							case "[object Number]":
							case "[object String]":
								return new o(t);
							case "[object RegExp]":
								return Dn(t);
							case "[object Symbol]":
								return Bn(t);
						}
					},
					Fn = Object.create,
					In = (function () {
						function t() {}
						return function (e) {
							if (!C(e)) return {};
							if (Fn) return Fn(e);
							t.prototype = e;
							var n = new t();
							return (t.prototype = void 0), n;
						};
					})();
				var zn = function (t) {
					return "function" != typeof t.constructor || Pe(t) ? {} : In(Q(t));
				};
				var Rn = function (t) {
						return X(t) && "[object Map]" == wn(t);
					},
					On = xe.a && xe.a.isMap,
					Mn = On ? ye(On) : Rn;
				var Nn = function (t) {
						return X(t) && "[object Set]" == wn(t);
					},
					Vn = xe.a && xe.a.isSet,
					Ln = Vn ? ye(Vn) : Nn,
					jn = "[object Arguments]",
					Hn = "[object Function]",
					$n = "[object Object]",
					qn = {};
				(qn[jn] =
					qn["[object Array]"] =
					qn["[object ArrayBuffer]"] =
					qn["[object DataView]"] =
					qn["[object Boolean]"] =
					qn["[object Date]"] =
					qn["[object Float32Array]"] =
					qn["[object Float64Array]"] =
					qn["[object Int8Array]"] =
					qn["[object Int16Array]"] =
					qn["[object Int32Array]"] =
					qn["[object Map]"] =
					qn["[object Number]"] =
					qn["[object Object]"] =
					qn["[object RegExp]"] =
					qn["[object Set]"] =
					qn["[object String]"] =
					qn["[object Symbol]"] =
					qn["[object Uint8Array]"] =
					qn["[object Uint8ClampedArray]"] =
					qn["[object Uint16Array]"] =
					qn["[object Uint32Array]"] =
						!0),
					(qn["[object Error]"] = qn[Hn] = qn["[object WeakMap]"] = !1);
				var Un = function t(e, n, o, i, r, s) {
					var a,
						c = 1 & n,
						l = 2 & n,
						d = 4 & n;
					if ((o && (a = r ? o(e, i, r, s) : o(e)), void 0 !== a)) return a;
					if (!C(e)) return e;
					var u = ke(e);
					if (u) {
						if (((a = _n(e)), !c)) return qe(e, a);
					} else {
						var h = wn(e),
							p = h == Hn || "[object GeneratorFunction]" == h;
						if (Object(be.a)(e)) return Object($e.a)(e, c);
						if (h == $n || h == jn || (p && !r)) {
							if (((a = l || p ? {} : zn(e)), !c))
								return l ? Ze(e, He(a, e)) : Ye(e, Me(a, e));
						} else {
							if (!qn[h]) return r ? e : {};
							a = Pn(e, h, c);
						}
					}
					s || (s = new oe());
					var g = s.get(e);
					if (g) return g;
					s.set(e, a),
						Ln(e)
							? e.forEach(function (i) {
									a.add(t(i, n, o, i, e, s));
								})
							: Mn(e) &&
								e.forEach(function (i, r) {
									a.set(r, t(i, n, o, r, e, s));
								});
					var f = u ? void 0 : (d ? (l ? nn : en) : l ? je : Oe)(e);
					return (
						ie(f || e, function (i, r) {
							f && (i = e[(r = i)]), ce(a, r, t(i, n, o, r, e, s));
						}),
						a
					);
				};
				var Wn = function (t, e) {
					return Un(t, 5, (e = "function" == typeof e ? e : void 0));
				};
				var Kn = function (t) {
					return X(t) && 1 === t.nodeType && !it(t);
				};
				class Gn {
					constructor(t, e) {
						(this._config = {}),
							e && this.define(Jn(e)),
							t && this._setObjectToTarget(this._config, t);
					}
					set(t, e) {
						this._setToTarget(this._config, t, e);
					}
					define(t, e) {
						this._setToTarget(this._config, t, e, !0);
					}
					get(t) {
						return this._getFromSource(this._config, t);
					}
					*names() {
						for (const t of Object.keys(this._config)) yield t;
					}
					_setToTarget(t, e, n, o = !1) {
						if (it(e)) return void this._setObjectToTarget(t, e, o);
						const i = e.split(".");
						e = i.pop();
						for (const e of i) it(t[e]) || (t[e] = {}), (t = t[e]);
						if (it(n))
							return (
								it(t[e]) || (t[e] = {}),
								(t = t[e]),
								void this._setObjectToTarget(t, n, o)
							);
						(o && void 0 !== t[e]) || (t[e] = n);
					}
					_getFromSource(t, e) {
						const n = e.split(".");
						e = n.pop();
						for (const e of n) {
							if (!it(t[e])) {
								t = null;
								break;
							}
							t = t[e];
						}
						return t ? Jn(t[e]) : void 0;
					}
					_setObjectToTarget(t, e, n) {
						Object.keys(e).forEach((o) => {
							this._setToTarget(t, o, e[o], n);
						});
					}
				}
				function Jn(t) {
					return Wn(t, Yn);
				}
				function Yn(t) {
					return Kn(t) ? t : void 0;
				}
				function Qn(t) {
					return !(!t || !t[Symbol.iterator]);
				}
				class Xn extends g {
					constructor(t = {}, e = {}) {
						super();
						const n = Qn(t);
						if (
							(n || (e = t),
							(this._items = []),
							(this._itemMap = new Map()),
							(this._idProperty = e.idProperty || "id"),
							(this._bindToExternalToInternalMap = new WeakMap()),
							(this._bindToInternalToExternalMap = new WeakMap()),
							(this._skippedIndexesFromExternal = []),
							n)
						)
							for (const e of t)
								this._items.push(e),
									this._itemMap.set(this._getItemIdBeforeAdding(e), e);
					}
					get length() {
						return this._items.length;
					}
					get first() {
						return this._items[0] || null;
					}
					get last() {
						return this._items[this.length - 1] || null;
					}
					add(t, e) {
						return this.addMany([t], e);
					}
					addMany(t, e) {
						if (void 0 === e) e = this._items.length;
						else if (e > this._items.length || e < 0)
							throw new l.a("collection-add-item-invalid-index", this);
						let n = 0;
						for (const o of t) {
							const t = this._getItemIdBeforeAdding(o),
								i = e + n;
							this._items.splice(i, 0, o),
								this._itemMap.set(t, o),
								this.fire("add", o, i),
								n++;
						}
						return (
							this.fire("change", { added: t, removed: [], index: e }), this
						);
					}
					get(t) {
						let e;
						if ("string" == typeof t) e = this._itemMap.get(t);
						else {
							if ("number" != typeof t)
								throw new l.a("collection-get-invalid-arg", this);
							e = this._items[t];
						}
						return e || null;
					}
					has(t) {
						if ("string" == typeof t) return this._itemMap.has(t);
						{
							const e = t[this._idProperty];
							return e && this._itemMap.has(e);
						}
					}
					getIndex(t) {
						let e;
						return (
							(e = "string" == typeof t ? this._itemMap.get(t) : t),
							e ? this._items.indexOf(e) : -1
						);
					}
					remove(t) {
						const [e, n] = this._remove(t);
						return (
							this.fire("change", { added: [], removed: [e], index: n }), e
						);
					}
					map(t, e) {
						return this._items.map(t, e);
					}
					find(t, e) {
						return this._items.find(t, e);
					}
					filter(t, e) {
						return this._items.filter(t, e);
					}
					clear() {
						this._bindToCollection &&
							(this.stopListening(this._bindToCollection),
							(this._bindToCollection = null));
						const t = Array.from(this._items);
						for (; this.length; ) this._remove(0);
						this.fire("change", { added: [], removed: t, index: 0 });
					}
					bindTo(t) {
						if (this._bindToCollection)
							throw new l.a("collection-bind-to-rebind", this);
						return (
							(this._bindToCollection = t),
							{
								as: (t) => {
									this._setUpBindToBinding((e) => new t(e));
								},
								using: (t) => {
									"function" == typeof t
										? this._setUpBindToBinding(t)
										: this._setUpBindToBinding((e) => e[t]);
								},
							}
						);
					}
					_setUpBindToBinding(t) {
						const e = this._bindToCollection,
							n = (n, o, i) => {
								const r = e._bindToCollection == this,
									s = e._bindToInternalToExternalMap.get(o);
								if (r && s)
									this._bindToExternalToInternalMap.set(o, s),
										this._bindToInternalToExternalMap.set(s, o);
								else {
									const n = t(o);
									if (!n) return void this._skippedIndexesFromExternal.push(i);
									let r = i;
									for (const t of this._skippedIndexesFromExternal)
										i > t && r--;
									for (const t of e._skippedIndexesFromExternal) r >= t && r++;
									this._bindToExternalToInternalMap.set(o, n),
										this._bindToInternalToExternalMap.set(n, o),
										this.add(n, r);
									for (let t = 0; t < e._skippedIndexesFromExternal.length; t++)
										r <= e._skippedIndexesFromExternal[t] &&
											e._skippedIndexesFromExternal[t]++;
								}
							};
						for (const t of e) n(0, t, e.getIndex(t));
						this.listenTo(e, "add", n),
							this.listenTo(e, "remove", (t, e, n) => {
								const o = this._bindToExternalToInternalMap.get(e);
								o && this.remove(o),
									(this._skippedIndexesFromExternal =
										this._skippedIndexesFromExternal.reduce(
											(t, e) => (n < e && t.push(e - 1), n > e && t.push(e), t),
											[],
										));
							});
					}
					_getItemIdBeforeAdding(t) {
						const e = this._idProperty;
						let n;
						if (e in t) {
							if (((n = t[e]), "string" != typeof n))
								throw new l.a("collection-add-invalid-id", this);
							if (this.get(n))
								throw new l.a("collection-add-item-already-exists", this);
						} else t[e] = n = s();
						return n;
					}
					_remove(t) {
						let e,
							n,
							o,
							i = !1;
						const r = this._idProperty;
						if (
							("string" == typeof t
								? ((n = t),
									(o = this._itemMap.get(n)),
									(i = !o),
									o && (e = this._items.indexOf(o)))
								: "number" == typeof t
									? ((e = t), (o = this._items[e]), (i = !o), o && (n = o[r]))
									: ((o = t),
										(n = o[r]),
										(e = this._items.indexOf(o)),
										(i = -1 == e || !this._itemMap.get(n))),
							i)
						)
							throw new l.a("collection-remove-404", this);
						this._items.splice(e, 1), this._itemMap.delete(n);
						const s = this._bindToInternalToExternalMap.get(o);
						return (
							this._bindToInternalToExternalMap.delete(o),
							this._bindToExternalToInternalMap.delete(s),
							this.fire("remove", o, e),
							[o, e]
						);
					}
					[Symbol.iterator]() {
						return this._items[Symbol.iterator]();
					}
				}
				class Zn extends g {
					constructor(t, e = [], n = []) {
						super(),
							(this._context = t),
							(this._plugins = new Map()),
							(this._availablePlugins = new Map());
						for (const t of e)
							t.pluginName && this._availablePlugins.set(t.pluginName, t);
						this._contextPlugins = new Map();
						for (const [t, e] of n)
							this._contextPlugins.set(t, e),
								this._contextPlugins.set(e, t),
								t.pluginName && this._availablePlugins.set(t.pluginName, t);
					}
					*[Symbol.iterator]() {
						for (const t of this._plugins)
							"function" == typeof t[0] && (yield t);
					}
					get(t) {
						const e = this._plugins.get(t);
						if (!e) {
							let e = t;
							throw (
								("function" == typeof t && (e = t.pluginName || t.name),
								new l.a("plugincollection-plugin-not-loaded", this._context, {
									plugin: e,
								}))
							);
						}
						return e;
					}
					has(t) {
						return this._plugins.has(t);
					}
					init(t, e = [], n = []) {
						const o = this,
							i = this._context;
						!(function t(e, n = new Set()) {
							e.forEach((e) => {
								a(e) &&
									(n.has(e) ||
										(n.add(e),
										e.pluginName &&
											!o._availablePlugins.has(e.pluginName) &&
											o._availablePlugins.set(e.pluginName, e),
										e.requires && t(e.requires, n)));
							});
						})(t),
							h(t);
						const r = [
							...(function t(e, n = new Set()) {
								return e
									.map((t) => (a(t) ? t : o._availablePlugins.get(t)))
									.reduce(
										(e, o) =>
											n.has(o)
												? e
												: (n.add(o),
													o.requires &&
														(h(o.requires, o),
														t(o.requires, n).forEach((t) => e.add(t))),
													e.add(o)),
										new Set(),
									);
							})(t.filter((t) => !d(t, e))),
						];
						!(function (t, e) {
							for (const n of e) {
								if ("function" != typeof n)
									throw new l.a(
										"plugincollection-replace-plugin-invalid-type",
										null,
										{ pluginItem: n },
									);
								const e = n.pluginName;
								if (!e)
									throw new l.a(
										"plugincollection-replace-plugin-missing-name",
										null,
										{ pluginItem: n },
									);
								if (n.requires && n.requires.length)
									throw new l.a(
										"plugincollection-plugin-for-replacing-cannot-have-dependencies",
										null,
										{ pluginName: e },
									);
								const i = o._availablePlugins.get(e);
								if (!i)
									throw new l.a(
										"plugincollection-plugin-for-replacing-not-exist",
										null,
										{ pluginName: e },
									);
								const r = t.indexOf(i);
								if (-1 === r) {
									if (o._contextPlugins.has(i)) return;
									throw new l.a(
										"plugincollection-plugin-for-replacing-not-loaded",
										null,
										{ pluginName: e },
									);
								}
								if (i.requires && i.requires.length)
									throw new l.a(
										"plugincollection-replaced-plugin-cannot-have-dependencies",
										null,
										{ pluginName: e },
									);
								t.splice(r, 1, n), o._availablePlugins.set(e, n);
							}
						})(r, n);
						const s = (function (t) {
							return t.map((t) => {
								let e = o._contextPlugins.get(t);
								return (e = e || new t(i)), o._add(t, e), e;
							});
						})(r);
						return p(s, "init")
							.then(() => p(s, "afterInit"))
							.then(() => s);
						function a(t) {
							return "function" == typeof t;
						}
						function c(t) {
							return a(t) && t.isContextPlugin;
						}
						function d(t, e) {
							return e.some((e) => e === t || u(t) === e || u(e) === t);
						}
						function u(t) {
							return a(t) ? t.pluginName || t.name : t;
						}
						function h(t, n = null) {
							t.map((t) =>
								a(t) ? t : o._availablePlugins.get(t) || t,
							).forEach((t) => {
								!(function (t, e) {
									if (a(t)) return;
									if (e)
										throw new l.a("plugincollection-soft-required", i, {
											missingPlugin: t,
											requiredBy: u(e),
										});
									throw new l.a("plugincollection-plugin-not-found", i, {
										plugin: t,
									});
								})(t, n),
									(function (t, e) {
										if (!c(e)) return;
										if (c(t)) return;
										throw new l.a("plugincollection-context-required", i, {
											plugin: u(t),
											requiredBy: u(e),
										});
									})(t, n),
									(function (t, n) {
										if (!n) return;
										if (!d(t, e)) return;
										throw new l.a("plugincollection-required", i, {
											plugin: u(t),
											requiredBy: u(n),
										});
									})(t, n);
							});
						}
						function p(t, e) {
							return t.reduce(
								(t, n) =>
									n[e]
										? o._contextPlugins.has(n)
											? t
											: t.then(n[e].bind(n))
										: t,
								Promise.resolve(),
							);
						}
					}
					destroy() {
						const t = [];
						for (const [, e] of this)
							"function" != typeof e.destroy ||
								this._contextPlugins.has(e) ||
								t.push(e.destroy());
						return Promise.all(t);
					}
					_add(t, e) {
						this._plugins.set(t, e);
						const n = t.pluginName;
						if (n) {
							if (this._plugins.has(n))
								throw new l.a("plugincollection-plugin-name-conflict", null, {
									pluginName: n,
									plugin1: this._plugins.get(n).constructor,
									plugin2: t,
								});
							this._plugins.set(n, e);
						}
					}
				}
				function to(t) {
					return Array.isArray(t) ? t : [t];
				}
				let eo;
				try {
					eo = { window: window, document: document };
				} catch (t) {
					eo = { window: {}, document: {} };
				}
				var no = eo;
				function oo(t, e, n = 1) {
					if ("number" != typeof n)
						throw new l.a("translation-service-quantity-not-a-number", null, {
							quantity: n,
						});
					const o = Object.keys(no.window.CKEDITOR_TRANSLATIONS).length;
					1 === o && (t = Object.keys(no.window.CKEDITOR_TRANSLATIONS)[0]);
					const i = e.id || e.string;
					if (
						0 === o ||
						!(function (t, e) {
							return (
								!!no.window.CKEDITOR_TRANSLATIONS[t] &&
								!!no.window.CKEDITOR_TRANSLATIONS[t].dictionary[e]
							);
						})(t, i)
					)
						return 1 !== n ? e.plural : e.string;
					const r = no.window.CKEDITOR_TRANSLATIONS[t].dictionary,
						s =
							no.window.CKEDITOR_TRANSLATIONS[t].getPluralForm ||
							((t) => (1 === t ? 0 : 1)),
						a = r[i];
					if ("string" == typeof a) return a;
					return a[Number(s(n))];
				}
				no.window.CKEDITOR_TRANSLATIONS ||
					(no.window.CKEDITOR_TRANSLATIONS = {});
				const io = [
					"ar",
					"ara",
					"fa",
					"per",
					"fas",
					"he",
					"heb",
					"ku",
					"kur",
					"ug",
					"uig",
				];
				function ro(t) {
					return io.includes(t) ? "rtl" : "ltr";
				}
				class so {
					constructor(t = {}) {
						(this.uiLanguage = t.uiLanguage || "en"),
							(this.contentLanguage = t.contentLanguage || this.uiLanguage),
							(this.uiLanguageDirection = ro(this.uiLanguage)),
							(this.contentLanguageDirection = ro(this.contentLanguage)),
							(this.t = (t, e) => this._t(t, e));
					}
					get language() {
						return (
							console.warn(
								"locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead.",
							),
							this.uiLanguage
						);
					}
					_t(t, e = []) {
						(e = to(e)), "string" == typeof t && (t = { string: t });
						const n = !!t.plural ? e[0] : 1;
						return (function (t, e) {
							return t.replace(/%(\d+)/g, (t, n) => (n < e.length ? e[n] : t));
						})(oo(this.uiLanguage, t, n), e);
					}
				}
				class ao {
					constructor(t) {
						this.config = new Gn(t, this.constructor.defaultConfig);
						const e = this.constructor.builtinPlugins;
						this.config.define("plugins", e), (this.plugins = new Zn(this, e));
						const n = this.config.get("language") || {};
						(this.locale = new so({
							uiLanguage: "string" == typeof n ? n : n.ui,
							contentLanguage: this.config.get("language.content"),
						})),
							(this.t = this.locale.t),
							(this.editors = new Xn()),
							(this._contextOwner = null);
					}
					initPlugins() {
						const t = this.config.get("plugins") || [],
							e = this.config.get("substitutePlugins") || [];
						for (const n of t.concat(e)) {
							if ("function" != typeof n)
								throw new l.a("context-initplugins-constructor-only", null, {
									Plugin: n,
								});
							if (!0 !== n.isContextPlugin)
								throw new l.a("context-initplugins-invalid-plugin", null, {
									Plugin: n,
								});
						}
						return this.plugins.init(t, [], e);
					}
					destroy() {
						return Promise.all(
							Array.from(this.editors, (t) => t.destroy()),
						).then(() => this.plugins.destroy());
					}
					_addEditor(t, e) {
						if (this._contextOwner)
							throw new l.a("context-addeditor-private-context");
						this.editors.add(t), e && (this._contextOwner = t);
					}
					_removeEditor(t) {
						return (
							this.editors.has(t) && this.editors.remove(t),
							this._contextOwner === t ? this.destroy() : Promise.resolve()
						);
					}
					_getEditorConfig() {
						const t = {};
						for (const e of this.config.names())
							["plugins", "removePlugins", "extraPlugins"].includes(e) ||
								(t[e] = this.config.get(e));
						return t;
					}
					static create(t) {
						return new Promise((e) => {
							const n = new this(t);
							e(n.initPlugins().then(() => n));
						});
					}
				}
				class co extends B {
					constructor(t) {
						super(), (this.context = t);
					}
					destroy() {
						this.stopListening();
					}
					static get isContextPlugin() {
						return !0;
					}
				}
				class lo {
					is() {
						throw new Error("is() method is abstract");
					}
				}
				function uo(t, e) {
					const n = Math.min(t.length, e.length);
					for (let o = 0; o < n; o++) if (t[o] != e[o]) return o;
					return t.length == e.length
						? "same"
						: t.length < e.length
							? "prefix"
							: "extension";
				}
				var ho = function (t) {
					return Un(t, 4);
				};
				class po extends p(lo) {
					constructor(t) {
						super(), (this.document = t), (this.parent = null);
					}
					get index() {
						let t;
						if (!this.parent) return null;
						if (-1 == (t = this.parent.getChildIndex(this)))
							throw new l.a("view-node-not-found-in-parent", this);
						return t;
					}
					get nextSibling() {
						const t = this.index;
						return (null !== t && this.parent.getChild(t + 1)) || null;
					}
					get previousSibling() {
						const t = this.index;
						return (null !== t && this.parent.getChild(t - 1)) || null;
					}
					get root() {
						let t = this;
						for (; t.parent; ) t = t.parent;
						return t;
					}
					isAttached() {
						return this.root.is("rootElement");
					}
					getPath() {
						const t = [];
						let e = this;
						for (; e.parent; ) t.unshift(e.index), (e = e.parent);
						return t;
					}
					getAncestors(t = {}) {
						const e = [];
						let n = t.includeSelf ? this : this.parent;
						for (; n; )
							e[t.parentFirst ? "push" : "unshift"](n), (n = n.parent);
						return e;
					}
					getCommonAncestor(t, e = {}) {
						const n = this.getAncestors(e),
							o = t.getAncestors(e);
						let i = 0;
						for (; n[i] == o[i] && n[i]; ) i++;
						return 0 === i ? null : n[i - 1];
					}
					isBefore(t) {
						if (this == t) return !1;
						if (this.root !== t.root) return !1;
						const e = this.getPath(),
							n = t.getPath(),
							o = uo(e, n);
						switch (o) {
							case "prefix":
								return !0;
							case "extension":
								return !1;
							default:
								return e[o] < n[o];
						}
					}
					isAfter(t) {
						return this != t && this.root === t.root && !this.isBefore(t);
					}
					_remove() {
						this.parent._removeChildren(this.index);
					}
					_fireChange(t, e) {
						this.fire(`change:${t}`, e),
							this.parent && this.parent._fireChange(t, e);
					}
					toJSON() {
						const t = ho(this);
						return delete t.parent, t;
					}
				}
				po.prototype.is = function (t) {
					return "node" === t || "view:node" === t;
				};
				class go extends po {
					constructor(t, e) {
						super(t), (this._textData = e);
					}
					get data() {
						return this._textData;
					}
					get _data() {
						return this.data;
					}
					set _data(t) {
						this._fireChange("text", this), (this._textData = t);
					}
					isSimilar(t) {
						return t instanceof go && (this === t || this.data === t.data);
					}
					_clone() {
						return new go(this.document, this.data);
					}
				}
				go.prototype.is = function (t) {
					return (
						"$text" === t ||
						"view:$text" === t ||
						"text" === t ||
						"view:text" === t ||
						"node" === t ||
						"view:node" === t
					);
				};
				class fo extends lo {
					constructor(t, e, n) {
						if ((super(), (this.textNode = t), e < 0 || e > t.data.length))
							throw new l.a("view-textproxy-wrong-offsetintext", this);
						if (n < 0 || e + n > t.data.length)
							throw new l.a("view-textproxy-wrong-length", this);
						(this.data = t.data.substring(e, e + n)), (this.offsetInText = e);
					}
					get offsetSize() {
						return this.data.length;
					}
					get isPartial() {
						return this.data.length !== this.textNode.data.length;
					}
					get parent() {
						return this.textNode.parent;
					}
					get root() {
						return this.textNode.root;
					}
					get document() {
						return this.textNode.document;
					}
					getAncestors(t = {}) {
						const e = [];
						let n = t.includeSelf ? this.textNode : this.parent;
						for (; null !== n; )
							e[t.parentFirst ? "push" : "unshift"](n), (n = n.parent);
						return e;
					}
				}
				function mo(t) {
					return Qn(t)
						? new Map(t)
						: (function (t) {
								const e = new Map();
								for (const n in t) e.set(n, t[n]);
								return e;
							})(t);
				}
				fo.prototype.is = function (t) {
					return (
						"$textProxy" === t ||
						"view:$textProxy" === t ||
						"textProxy" === t ||
						"view:textProxy" === t
					);
				};
				class ko {
					constructor(...t) {
						(this._patterns = []), this.add(...t);
					}
					add(...t) {
						for (let e of t)
							("string" == typeof e || e instanceof RegExp) &&
								(e = { name: e }),
								this._patterns.push(e);
					}
					match(...t) {
						for (const e of t)
							for (const t of this._patterns) {
								const n = bo(e, t);
								if (n) return { element: e, pattern: t, match: n };
							}
						return null;
					}
					matchAll(...t) {
						const e = [];
						for (const n of t)
							for (const t of this._patterns) {
								const o = bo(n, t);
								o && e.push({ element: n, pattern: t, match: o });
							}
						return e.length > 0 ? e : null;
					}
					getElementName() {
						if (1 !== this._patterns.length) return null;
						const t = this._patterns[0],
							e = t.name;
						return "function" == typeof t || !e || e instanceof RegExp
							? null
							: e;
					}
				}
				function bo(t, e) {
					if ("function" == typeof e) return e(t);
					const n = {};
					return (e.name &&
						((n.name = (function (t, e) {
							if (t instanceof RegExp) return !!e.match(t);
							return t === e;
						})(e.name, t.name)),
						!n.name)) ||
						(e.attributes &&
							((n.attributes = (function (t, e) {
								const n = new Set(e.getAttributeKeys());
								it(t)
									? (void 0 !== t.style &&
											Object(l.b)(
												"matcher-pattern-deprecated-attributes-style-key",
												t,
											),
										void 0 !== t.class &&
											Object(l.b)(
												"matcher-pattern-deprecated-attributes-class-key",
												t,
											))
									: (n.delete("style"), n.delete("class"));
								return wo(t, n, (t) => e.getAttribute(t));
							})(e.attributes, t)),
							!n.attributes)) ||
						(e.classes &&
							((n.classes = (function (t, e) {
								return wo(t, e.getClassNames(), () => {});
							})(e.classes, t)),
							!n.classes)) ||
						(e.styles &&
							((n.styles = (function (t, e) {
								return wo(t, e.getStyleNames(!0), (t) => e.getStyle(t));
							})(e.styles, t)),
							!n.styles))
						? null
						: n;
				}
				function wo(t, e, n) {
					const o = (function (t) {
							if (Array.isArray(t))
								return t.map((t) =>
									it(t)
										? ((void 0 !== t.key && void 0 !== t.value) ||
												Object(l.b)("matcher-pattern-missing-key-or-value", t),
											[t.key, t.value])
										: [t, !0],
								);
							if (it(t)) return Object.entries(t);
							return [[t, !0]];
						})(t),
						i = Array.from(e),
						r = [];
					if (
						(o.forEach(([t, e]) => {
							i.forEach((o) => {
								(function (t, e) {
									return (
										!0 === t || t === e || (t instanceof RegExp && e.match(t))
									);
								})(t, o) &&
									(function (t, e, n) {
										if (!0 === t) return !0;
										const o = n(e);
										return (
											t === o || (t instanceof RegExp && !!String(o).match(t))
										);
									})(e, o, n) &&
									r.push(o);
							});
						}),
						o.length && !(r.length < o.length))
					)
						return r;
				}
				var Ao = function (t) {
						return "symbol" == typeof t || (X(t) && "[object Symbol]" == J(t));
					},
					_o = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
					Co = /^\w*$/;
				var vo = function (t, e) {
					if (ke(t)) return !1;
					var n = typeof t;
					return (
						!(
							"number" != n &&
							"symbol" != n &&
							"boolean" != n &&
							null != t &&
							!Ao(t)
						) ||
						Co.test(t) || !_o.test(t) ||
						(null != e && t in Object(e))
					);
				};
				function yo(t, e) {
					if ("function" != typeof t || (null != e && "function" != typeof e))
						throw new TypeError("Expected a function");
					var n = function () {
						var o = arguments,
							i = e ? e.apply(this, o) : o[0],
							r = n.cache;
						if (r.has(i)) return r.get(i);
						var s = t.apply(this, o);
						return (n.cache = r.set(i, s) || r), s;
					};
					return (n.cache = new (yo.Cache || te)()), n;
				}
				yo.Cache = te;
				var xo = yo;
				var Do =
						/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
					Eo = /\\(\\)?/g,
					So = (function (t) {
						var e = xo(t, function (t) {
								return 500 === n.size && n.clear(), t;
							}),
							n = e.cache;
						return e;
					})(function (t) {
						var e = [];
						return (
							46 === t.charCodeAt(0) && e.push(""),
							t.replace(Do, function (t, n, o, i) {
								e.push(o ? i.replace(Eo, "$1") : n || t);
							}),
							e
						);
					}),
					Bo = So;
				var To = function (t, e) {
						for (
							var n = -1, o = null == t ? 0 : t.length, i = Array(o);
							++n < o;
						)
							i[n] = e(t[n], n, t);
						return i;
					},
					Po = L ? L.prototype : void 0,
					Fo = Po ? Po.toString : void 0;
				var Io = function t(e) {
					if ("string" == typeof e) return e;
					if (ke(e)) return To(e, t) + "";
					if (Ao(e)) return Fo ? Fo.call(e) : "";
					var n = e + "";
					return "0" == n && 1 / e == -Infinity ? "-0" : n;
				};
				var zo = function (t) {
					return null == t ? "" : Io(t);
				};
				var Ro = function (t, e) {
					return ke(t) ? t : vo(t, e) ? [t] : Bo(zo(t));
				};
				var Oo = function (t) {
					var e = null == t ? 0 : t.length;
					return e ? t[e - 1] : void 0;
				};
				var Mo = function (t) {
					if ("string" == typeof t || Ao(t)) return t;
					var e = t + "";
					return "0" == e && 1 / t == -Infinity ? "-0" : e;
				};
				var No = function (t, e) {
					for (var n = 0, o = (e = Ro(e, t)).length; null != t && n < o; )
						t = t[Mo(e[n++])];
					return n && n == o ? t : void 0;
				};
				var Vo = function (t, e, n) {
					var o = -1,
						i = t.length;
					e < 0 && (e = -e > i ? 0 : i + e),
						(n = n > i ? i : n) < 0 && (n += i),
						(i = e > n ? 0 : (n - e) >>> 0),
						(e >>>= 0);
					for (var r = Array(i); ++o < i; ) r[o] = t[o + e];
					return r;
				};
				var Lo = function (t, e) {
					return e.length < 2 ? t : No(t, Vo(e, 0, -1));
				};
				var jo = function (t, e) {
					return (e = Ro(e, t)), null == (t = Lo(t, e)) || delete t[Mo(Oo(e))];
				};
				var Ho = function (t, e) {
					return null == t || jo(t, e);
				};
				var $o = function (t, e, n) {
					var o = null == t ? void 0 : No(t, e);
					return void 0 === o ? n : o;
				};
				var qo = function (t, e, n) {
					((void 0 !== n && !st(t[e], n)) || (void 0 === n && !(e in t))) &&
						se(t, e, n);
				};
				var Uo = (function (t) {
					return function (e, n, o) {
						for (var i = -1, r = Object(e), s = o(e), a = s.length; a--; ) {
							var c = s[t ? a : ++i];
							if (!1 === n(r[c], c, r)) break;
						}
						return e;
					};
				})();
				var Wo = function (t) {
					return X(t) && Re(t);
				};
				var Ko = function (t, e) {
					if (
						("constructor" !== e || "function" != typeof t[e]) &&
						"__proto__" != e
					)
						return t[e];
				};
				var Go = function (t) {
					return le(t, je(t));
				};
				var Jo = function (t, e, n, o, i, r, s) {
					var a = Ko(t, n),
						c = Ko(e, n),
						l = s.get(c);
					if (l) qo(t, n, l);
					else {
						var d = r ? r(a, c, n + "", t, e, s) : void 0,
							u = void 0 === d;
						if (u) {
							var h = ke(c),
								p = !h && Object(be.a)(c),
								g = !h && !p && Ee(c);
							(d = c),
								h || p || g
									? ke(a)
										? (d = a)
										: Wo(a)
											? (d = qe(a))
											: p
												? ((u = !1), (d = Object($e.a)(c, !0)))
												: g
													? ((u = !1), (d = Tn(c, !0)))
													: (d = [])
									: it(c) || me(c)
										? ((d = a),
											me(a) ? (d = Go(a)) : (C(a) && !At(a)) || (d = zn(c)))
										: (u = !1);
						}
						u && (s.set(c, d), i(d, c, o, r, s), s.delete(c)), qo(t, n, d);
					}
				};
				var Yo = function t(e, n, o, i, r) {
					e !== n &&
						Uo(
							n,
							function (s, a) {
								if ((r || (r = new oe()), C(s))) Jo(e, n, a, o, t, i, r);
								else {
									var c = i ? i(Ko(e, a), s, a + "", e, n, r) : void 0;
									void 0 === c && (c = s), qo(e, a, c);
								}
							},
							je,
						);
				};
				var Qo = function (t) {
					return t;
				};
				var Xo = function (t, e, n) {
						switch (n.length) {
							case 0:
								return t.call(e);
							case 1:
								return t.call(e, n[0]);
							case 2:
								return t.call(e, n[0], n[1]);
							case 3:
								return t.call(e, n[0], n[1], n[2]);
						}
						return t.apply(e, n);
					},
					Zo = Math.max;
				var ti = function (t, e, n) {
					return (
						(e = Zo(void 0 === e ? t.length - 1 : e, 0)),
						function () {
							for (
								var o = arguments,
									i = -1,
									r = Zo(o.length - e, 0),
									s = Array(r);
								++i < r;
							)
								s[i] = o[e + i];
							i = -1;
							for (var a = Array(e + 1); ++i < e; ) a[i] = o[i];
							return (a[e] = n(s)), Xo(t, this, a);
						}
					);
				};
				var ei = function (t) {
						return function () {
							return t;
						};
					},
					ni = re
						? function (t, e) {
								return re(t, "toString", {
									configurable: !0,
									enumerable: !1,
									value: ei(e),
									writable: !0,
								});
							}
						: Qo,
					oi = Date.now;
				var ii = function (t) {
						var e = 0,
							n = 0;
						return function () {
							var o = oi(),
								i = 16 - (o - n);
							if (((n = o), i > 0)) {
								if (++e >= 800) return arguments[0];
							} else e = 0;
							return t.apply(void 0, arguments);
						};
					},
					ri = ii(ni);
				var si = function (t, e) {
					return ri(ti(t, e, Qo), t + "");
				};
				var ai = function (t, e, n) {
					if (!C(n)) return !1;
					var o = typeof e;
					return (
						!!("number" == o
							? Re(n) && Ae(e, n.length)
							: "string" == o && e in n) && st(n[e], t)
					);
				};
				var ci = function (t) {
						return si(function (e, n) {
							var o = -1,
								i = n.length,
								r = i > 1 ? n[i - 1] : void 0,
								s = i > 2 ? n[2] : void 0;
							for (
								r = t.length > 3 && "function" == typeof r ? (i--, r) : void 0,
									s && ai(n[0], n[1], s) && ((r = i < 3 ? void 0 : r), (i = 1)),
									e = Object(e);
								++o < i;
							) {
								var a = n[o];
								a && t(e, a, o, r);
							}
							return e;
						});
					},
					li = ci(function (t, e, n) {
						Yo(t, e, n);
					});
				var di = function (t, e, n, o) {
					if (!C(t)) return t;
					for (
						var i = -1, r = (e = Ro(e, t)).length, s = r - 1, a = t;
						null != a && ++i < r;
					) {
						var c = Mo(e[i]),
							l = n;
						if ("__proto__" === c || "constructor" === c || "prototype" === c)
							return t;
						if (i != s) {
							var d = a[c];
							void 0 === (l = o ? o(d, c, a) : void 0) &&
								(l = C(d) ? d : Ae(e[i + 1]) ? [] : {});
						}
						ce(a, c, l), (a = a[c]);
					}
					return t;
				};
				var ui = function (t, e, n) {
					return null == t ? t : di(t, e, n);
				};
				class hi {
					constructor(t) {
						(this._styles = {}), (this._styleProcessor = t);
					}
					get isEmpty() {
						const t = Object.entries(this._styles);
						return !Array.from(t).length;
					}
					get size() {
						return this.isEmpty ? 0 : this.getStyleNames().length;
					}
					setTo(t) {
						this.clear();
						const e = Array.from(
							(function (t) {
								let e = null,
									n = 0,
									o = 0,
									i = null;
								const r = new Map();
								if ("" === t) return r;
								";" != t.charAt(t.length - 1) && (t += ";");
								for (let s = 0; s < t.length; s++) {
									const a = t.charAt(s);
									if (null === e)
										switch (a) {
											case ":":
												i || ((i = t.substr(n, s - n)), (o = s + 1));
												break;
											case '"':
											case "'":
												e = a;
												break;
											case ";": {
												const e = t.substr(o, s - o);
												i && r.set(i.trim(), e.trim()), (i = null), (n = s + 1);
												break;
											}
										}
									else a === e && (e = null);
								}
								return r;
							})(t).entries(),
						);
						for (const [t, n] of e)
							this._styleProcessor.toNormalizedForm(t, n, this._styles);
					}
					has(t) {
						if (this.isEmpty) return !1;
						const e = this._styleProcessor
							.getReducedForm(t, this._styles)
							.find(([e]) => e === t);
						return Array.isArray(e);
					}
					set(t, e) {
						if (C(t))
							for (const [e, n] of Object.entries(t))
								this._styleProcessor.toNormalizedForm(e, n, this._styles);
						else this._styleProcessor.toNormalizedForm(t, e, this._styles);
					}
					remove(t) {
						const e = gi(t);
						Ho(this._styles, e),
							delete this._styles[t],
							this._cleanEmptyObjectsOnPath(e);
					}
					getNormalized(t) {
						return this._styleProcessor.getNormalized(t, this._styles);
					}
					toString() {
						return this.isEmpty
							? ""
							: this._getStylesEntries()
									.map((t) => t.join(":"))
									.sort()
									.join(";") + ";";
					}
					getAsString(t) {
						if (this.isEmpty) return;
						if (this._styles[t] && !C(this._styles[t])) return this._styles[t];
						const e = this._styleProcessor
							.getReducedForm(t, this._styles)
							.find(([e]) => e === t);
						return Array.isArray(e) ? e[1] : void 0;
					}
					getStyleNames(t = !1) {
						if (this.isEmpty) return [];
						if (t) return this._styleProcessor.getStyleNames(this._styles);
						return this._getStylesEntries().map(([t]) => t);
					}
					clear() {
						this._styles = {};
					}
					_getStylesEntries() {
						const t = [],
							e = Object.keys(this._styles);
						for (const n of e)
							t.push(...this._styleProcessor.getReducedForm(n, this._styles));
						return t;
					}
					_cleanEmptyObjectsOnPath(t) {
						const e = t.split(".");
						if (!(e.length > 1)) return;
						const n = e.splice(0, e.length - 1).join("."),
							o = $o(this._styles, n);
						if (!o) return;
						!Array.from(Object.keys(o)).length && this.remove(n);
					}
				}
				class pi {
					constructor() {
						(this._normalizers = new Map()),
							(this._extractors = new Map()),
							(this._reducers = new Map()),
							(this._consumables = new Map());
					}
					toNormalizedForm(t, e, n) {
						if (C(e)) fi(n, gi(t), e);
						else if (this._normalizers.has(t)) {
							const o = this._normalizers.get(t),
								{ path: i, value: r } = o(e);
							fi(n, i, r);
						} else fi(n, t, e);
					}
					getNormalized(t, e) {
						if (!t) return li({}, e);
						if (void 0 !== e[t]) return e[t];
						if (this._extractors.has(t)) {
							const n = this._extractors.get(t);
							if ("string" == typeof n) return $o(e, n);
							const o = n(t, e);
							if (o) return o;
						}
						return $o(e, gi(t));
					}
					getReducedForm(t, e) {
						const n = this.getNormalized(t, e);
						if (void 0 === n) return [];
						if (this._reducers.has(t)) {
							return this._reducers.get(t)(n);
						}
						return [[t, n]];
					}
					getStyleNames(t) {
						const e = Array.from(this._consumables.keys()).filter((e) => {
								const n = this.getNormalized(e, t);
								return n && "object" == typeof n ? Object.keys(n).length : n;
							}),
							n = new Set([...e, ...Object.keys(t)]);
						return Array.from(n.values());
					}
					getRelatedStyles(t) {
						return this._consumables.get(t) || [];
					}
					setNormalizer(t, e) {
						this._normalizers.set(t, e);
					}
					setExtractor(t, e) {
						this._extractors.set(t, e);
					}
					setReducer(t, e) {
						this._reducers.set(t, e);
					}
					setStyleRelation(t, e) {
						this._mapStyleNames(t, e);
						for (const n of e) this._mapStyleNames(n, [t]);
					}
					_mapStyleNames(t, e) {
						this._consumables.has(t) || this._consumables.set(t, []),
							this._consumables.get(t).push(...e);
					}
				}
				function gi(t) {
					return t.replace("-", ".");
				}
				function fi(t, e, n) {
					let o = n;
					C(n) && (o = li({}, $o(t, e), n)), ui(t, e, o);
				}
				class mi extends po {
					constructor(t, e, n, o) {
						if (
							(super(t),
							(this.name = e),
							(this._attrs = (function (t) {
								const e = mo(t);
								for (const [t, n] of e)
									null === n
										? e.delete(t)
										: "string" != typeof n && e.set(t, String(n));
								return e;
							})(n)),
							(this._children = []),
							o && this._insertChild(0, o),
							(this._classes = new Set()),
							this._attrs.has("class"))
						) {
							const t = this._attrs.get("class");
							ki(this._classes, t), this._attrs.delete("class");
						}
						(this._styles = new hi(this.document.stylesProcessor)),
							this._attrs.has("style") &&
								(this._styles.setTo(this._attrs.get("style")),
								this._attrs.delete("style")),
							(this._customProperties = new Map()),
							(this._unsafeAttributesToRender = []);
					}
					get childCount() {
						return this._children.length;
					}
					get isEmpty() {
						return 0 === this._children.length;
					}
					getChild(t) {
						return this._children[t];
					}
					getChildIndex(t) {
						return this._children.indexOf(t);
					}
					getChildren() {
						return this._children[Symbol.iterator]();
					}
					*getAttributeKeys() {
						this._classes.size > 0 && (yield "class"),
							this._styles.isEmpty || (yield "style"),
							yield* this._attrs.keys();
					}
					*getAttributes() {
						yield* this._attrs.entries(),
							this._classes.size > 0 &&
								(yield ["class", this.getAttribute("class")]),
							this._styles.isEmpty ||
								(yield ["style", this.getAttribute("style")]);
					}
					getAttribute(t) {
						if ("class" == t)
							return this._classes.size > 0
								? [...this._classes].join(" ")
								: void 0;
						if ("style" == t) {
							const t = this._styles.toString();
							return "" == t ? void 0 : t;
						}
						return this._attrs.get(t);
					}
					hasAttribute(t) {
						return "class" == t
							? this._classes.size > 0
							: "style" == t
								? !this._styles.isEmpty
								: this._attrs.has(t);
					}
					isSimilar(t) {
						if (!(t instanceof mi)) return !1;
						if (this === t) return !0;
						if (this.name != t.name) return !1;
						if (
							this._attrs.size !== t._attrs.size ||
							this._classes.size !== t._classes.size ||
							this._styles.size !== t._styles.size
						)
							return !1;
						for (const [e, n] of this._attrs)
							if (!t._attrs.has(e) || t._attrs.get(e) !== n) return !1;
						for (const e of this._classes) if (!t._classes.has(e)) return !1;
						for (const e of this._styles.getStyleNames())
							if (
								!t._styles.has(e) ||
								t._styles.getAsString(e) !== this._styles.getAsString(e)
							)
								return !1;
						return !0;
					}
					hasClass(...t) {
						for (const e of t) if (!this._classes.has(e)) return !1;
						return !0;
					}
					getClassNames() {
						return this._classes.keys();
					}
					getStyle(t) {
						return this._styles.getAsString(t);
					}
					getNormalizedStyle(t) {
						return this._styles.getNormalized(t);
					}
					getStyleNames(t) {
						return this._styles.getStyleNames(t);
					}
					hasStyle(...t) {
						for (const e of t) if (!this._styles.has(e)) return !1;
						return !0;
					}
					findAncestor(...t) {
						const e = new ko(...t);
						let n = this.parent;
						for (; n && !n.is("documentFragment"); ) {
							if (e.match(n)) return n;
							n = n.parent;
						}
						return null;
					}
					getCustomProperty(t) {
						return this._customProperties.get(t);
					}
					*getCustomProperties() {
						yield* this._customProperties.entries();
					}
					getIdentity() {
						const t = Array.from(this._classes).sort().join(","),
							e = this._styles.toString(),
							n = Array.from(this._attrs)
								.map((t) => `${t[0]}="${t[1]}"`)
								.sort()
								.join(" ");
						return (
							this.name +
							("" == t ? "" : ` class="${t}"`) +
							(e ? ` style="${e}"` : "") +
							("" == n ? "" : ` ${n}`)
						);
					}
					shouldRenderUnsafeAttribute(t) {
						return this._unsafeAttributesToRender.includes(t);
					}
					_clone(t = !1) {
						const e = [];
						if (t) for (const n of this.getChildren()) e.push(n._clone(t));
						const n = new this.constructor(
							this.document,
							this.name,
							this._attrs,
							e,
						);
						return (
							(n._classes = new Set(this._classes)),
							n._styles.set(this._styles.getNormalized()),
							(n._customProperties = new Map(this._customProperties)),
							(n.getFillerOffset = this.getFillerOffset),
							(n._unsafeAttributesToRender = this._unsafeAttributesToRender),
							n
						);
					}
					_appendChild(t) {
						return this._insertChild(this.childCount, t);
					}
					_insertChild(t, e) {
						this._fireChange("children", this);
						let n = 0;
						const o = (function (t, e) {
							if ("string" == typeof e) return [new go(t, e)];
							Qn(e) || (e = [e]);
							return Array.from(e).map((e) =>
								"string" == typeof e
									? new go(t, e)
									: e instanceof fo
										? new go(t, e.data)
										: e,
							);
						})(this.document, e);
						for (const e of o)
							null !== e.parent && e._remove(),
								(e.parent = this),
								(e.document = this.document),
								this._children.splice(t, 0, e),
								t++,
								n++;
						return n;
					}
					_removeChildren(t, e = 1) {
						this._fireChange("children", this);
						for (let n = t; n < t + e; n++) this._children[n].parent = null;
						return this._children.splice(t, e);
					}
					_setAttribute(t, e) {
						(e = String(e)),
							this._fireChange("attributes", this),
							"class" == t
								? ki(this._classes, e)
								: "style" == t
									? this._styles.setTo(e)
									: this._attrs.set(t, e);
					}
					_removeAttribute(t) {
						return (
							this._fireChange("attributes", this),
							"class" == t
								? this._classes.size > 0 && (this._classes.clear(), !0)
								: "style" == t
									? !this._styles.isEmpty && (this._styles.clear(), !0)
									: this._attrs.delete(t)
						);
					}
					_addClass(t) {
						this._fireChange("attributes", this);
						for (const e of to(t)) this._classes.add(e);
					}
					_removeClass(t) {
						this._fireChange("attributes", this);
						for (const e of to(t)) this._classes.delete(e);
					}
					_setStyle(t, e) {
						this._fireChange("attributes", this),
							it(t) ? this._styles.set(t) : this._styles.set(t, e);
					}
					_removeStyle(t) {
						this._fireChange("attributes", this);
						for (const e of to(t)) this._styles.remove(e);
					}
					_setCustomProperty(t, e) {
						this._customProperties.set(t, e);
					}
					_removeCustomProperty(t) {
						return this._customProperties.delete(t);
					}
				}
				function ki(t, e) {
					const n = e.split(/\s+/);
					t.clear(), n.forEach((e) => t.add(e));
				}
				mi.prototype.is = function (t, e) {
					return e
						? e === this.name && ("element" === t || "view:element" === t)
						: "element" === t ||
								"view:element" === t ||
								"node" === t ||
								"view:node" === t;
				};
				class bi extends mi {
					constructor(...t) {
						super(...t), (this.getFillerOffset = wi);
					}
				}
				function wi() {
					const t = [...this.getChildren()],
						e = t[this.childCount - 1];
					if (e && e.is("element", "br")) return this.childCount;
					for (const e of t) if (!e.is("uiElement")) return null;
					return this.childCount;
				}
				bi.prototype.is = function (t, e) {
					return e
						? e === this.name &&
								("containerElement" === t ||
									"view:containerElement" === t ||
									"element" === t ||
									"view:element" === t)
						: "containerElement" === t ||
								"view:containerElement" === t ||
								"element" === t ||
								"view:element" === t ||
								"node" === t ||
								"view:node" === t;
				};
				class Ai extends S(bi) {
					constructor(...t) {
						super(...t);
						const e = t[0];
						this.set("isReadOnly", !1),
							this.set("isFocused", !1),
							this.bind("isReadOnly").to(e),
							this.bind("isFocused").to(
								e,
								"isFocused",
								(t) => t && e.selection.editableElement == this,
							),
							this.listenTo(e.selection, "change", () => {
								this.isFocused =
									e.isFocused && e.selection.editableElement == this;
							});
					}
					destroy() {
						this.stopListening();
					}
				}
				Ai.prototype.is = function (t, e) {
					return e
						? e === this.name &&
								("editableElement" === t ||
									"view:editableElement" === t ||
									"containerElement" === t ||
									"view:containerElement" === t ||
									"element" === t ||
									"view:element" === t)
						: "editableElement" === t ||
								"view:editableElement" === t ||
								"containerElement" === t ||
								"view:containerElement" === t ||
								"element" === t ||
								"view:element" === t ||
								"node" === t ||
								"view:node" === t;
				};
				const _i = Symbol("rootName");
				class Ci extends Ai {
					constructor(t, e) {
						super(t, e), (this.rootName = "main");
					}
					get rootName() {
						return this.getCustomProperty(_i);
					}
					set rootName(t) {
						this._setCustomProperty(_i, t);
					}
					set _name(t) {
						this.name = t;
					}
				}
				Ci.prototype.is = function (t, e) {
					return e
						? e === this.name &&
								("rootElement" === t ||
									"view:rootElement" === t ||
									"editableElement" === t ||
									"view:editableElement" === t ||
									"containerElement" === t ||
									"view:containerElement" === t ||
									"element" === t ||
									"view:element" === t)
						: "rootElement" === t ||
								"view:rootElement" === t ||
								"editableElement" === t ||
								"view:editableElement" === t ||
								"containerElement" === t ||
								"view:containerElement" === t ||
								"element" === t ||
								"view:element" === t ||
								"node" === t ||
								"view:node" === t;
				};
				class vi {
					constructor(t = {}) {
						if (!t.boundaries && !t.startPosition)
							throw new l.a("view-tree-walker-no-start-position", null);
						if (
							t.direction &&
							"forward" != t.direction &&
							"backward" != t.direction
						)
							throw new l.a(
								"view-tree-walker-unknown-direction",
								t.startPosition,
								{ direction: t.direction },
							);
						(this.boundaries = t.boundaries || null),
							t.startPosition
								? (this.position = yi._createAt(t.startPosition))
								: (this.position = yi._createAt(
										t.boundaries["backward" == t.direction ? "end" : "start"],
									)),
							(this.direction = t.direction || "forward"),
							(this.singleCharacters = !!t.singleCharacters),
							(this.shallow = !!t.shallow),
							(this.ignoreElementEnd = !!t.ignoreElementEnd),
							(this._boundaryStartParent = this.boundaries
								? this.boundaries.start.parent
								: null),
							(this._boundaryEndParent = this.boundaries
								? this.boundaries.end.parent
								: null);
					}
					[Symbol.iterator]() {
						return this;
					}
					skip(t) {
						let e, n, o;
						do {
							(o = this.position), ({ done: e, value: n } = this.next());
						} while (!e && t(n));
						e || (this.position = o);
					}
					next() {
						return "forward" == this.direction
							? this._next()
							: this._previous();
					}
					_next() {
						let t = this.position.clone();
						const e = this.position,
							n = t.parent;
						if (null === n.parent && t.offset === n.childCount)
							return { done: !0, value: void 0 };
						if (
							n === this._boundaryEndParent &&
							t.offset == this.boundaries.end.offset
						)
							return { done: !0, value: void 0 };
						let o;
						if (n instanceof go) {
							if (t.isAtEnd)
								return (this.position = yi._createAfter(n)), this._next();
							o = n.data[t.offset];
						} else o = n.getChild(t.offset);
						if (o instanceof mi)
							return (
								this.shallow ? t.offset++ : (t = new yi(o, 0)),
								(this.position = t),
								this._formatReturnValue("elementStart", o, e, t, 1)
							);
						if (o instanceof go) {
							if (this.singleCharacters)
								return (t = new yi(o, 0)), (this.position = t), this._next();
							{
								let n,
									i = o.data.length;
								return (
									o == this._boundaryEndParent
										? ((i = this.boundaries.end.offset),
											(n = new fo(o, 0, i)),
											(t = yi._createAfter(n)))
										: ((n = new fo(o, 0, o.data.length)), t.offset++),
									(this.position = t),
									this._formatReturnValue("text", n, e, t, i)
								);
							}
						}
						if ("string" == typeof o) {
							let o;
							if (this.singleCharacters) o = 1;
							else {
								o =
									(n === this._boundaryEndParent
										? this.boundaries.end.offset
										: n.data.length) - t.offset;
							}
							const i = new fo(n, t.offset, o);
							return (
								(t.offset += o),
								(this.position = t),
								this._formatReturnValue("text", i, e, t, o)
							);
						}
						return (
							(t = yi._createAfter(n)),
							(this.position = t),
							this.ignoreElementEnd
								? this._next()
								: this._formatReturnValue("elementEnd", n, e, t)
						);
					}
					_previous() {
						let t = this.position.clone();
						const e = this.position,
							n = t.parent;
						if (null === n.parent && 0 === t.offset)
							return { done: !0, value: void 0 };
						if (
							n == this._boundaryStartParent &&
							t.offset == this.boundaries.start.offset
						)
							return { done: !0, value: void 0 };
						let o;
						if (n instanceof go) {
							if (t.isAtStart)
								return (this.position = yi._createBefore(n)), this._previous();
							o = n.data[t.offset - 1];
						} else o = n.getChild(t.offset - 1);
						if (o instanceof mi)
							return this.shallow
								? (t.offset--,
									(this.position = t),
									this._formatReturnValue("elementStart", o, e, t, 1))
								: ((t = new yi(o, o.childCount)),
									(this.position = t),
									this.ignoreElementEnd
										? this._previous()
										: this._formatReturnValue("elementEnd", o, e, t));
						if (o instanceof go) {
							if (this.singleCharacters)
								return (
									(t = new yi(o, o.data.length)),
									(this.position = t),
									this._previous()
								);
							{
								let n,
									i = o.data.length;
								if (o == this._boundaryStartParent) {
									const e = this.boundaries.start.offset;
									(n = new fo(o, e, o.data.length - e)),
										(i = n.data.length),
										(t = yi._createBefore(n));
								} else (n = new fo(o, 0, o.data.length)), t.offset--;
								return (
									(this.position = t),
									this._formatReturnValue("text", n, e, t, i)
								);
							}
						}
						if ("string" == typeof o) {
							let o;
							if (this.singleCharacters) o = 1;
							else {
								const e =
									n === this._boundaryStartParent
										? this.boundaries.start.offset
										: 0;
								o = t.offset - e;
							}
							t.offset -= o;
							const i = new fo(n, t.offset, o);
							return (
								(this.position = t), this._formatReturnValue("text", i, e, t, o)
							);
						}
						return (
							(t = yi._createBefore(n)),
							(this.position = t),
							this._formatReturnValue("elementStart", n, e, t, 1)
						);
					}
					_formatReturnValue(t, e, n, o, i) {
						return (
							e instanceof fo &&
								(e.offsetInText + e.data.length == e.textNode.data.length &&
									("forward" != this.direction ||
									(this.boundaries &&
										this.boundaries.end.isEqual(this.position))
										? (n = yi._createAfter(e.textNode))
										: ((o = yi._createAfter(e.textNode)), (this.position = o))),
								0 === e.offsetInText &&
									("backward" != this.direction ||
									(this.boundaries &&
										this.boundaries.start.isEqual(this.position))
										? (n = yi._createBefore(e.textNode))
										: ((o = yi._createBefore(e.textNode)),
											(this.position = o)))),
							{
								done: !1,
								value: {
									type: t,
									item: e,
									previousPosition: n,
									nextPosition: o,
									length: i,
								},
							}
						);
					}
				}
				class yi extends lo {
					constructor(t, e) {
						super(), (this.parent = t), (this.offset = e);
					}
					get nodeAfter() {
						return this.parent.is("$text")
							? null
							: this.parent.getChild(this.offset) || null;
					}
					get nodeBefore() {
						return this.parent.is("$text")
							? null
							: this.parent.getChild(this.offset - 1) || null;
					}
					get isAtStart() {
						return 0 === this.offset;
					}
					get isAtEnd() {
						const t = this.parent.is("$text")
							? this.parent.data.length
							: this.parent.childCount;
						return this.offset === t;
					}
					get root() {
						return this.parent.root;
					}
					get editableElement() {
						let t = this.parent;
						for (; !(t instanceof Ai); ) {
							if (!t.parent) return null;
							t = t.parent;
						}
						return t;
					}
					getShiftedBy(t) {
						const e = yi._createAt(this),
							n = e.offset + t;
						return (e.offset = n < 0 ? 0 : n), e;
					}
					getLastMatchingPosition(t, e = {}) {
						e.startPosition = this;
						const n = new vi(e);
						return n.skip(t), n.position;
					}
					getAncestors() {
						return this.parent.is("documentFragment")
							? [this.parent]
							: this.parent.getAncestors({ includeSelf: !0 });
					}
					getCommonAncestor(t) {
						const e = this.getAncestors(),
							n = t.getAncestors();
						let o = 0;
						for (; e[o] == n[o] && e[o]; ) o++;
						return 0 === o ? null : e[o - 1];
					}
					isEqual(t) {
						return this.parent == t.parent && this.offset == t.offset;
					}
					isBefore(t) {
						return "before" == this.compareWith(t);
					}
					isAfter(t) {
						return "after" == this.compareWith(t);
					}
					compareWith(t) {
						if (this.root !== t.root) return "different";
						if (this.isEqual(t)) return "same";
						const e = this.parent.is("node") ? this.parent.getPath() : [],
							n = t.parent.is("node") ? t.parent.getPath() : [];
						e.push(this.offset), n.push(t.offset);
						const o = uo(e, n);
						switch (o) {
							case "prefix":
								return "before";
							case "extension":
								return "after";
							default:
								return e[o] < n[o] ? "before" : "after";
						}
					}
					getWalker(t = {}) {
						return (t.startPosition = this), new vi(t);
					}
					clone() {
						return new yi(this.parent, this.offset);
					}
					static _createAt(t, e) {
						if (t instanceof yi) return new this(t.parent, t.offset);
						{
							const n = t;
							if ("end" == e) e = n.is("$text") ? n.data.length : n.childCount;
							else {
								if ("before" == e) return this._createBefore(n);
								if ("after" == e) return this._createAfter(n);
								if (0 !== e && !e)
									throw new l.a("view-createpositionat-offset-required", n);
							}
							return new yi(n, e);
						}
					}
					static _createAfter(t) {
						if (t.is("$textProxy"))
							return new yi(t.textNode, t.offsetInText + t.data.length);
						if (!t.parent)
							throw new l.a("view-position-after-root", t, { root: t });
						return new yi(t.parent, t.index + 1);
					}
					static _createBefore(t) {
						if (t.is("$textProxy")) return new yi(t.textNode, t.offsetInText);
						if (!t.parent)
							throw new l.a("view-position-before-root", t, { root: t });
						return new yi(t.parent, t.index);
					}
				}
				yi.prototype.is = function (t) {
					return "position" === t || "view:position" === t;
				};
				class xi extends lo {
					constructor(t, e = null) {
						super(),
							(this.start = t.clone()),
							(this.end = e ? e.clone() : t.clone());
					}
					*[Symbol.iterator]() {
						yield* new vi({ boundaries: this, ignoreElementEnd: !0 });
					}
					get isCollapsed() {
						return this.start.isEqual(this.end);
					}
					get isFlat() {
						return this.start.parent === this.end.parent;
					}
					get root() {
						return this.start.root;
					}
					getEnlarged() {
						let t = this.start.getLastMatchingPosition(Di, {
								direction: "backward",
							}),
							e = this.end.getLastMatchingPosition(Di);
						return (
							t.parent.is("$text") &&
								t.isAtStart &&
								(t = yi._createBefore(t.parent)),
							e.parent.is("$text") &&
								e.isAtEnd &&
								(e = yi._createAfter(e.parent)),
							new xi(t, e)
						);
					}
					getTrimmed() {
						let t = this.start.getLastMatchingPosition(Di);
						if (t.isAfter(this.end) || t.isEqual(this.end)) return new xi(t, t);
						let e = this.end.getLastMatchingPosition(Di, {
							direction: "backward",
						});
						const n = t.nodeAfter,
							o = e.nodeBefore;
						return (
							n && n.is("$text") && (t = new yi(n, 0)),
							o && o.is("$text") && (e = new yi(o, o.data.length)),
							new xi(t, e)
						);
					}
					isEqual(t) {
						return (
							this == t ||
							(this.start.isEqual(t.start) && this.end.isEqual(t.end))
						);
					}
					containsPosition(t) {
						return t.isAfter(this.start) && t.isBefore(this.end);
					}
					containsRange(t, e = !1) {
						t.isCollapsed && (e = !1);
						const n =
								this.containsPosition(t.start) ||
								(e && this.start.isEqual(t.start)),
							o =
								this.containsPosition(t.end) || (e && this.end.isEqual(t.end));
						return n && o;
					}
					getDifference(t) {
						const e = [];
						return (
							this.isIntersecting(t)
								? (this.containsPosition(t.start) &&
										e.push(new xi(this.start, t.start)),
									this.containsPosition(t.end) &&
										e.push(new xi(t.end, this.end)))
								: e.push(this.clone()),
							e
						);
					}
					getIntersection(t) {
						if (this.isIntersecting(t)) {
							let e = this.start,
								n = this.end;
							return (
								this.containsPosition(t.start) && (e = t.start),
								this.containsPosition(t.end) && (n = t.end),
								new xi(e, n)
							);
						}
						return null;
					}
					getWalker(t = {}) {
						return (t.boundaries = this), new vi(t);
					}
					getCommonAncestor() {
						return this.start.getCommonAncestor(this.end);
					}
					getContainedElement() {
						if (this.isCollapsed) return null;
						let t = this.start.nodeAfter,
							e = this.end.nodeBefore;
						return (
							this.start.parent.is("$text") &&
								this.start.isAtEnd &&
								this.start.parent.nextSibling &&
								(t = this.start.parent.nextSibling),
							this.end.parent.is("$text") &&
								this.end.isAtStart &&
								this.end.parent.previousSibling &&
								(e = this.end.parent.previousSibling),
							t && t.is("element") && t === e ? t : null
						);
					}
					clone() {
						return new xi(this.start, this.end);
					}
					*getItems(t = {}) {
						(t.boundaries = this), (t.ignoreElementEnd = !0);
						const e = new vi(t);
						for (const t of e) yield t.item;
					}
					*getPositions(t = {}) {
						t.boundaries = this;
						const e = new vi(t);
						yield e.position;
						for (const t of e) yield t.nextPosition;
					}
					isIntersecting(t) {
						return this.start.isBefore(t.end) && this.end.isAfter(t.start);
					}
					static _createFromParentsAndOffsets(t, e, n, o) {
						return new this(new yi(t, e), new yi(n, o));
					}
					static _createFromPositionAndShift(t, e) {
						const n = t,
							o = t.getShiftedBy(e);
						return e > 0 ? new this(n, o) : new this(o, n);
					}
					static _createIn(t) {
						return this._createFromParentsAndOffsets(t, 0, t, t.childCount);
					}
					static _createOn(t) {
						const e = t.is("$textProxy") ? t.offsetSize : 1;
						return this._createFromPositionAndShift(yi._createBefore(t), e);
					}
				}
				function Di(t) {
					return !(!t.item.is("attributeElement") && !t.item.is("uiElement"));
				}
				function Ei(t) {
					let e = 0;
					for (const n of t) e++;
					return e;
				}
				xi.prototype.is = function (t) {
					return "range" === t || "view:range" === t;
				};
				class Si extends p(lo) {
					constructor(...t) {
						super(),
							(this._ranges = []),
							(this._lastRangeBackward = !1),
							(this._isFake = !1),
							(this._fakeSelectionLabel = ""),
							t.length && this.setTo(...t);
					}
					get isFake() {
						return this._isFake;
					}
					get fakeSelectionLabel() {
						return this._fakeSelectionLabel;
					}
					get anchor() {
						if (!this._ranges.length) return null;
						const t = this._ranges[this._ranges.length - 1];
						return (this._lastRangeBackward ? t.end : t.start).clone();
					}
					get focus() {
						if (!this._ranges.length) return null;
						const t = this._ranges[this._ranges.length - 1];
						return (this._lastRangeBackward ? t.start : t.end).clone();
					}
					get isCollapsed() {
						return 1 === this.rangeCount && this._ranges[0].isCollapsed;
					}
					get rangeCount() {
						return this._ranges.length;
					}
					get isBackward() {
						return !this.isCollapsed && this._lastRangeBackward;
					}
					get editableElement() {
						return this.anchor ? this.anchor.editableElement : null;
					}
					*getRanges() {
						for (const t of this._ranges) yield t.clone();
					}
					getFirstRange() {
						let t = null;
						for (const e of this._ranges)
							(t && !e.start.isBefore(t.start)) || (t = e);
						return t ? t.clone() : null;
					}
					getLastRange() {
						let t = null;
						for (const e of this._ranges)
							(t && !e.end.isAfter(t.end)) || (t = e);
						return t ? t.clone() : null;
					}
					getFirstPosition() {
						const t = this.getFirstRange();
						return t ? t.start.clone() : null;
					}
					getLastPosition() {
						const t = this.getLastRange();
						return t ? t.end.clone() : null;
					}
					isEqual(t) {
						if (this.isFake != t.isFake) return !1;
						if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel)
							return !1;
						if (this.rangeCount != t.rangeCount) return !1;
						if (0 === this.rangeCount) return !0;
						if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus))
							return !1;
						for (const e of this._ranges) {
							let n = !1;
							for (const o of t._ranges)
								if (e.isEqual(o)) {
									n = !0;
									break;
								}
							if (!n) return !1;
						}
						return !0;
					}
					isSimilar(t) {
						if (this.isBackward != t.isBackward) return !1;
						const e = Ei(this.getRanges());
						if (e != Ei(t.getRanges())) return !1;
						if (0 == e) return !0;
						for (let e of this.getRanges()) {
							e = e.getTrimmed();
							let n = !1;
							for (let o of t.getRanges())
								if (
									((o = o.getTrimmed()),
									e.start.isEqual(o.start) && e.end.isEqual(o.end))
								) {
									n = !0;
									break;
								}
							if (!n) return !1;
						}
						return !0;
					}
					getSelectedElement() {
						return 1 !== this.rangeCount
							? null
							: this.getFirstRange().getContainedElement();
					}
					setTo(...t) {
						let [e, n, o] = t;
						if (("object" == typeof n && ((o = n), (n = void 0)), null === e))
							this._setRanges([]), this._setFakeOptions(o);
						else if (e instanceof Si || e instanceof Bi)
							this._setRanges(e.getRanges(), e.isBackward),
								this._setFakeOptions({
									fake: e.isFake,
									label: e.fakeSelectionLabel,
								});
						else if (e instanceof xi)
							this._setRanges([e], o && o.backward), this._setFakeOptions(o);
						else if (e instanceof yi)
							this._setRanges([new xi(e)]), this._setFakeOptions(o);
						else if (e instanceof po) {
							const t = !!o && !!o.backward;
							let i;
							if (void 0 === n)
								throw new l.a(
									"view-selection-setto-required-second-parameter",
									this,
								);
							(i =
								"in" == n
									? xi._createIn(e)
									: "on" == n
										? xi._createOn(e)
										: new xi(yi._createAt(e, n))),
								this._setRanges([i], t),
								this._setFakeOptions(o);
						} else {
							if (!Qn(e))
								throw new l.a("view-selection-setto-not-selectable", this);
							this._setRanges(e, o && o.backward), this._setFakeOptions(o);
						}
						this.fire("change");
					}
					setFocus(t, e) {
						if (null === this.anchor)
							throw new l.a("view-selection-setfocus-no-ranges", this);
						const n = yi._createAt(t, e);
						if ("same" == n.compareWith(this.focus)) return;
						const o = this.anchor;
						this._ranges.pop(),
							"before" == n.compareWith(o)
								? this._addRange(new xi(n, o), !0)
								: this._addRange(new xi(o, n)),
							this.fire("change");
					}
					_setRanges(t, e = !1) {
						(t = Array.from(t)), (this._ranges = []);
						for (const e of t) this._addRange(e);
						this._lastRangeBackward = !!e;
					}
					_setFakeOptions(t = {}) {
						(this._isFake = !!t.fake),
							(this._fakeSelectionLabel = (t.fake && t.label) || "");
					}
					_addRange(t, e = !1) {
						if (!(t instanceof xi))
							throw new l.a("view-selection-add-range-not-range", this);
						this._pushRange(t), (this._lastRangeBackward = !!e);
					}
					_pushRange(t) {
						for (const e of this._ranges)
							if (t.isIntersecting(e))
								throw new l.a("view-selection-range-intersects", this, {
									addedRange: t,
									intersectingRange: e,
								});
						this._ranges.push(new xi(t.start, t.end));
					}
				}
				Si.prototype.is = function (t) {
					return "selection" === t || "view:selection" === t;
				};
				class Bi extends p(lo) {
					constructor(...t) {
						super(),
							(this._selection = new Si()),
							this._selection.delegate("change").to(this),
							t.length && this._selection.setTo(...t);
					}
					get isFake() {
						return this._selection.isFake;
					}
					get fakeSelectionLabel() {
						return this._selection.fakeSelectionLabel;
					}
					get anchor() {
						return this._selection.anchor;
					}
					get focus() {
						return this._selection.focus;
					}
					get isCollapsed() {
						return this._selection.isCollapsed;
					}
					get rangeCount() {
						return this._selection.rangeCount;
					}
					get isBackward() {
						return this._selection.isBackward;
					}
					get editableElement() {
						return this._selection.editableElement;
					}
					get _ranges() {
						return this._selection._ranges;
					}
					*getRanges() {
						yield* this._selection.getRanges();
					}
					getFirstRange() {
						return this._selection.getFirstRange();
					}
					getLastRange() {
						return this._selection.getLastRange();
					}
					getFirstPosition() {
						return this._selection.getFirstPosition();
					}
					getLastPosition() {
						return this._selection.getLastPosition();
					}
					getSelectedElement() {
						return this._selection.getSelectedElement();
					}
					isEqual(t) {
						return this._selection.isEqual(t);
					}
					isSimilar(t) {
						return this._selection.isSimilar(t);
					}
					_setTo(...t) {
						this._selection.setTo(...t);
					}
					_setFocus(t, e) {
						this._selection.setFocus(t, e);
					}
				}
				Bi.prototype.is = function (t) {
					return (
						"selection" === t ||
						"documentSelection" == t ||
						"view:selection" == t ||
						"view:documentSelection" == t
					);
				};
				class Ti extends i {
					constructor(t, e, n) {
						super(t, e),
							(this.startRange = n),
							(this._eventPhase = "none"),
							(this._currentTarget = null);
					}
					get eventPhase() {
						return this._eventPhase;
					}
					get currentTarget() {
						return this._currentTarget;
					}
				}
				const Pi = Symbol("bubbling contexts");
				function Fi(t) {
					return class extends t {
						fire(t, ...e) {
							try {
								const n = t instanceof i ? t : new i(this, t),
									o = Oi(this);
								if (!o.size) return;
								if ((Ii(n, "capturing", this), zi(o, "$capture", n, ...e)))
									return n.return;
								const r = n.startRange || this.selection.getFirstRange(),
									s = r ? r.getContainedElement() : null,
									a = !!s && Boolean(Ri(o, s));
								let c =
									s ||
									(function (t) {
										if (!t) return null;
										const e = t.start.parent,
											n = t.end.parent,
											o = e.getPath(),
											i = n.getPath();
										return o.length > i.length ? e : n;
									})(r);
								if ((Ii(n, "atTarget", c), !a)) {
									if (zi(o, "$text", n, ...e)) return n.return;
									Ii(n, "bubbling", c);
								}
								for (; c; ) {
									if (c.is("rootElement")) {
										if (zi(o, "$root", n, ...e)) return n.return;
									} else if (c.is("element") && zi(o, c.name, n, ...e))
										return n.return;
									if (zi(o, c, n, ...e)) return n.return;
									(c = c.parent), Ii(n, "bubbling", c);
								}
								return (
									Ii(n, "bubbling", this), zi(o, "$document", n, ...e), n.return
								);
							} catch (t) {
								l.a.rethrowUnexpectedError(t, this);
							}
						}
						_addEventListener(t, e, n) {
							const o = to(n.context || "$document"),
								i = Oi(this);
							for (const r of o) {
								let o = i.get(r);
								o || ((o = new g()), i.set(r, o)), this.listenTo(o, t, e, n);
							}
						}
						_removeEventListener(t, e) {
							const n = Oi(this);
							for (const o of n.values()) this.stopListening(o, t, e);
						}
					};
				}
				{
					const t = Fi(Object);
					["fire", "_addEventListener", "_removeEventListener"].forEach((e) => {
						Fi[e] = t.prototype[e];
					});
				}
				function Ii(t, e, n) {
					t instanceof Ti && ((t._eventPhase = e), (t._currentTarget = n));
				}
				function zi(t, e, n, ...o) {
					const i = "string" == typeof e ? t.get(e) : Ri(t, e);
					return !!i && (i.fire(n, ...o), n.stop.called);
				}
				function Ri(t, e) {
					for (const [n, o] of t) if ("function" == typeof n && n(e)) return o;
					return null;
				}
				function Oi(t) {
					return t[Pi] || (t[Pi] = new Map()), t[Pi];
				}
				class Mi extends Fi(B) {
					constructor(t) {
						super(),
							(this.selection = new Bi()),
							(this.roots = new Xn({ idProperty: "rootName" })),
							(this.stylesProcessor = t),
							this.set("isReadOnly", !1),
							this.set("isFocused", !1),
							this.set("isSelecting", !1),
							this.set("isComposing", !1),
							(this._postFixers = new Set());
					}
					getRoot(t = "main") {
						return this.roots.get(t);
					}
					registerPostFixer(t) {
						this._postFixers.add(t);
					}
					destroy() {
						this.roots.map((t) => t.destroy()), this.stopListening();
					}
					_callPostFixers(t) {
						let e = !1;
						do {
							for (const n of this._postFixers) if (((e = n(t)), e)) break;
						} while (e);
					}
				}
				class Ni extends mi {
					constructor(...t) {
						super(...t),
							(this.getFillerOffset = Vi),
							(this._priority = 10),
							(this._id = null),
							(this._clonesGroup = null);
					}
					get priority() {
						return this._priority;
					}
					get id() {
						return this._id;
					}
					getElementsWithSameId() {
						if (null === this.id)
							throw new l.a(
								"attribute-element-get-elements-with-same-id-no-id",
								this,
							);
						return new Set(this._clonesGroup);
					}
					isSimilar(t) {
						return null !== this.id || null !== t.id
							? this.id === t.id
							: super.isSimilar(t) && this.priority == t.priority;
					}
					_clone(t = !1) {
						const e = super._clone(t);
						return (e._priority = this._priority), (e._id = this._id), e;
					}
				}
				function Vi() {
					if (Li(this)) return null;
					let t = this.parent;
					for (; t && t.is("attributeElement"); ) {
						if (Li(t) > 1) return null;
						t = t.parent;
					}
					return !t || Li(t) > 1 ? null : this.childCount;
				}
				function Li(t) {
					return Array.from(t.getChildren()).filter((t) => !t.is("uiElement"))
						.length;
				}
				(Ni.DEFAULT_PRIORITY = 10),
					(Ni.prototype.is = function (t, e) {
						return e
							? e === this.name &&
									("attributeElement" === t ||
										"view:attributeElement" === t ||
										"element" === t ||
										"view:element" === t)
							: "attributeElement" === t ||
									"view:attributeElement" === t ||
									"element" === t ||
									"view:element" === t ||
									"node" === t ||
									"view:node" === t;
					});
				class ji extends mi {
					constructor(t, e, n, o) {
						super(t, e, n, o), (this.getFillerOffset = Hi);
					}
					_insertChild(t, e) {
						if (e && (e instanceof po || Array.from(e).length > 0))
							throw new l.a("view-emptyelement-cannot-add", [this, e]);
						return 0;
					}
				}
				function Hi() {
					return null;
				}
				ji.prototype.is = function (t, e) {
					return e
						? e === this.name &&
								("emptyElement" === t ||
									"view:emptyElement" === t ||
									"element" === t ||
									"view:element" === t)
						: "emptyElement" === t ||
								"view:emptyElement" === t ||
								"element" === t ||
								"view:element" === t ||
								"node" === t ||
								"view:node" === t;
				};
				const $i = (function () {
						try {
							return navigator.userAgent.toLowerCase();
						} catch (t) {
							return "";
						}
					})(),
					qi = {
						isMac: Wi($i),
						isWindows: (function (t) {
							return t.indexOf("windows") > -1;
						})($i),
						isGecko: (function (t) {
							return !!t.match(/gecko\/\d+/);
						})($i),
						isSafari: (function (t) {
							return (
								t.indexOf(" applewebkit/") > -1 && -1 === t.indexOf("chrome")
							);
						})($i),
						isiOS: (function (t) {
							return (
								!!t.match(/iphone|ipad/i) ||
								(Wi(t) && navigator.maxTouchPoints > 0)
							);
						})($i),
						isAndroid: (function (t) {
							return t.indexOf("android") > -1;
						})($i),
						isBlink: (function (t) {
							return t.indexOf("chrome/") > -1 && t.indexOf("edge/") < 0;
						})($i),
						features: {
							isRegExpUnicodePropertySupported: (function () {
								let t = !1;
								try {
									t = 0 === "ć".search(new RegExp("[\\p{L}]", "u"));
								} catch (t) {}
								return t;
							})(),
						},
					};
				var Ui = qi;
				function Wi(t) {
					return t.indexOf("macintosh") > -1;
				}
				const Ki = { ctrl: "⌃", cmd: "⌘", alt: "⌥", shift: "⇧" },
					Gi = { ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+" },
					Ji = (function () {
						const t = {
							arrowleft: 37,
							arrowup: 38,
							arrowright: 39,
							arrowdown: 40,
							backspace: 8,
							delete: 46,
							enter: 13,
							space: 32,
							esc: 27,
							tab: 9,
							ctrl: 1114112,
							shift: 2228224,
							alt: 4456448,
							cmd: 8912896,
						};
						for (let e = 65; e <= 90; e++) {
							const n = String.fromCharCode(e);
							t[n.toLowerCase()] = e;
						}
						for (let e = 48; e <= 57; e++) t[e - 48] = e;
						for (let e = 112; e <= 123; e++) t["f" + (e - 111)] = e;
						for (const e of "`-=[];',./\\") t[e] = e.charCodeAt(0);
						return t;
					})(),
					Yi = Object.fromEntries(
						Object.entries(Ji).map(([t, e]) => [
							e,
							t.charAt(0).toUpperCase() + t.slice(1),
						]),
					);
				function Qi(t) {
					let e;
					if ("string" == typeof t) {
						if (((e = Ji[t.toLowerCase()]), !e))
							throw new l.a("keyboard-unknown-key", null, { key: t });
					} else
						e =
							t.keyCode +
							(t.altKey ? Ji.alt : 0) +
							(t.ctrlKey ? Ji.ctrl : 0) +
							(t.shiftKey ? Ji.shift : 0) +
							(t.metaKey ? Ji.cmd : 0);
					return e;
				}
				function Xi(t) {
					return (
						"string" == typeof t &&
							(t = (function (t) {
								return t.split("+").map((t) => t.trim());
							})(t)),
						t
							.map((t) =>
								"string" == typeof t
									? (function (t) {
											if (t.endsWith("!")) return Qi(t.slice(0, -1));
											const e = Qi(t);
											return Ui.isMac && e == Ji.ctrl ? Ji.cmd : e;
										})(t)
									: t,
							)
							.reduce((t, e) => e + t, 0)
					);
				}
				function Zi(t) {
					let e = Xi(t);
					return (
						Object.entries(Ui.isMac ? Ki : Gi).reduce(
							(t, [n, o]) => (0 != (e & Ji[n]) && ((e &= ~Ji[n]), (t += o)), t),
							"",
						) + (e ? Yi[e] : "")
					);
				}
				function tr(t, e) {
					const n = "ltr" === e;
					switch (t) {
						case Ji.arrowleft:
							return n ? "left" : "right";
						case Ji.arrowright:
							return n ? "right" : "left";
						case Ji.arrowup:
							return "up";
						case Ji.arrowdown:
							return "down";
					}
				}
				class er extends mi {
					constructor(...t) {
						super(...t), (this.getFillerOffset = or);
					}
					_insertChild(t, e) {
						if (e && (e instanceof po || Array.from(e).length > 0))
							throw new l.a("view-uielement-cannot-add", [this, e]);
						return 0;
					}
					render(t, e) {
						return this.toDomElement(t);
					}
					toDomElement(t) {
						const e = t.createElement(this.name);
						for (const t of this.getAttributeKeys())
							e.setAttribute(t, this.getAttribute(t));
						return e;
					}
				}
				function nr(t) {
					t.document.on(
						"arrowKey",
						(e, n) =>
							(function (t, e, n) {
								if (e.keyCode == Ji.arrowright) {
									const t =
											e.domTarget.ownerDocument.defaultView.getSelection(),
										o = 1 == t.rangeCount && t.getRangeAt(0).collapsed;
									if (o || e.shiftKey) {
										const e = t.focusNode,
											i = t.focusOffset,
											r = n.domPositionToView(e, i);
										if (null === r) return;
										let s = !1;
										const a = r.getLastMatchingPosition(
											(t) => (
												t.item.is("uiElement") && (s = !0),
												!(
													!t.item.is("uiElement") &&
													!t.item.is("attributeElement")
												)
											),
										);
										if (s) {
											const e = n.viewPositionToDom(a);
											o
												? t.collapse(e.parent, e.offset)
												: t.extend(e.parent, e.offset);
										}
									}
								}
							})(0, n, t.domConverter),
						{ priority: "low" },
					);
				}
				function or() {
					return null;
				}
				er.prototype.is = function (t, e) {
					return e
						? e === this.name &&
								("uiElement" === t ||
									"view:uiElement" === t ||
									"element" === t ||
									"view:element" === t)
						: "uiElement" === t ||
								"view:uiElement" === t ||
								"element" === t ||
								"view:element" === t ||
								"node" === t ||
								"view:node" === t;
				};
				class ir extends mi {
					constructor(...t) {
						super(...t), (this.getFillerOffset = rr);
					}
					_insertChild(t, e) {
						if (e && (e instanceof po || Array.from(e).length > 0))
							throw new l.a("view-rawelement-cannot-add", [this, e]);
						return 0;
					}
					render() {}
				}
				function rr() {
					return null;
				}
				ir.prototype.is = function (t, e) {
					return e
						? e === this.name &&
								("rawElement" === t ||
									"view:rawElement" === t ||
									"element" === t ||
									"view:element" === t)
						: "rawElement" === t ||
								"view:rawElement" === t ||
								t === this.name ||
								t === "view:" + this.name ||
								"element" === t ||
								"view:element" === t ||
								"node" === t ||
								"view:node" === t;
				};
				class sr extends p(lo) {
					constructor(t, e) {
						super(),
							(this.document = t),
							(this._children = []),
							e && this._insertChild(0, e);
					}
					[Symbol.iterator]() {
						return this._children[Symbol.iterator]();
					}
					get childCount() {
						return this._children.length;
					}
					get isEmpty() {
						return 0 === this.childCount;
					}
					get root() {
						return this;
					}
					get parent() {
						return null;
					}
					_appendChild(t) {
						return this._insertChild(this.childCount, t);
					}
					getChild(t) {
						return this._children[t];
					}
					getChildIndex(t) {
						return this._children.indexOf(t);
					}
					getChildren() {
						return this._children[Symbol.iterator]();
					}
					_insertChild(t, e) {
						this._fireChange("children", this);
						let n = 0;
						const o = (function (t, e) {
							if ("string" == typeof e) return [new go(t, e)];
							Qn(e) || (e = [e]);
							return Array.from(e).map((e) =>
								"string" == typeof e
									? new go(t, e)
									: e instanceof fo
										? new go(t, e.data)
										: e,
							);
						})(this.document, e);
						for (const e of o)
							null !== e.parent && e._remove(),
								(e.parent = this),
								this._children.splice(t, 0, e),
								t++,
								n++;
						return n;
					}
					_removeChildren(t, e = 1) {
						this._fireChange("children", this);
						for (let n = t; n < t + e; n++) this._children[n].parent = null;
						return this._children.splice(t, e);
					}
					_fireChange(t, e) {
						this.fire("change:" + t, e);
					}
				}
				sr.prototype.is = function (t) {
					return "documentFragment" === t || "view:documentFragment" === t;
				};
				class ar {
					constructor(t) {
						(this.document = t),
							(this._cloneGroups = new Map()),
							(this._slotFactory = null);
					}
					setSelection(...t) {
						this.document.selection._setTo(...t);
					}
					setSelectionFocus(...t) {
						this.document.selection._setFocus(...t);
					}
					createDocumentFragment(t) {
						return new sr(this.document, t);
					}
					createText(t) {
						return new go(this.document, t);
					}
					createAttributeElement(t, e, n = {}) {
						const o = new Ni(this.document, t, e);
						return (
							"number" == typeof n.priority && (o._priority = n.priority),
							n.id && (o._id = n.id),
							n.renderUnsafeAttributes &&
								o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes),
							o
						);
					}
					createContainerElement(t, e, n = {}, o = {}) {
						let i = null;
						it(n) ? (o = n) : (i = n);
						const r = new bi(this.document, t, e, i);
						return (
							o.renderUnsafeAttributes &&
								r._unsafeAttributesToRender.push(...o.renderUnsafeAttributes),
							r
						);
					}
					createEditableElement(t, e, n = {}) {
						const o = new Ai(this.document, t, e);
						return (
							n.renderUnsafeAttributes &&
								o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes),
							o
						);
					}
					createEmptyElement(t, e, n = {}) {
						const o = new ji(this.document, t, e);
						return (
							n.renderUnsafeAttributes &&
								o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes),
							o
						);
					}
					createUIElement(t, e, n) {
						const o = new er(this.document, t, e);
						return n && (o.render = n), o;
					}
					createRawElement(t, e, n, o = {}) {
						const i = new ir(this.document, t, e);
						return (
							n && (i.render = n),
							o.renderUnsafeAttributes &&
								i._unsafeAttributesToRender.push(...o.renderUnsafeAttributes),
							i
						);
					}
					setAttribute(t, e, n) {
						n._setAttribute(t, e);
					}
					removeAttribute(t, e) {
						e._removeAttribute(t);
					}
					addClass(t, e) {
						e._addClass(t);
					}
					removeClass(t, e) {
						e._removeClass(t);
					}
					setStyle(t, e, n) {
						it(t) && void 0 === n ? e._setStyle(t) : n._setStyle(t, e);
					}
					removeStyle(t, e) {
						e._removeStyle(t);
					}
					setCustomProperty(t, e, n) {
						n._setCustomProperty(t, e);
					}
					removeCustomProperty(t, e) {
						return e._removeCustomProperty(t);
					}
					breakAttributes(t) {
						return t instanceof yi
							? this._breakAttributes(t)
							: this._breakAttributesRange(t);
					}
					breakContainer(t) {
						const e = t.parent;
						if (!e.is("containerElement"))
							throw new l.a(
								"view-writer-break-non-container-element",
								this.document,
							);
						if (!e.parent)
							throw new l.a("view-writer-break-root", this.document);
						if (t.isAtStart) return yi._createBefore(e);
						if (!t.isAtEnd) {
							const n = e._clone(!1);
							this.insert(yi._createAfter(e), n);
							const o = new xi(t, yi._createAt(e, "end")),
								i = new yi(n, 0);
							this.move(o, i);
						}
						return yi._createAfter(e);
					}
					mergeAttributes(t) {
						const e = t.offset,
							n = t.parent;
						if (n.is("$text")) return t;
						if (n.is("attributeElement") && 0 === n.childCount) {
							const t = n.parent,
								e = n.index;
							return (
								n._remove(),
								this._removeFromClonedElementsGroup(n),
								this.mergeAttributes(new yi(t, e))
							);
						}
						const o = n.getChild(e - 1),
							i = n.getChild(e);
						if (!o || !i) return t;
						if (o.is("$text") && i.is("$text")) return hr(o, i);
						if (
							o.is("attributeElement") &&
							i.is("attributeElement") &&
							o.isSimilar(i)
						) {
							const t = o.childCount;
							return (
								o._appendChild(i.getChildren()),
								i._remove(),
								this._removeFromClonedElementsGroup(i),
								this.mergeAttributes(new yi(o, t))
							);
						}
						return t;
					}
					mergeContainers(t) {
						const e = t.nodeBefore,
							n = t.nodeAfter;
						if (
							!(e && n && e.is("containerElement") && n.is("containerElement"))
						)
							throw new l.a(
								"view-writer-merge-containers-invalid-position",
								this.document,
							);
						const o = e.getChild(e.childCount - 1),
							i =
								o instanceof go
									? yi._createAt(o, "end")
									: yi._createAt(e, "end");
						return (
							this.move(xi._createIn(n), yi._createAt(e, "end")),
							this.remove(xi._createOn(n)),
							i
						);
					}
					insert(t, e) {
						gr((e = Qn(e) ? [...e] : [e]), this.document);
						const n = e.reduce((t, e) => {
							const n = t[t.length - 1],
								o = !e.is("uiElement");
							return (
								n && n.breakAttributes == o
									? n.nodes.push(e)
									: t.push({ breakAttributes: o, nodes: [e] }),
								t
							);
						}, []);
						let o = null,
							i = t;
						for (const { nodes: t, breakAttributes: e } of n) {
							const n = this._insertNodes(i, t, e);
							o || (o = n.start), (i = n.end);
						}
						return o ? new xi(o, i) : new xi(t);
					}
					remove(t) {
						const e = t instanceof xi ? t : xi._createOn(t);
						if ((mr(e, this.document), e.isCollapsed))
							return new sr(this.document);
						const { start: n, end: o } = this._breakAttributesRange(e, !0),
							i = n.parent,
							r = o.offset - n.offset,
							s = i._removeChildren(n.offset, r);
						for (const t of s) this._removeFromClonedElementsGroup(t);
						const a = this.mergeAttributes(n);
						return (e.start = a), (e.end = a.clone()), new sr(this.document, s);
					}
					clear(t, e) {
						mr(t, this.document);
						const n = t.getWalker({
							direction: "backward",
							ignoreElementEnd: !0,
						});
						for (const o of n) {
							const n = o.item;
							let i;
							if (n.is("element") && e.isSimilar(n)) i = xi._createOn(n);
							else if (!o.nextPosition.isAfter(t.start) && n.is("$textProxy")) {
								const t = n
									.getAncestors()
									.find((t) => t.is("element") && e.isSimilar(t));
								t && (i = xi._createIn(t));
							}
							i &&
								(i.end.isAfter(t.end) && (i.end = t.end),
								i.start.isBefore(t.start) && (i.start = t.start),
								this.remove(i));
						}
					}
					move(t, e) {
						let n;
						if (e.isAfter(t.end)) {
							const o = (e = this._breakAttributes(e, !0)).parent,
								i = o.childCount;
							(t = this._breakAttributesRange(t, !0)),
								(n = this.remove(t)),
								(e.offset += o.childCount - i);
						} else n = this.remove(t);
						return this.insert(e, n);
					}
					wrap(t, e) {
						if (!(e instanceof Ni))
							throw new l.a(
								"view-writer-wrap-invalid-attribute",
								this.document,
							);
						if ((mr(t, this.document), t.isCollapsed)) {
							let o = t.start;
							o.parent.is("element") &&
								((n = o.parent),
								!Array.from(n.getChildren()).some((t) => !t.is("uiElement"))) &&
								(o = o.getLastMatchingPosition((t) => t.item.is("uiElement"))),
								(o = this._wrapPosition(o, e));
							const i = this.document.selection;
							return (
								i.isCollapsed &&
									i.getFirstPosition().isEqual(t.start) &&
									this.setSelection(o),
								new xi(o)
							);
						}
						return this._wrapRange(t, e);
						var n;
					}
					unwrap(t, e) {
						if (!(e instanceof Ni))
							throw new l.a(
								"view-writer-unwrap-invalid-attribute",
								this.document,
							);
						if ((mr(t, this.document), t.isCollapsed)) return t;
						const { start: n, end: o } = this._breakAttributesRange(t, !0),
							i = n.parent,
							r = this._unwrapChildren(i, n.offset, o.offset, e),
							s = this.mergeAttributes(r.start);
						s.isEqual(r.start) || r.end.offset--;
						const a = this.mergeAttributes(r.end);
						return new xi(s, a);
					}
					rename(t, e) {
						const n = new bi(this.document, t, e.getAttributes());
						return (
							this.insert(yi._createAfter(e), n),
							this.move(xi._createIn(e), yi._createAt(n, 0)),
							this.remove(xi._createOn(e)),
							n
						);
					}
					clearClonedElementsGroup(t) {
						this._cloneGroups.delete(t);
					}
					createPositionAt(t, e) {
						return yi._createAt(t, e);
					}
					createPositionAfter(t) {
						return yi._createAfter(t);
					}
					createPositionBefore(t) {
						return yi._createBefore(t);
					}
					createRange(...t) {
						return new xi(...t);
					}
					createRangeOn(t) {
						return xi._createOn(t);
					}
					createRangeIn(t) {
						return xi._createIn(t);
					}
					createSelection(...t) {
						return new Si(...t);
					}
					createSlot(t) {
						if (!this._slotFactory)
							throw new l.a(
								"view-writer-invalid-create-slot-context",
								this.document,
							);
						return this._slotFactory(this, t);
					}
					_registerSlotFactory(t) {
						this._slotFactory = t;
					}
					_clearSlotFactory() {
						this._slotFactory = null;
					}
					_insertNodes(t, e, n) {
						let o, i;
						if (
							((o = n
								? cr(t)
								: t.parent.is("$text")
									? t.parent.parent
									: t.parent),
							!o)
						)
							throw new l.a(
								"view-writer-invalid-position-container",
								this.document,
							);
						i = n
							? this._breakAttributes(t, !0)
							: t.parent.is("$text")
								? ur(t)
								: t;
						const r = o._insertChild(i.offset, e);
						for (const t of e) this._addToClonedElementsGroup(t);
						const s = i.getShiftedBy(r),
							a = this.mergeAttributes(i);
						a.isEqual(i) || s.offset--;
						const c = this.mergeAttributes(s);
						return new xi(a, c);
					}
					_wrapChildren(t, e, n, o) {
						let i = e;
						const r = [];
						for (; i < n; ) {
							const e = t.getChild(i),
								n = e.is("$text"),
								s = e.is("attributeElement");
							if (s && this._wrapAttributeElement(o, e)) r.push(new yi(t, i));
							else if (n || !s || lr(o, e)) {
								const n = o._clone();
								e._remove(),
									n._appendChild(e),
									t._insertChild(i, n),
									this._addToClonedElementsGroup(n),
									r.push(new yi(t, i));
							} else this._wrapChildren(e, 0, e.childCount, o);
							i++;
						}
						let s = 0;
						for (const t of r) {
							if (((t.offset -= s), t.offset == e)) continue;
							this.mergeAttributes(t).isEqual(t) || (s++, n--);
						}
						return xi._createFromParentsAndOffsets(t, e, t, n);
					}
					_unwrapChildren(t, e, n, o) {
						let i = e;
						const r = [];
						for (; i < n; ) {
							const e = t.getChild(i);
							if (e.is("attributeElement"))
								if (e.isSimilar(o)) {
									const o = e.getChildren(),
										s = e.childCount;
									e._remove(),
										t._insertChild(i, o),
										this._removeFromClonedElementsGroup(e),
										r.push(new yi(t, i), new yi(t, i + s)),
										(i += s),
										(n += s - 1);
								} else
									this._unwrapAttributeElement(o, e)
										? (r.push(new yi(t, i), new yi(t, i + 1)), i++)
										: (this._unwrapChildren(e, 0, e.childCount, o), i++);
							else i++;
						}
						let s = 0;
						for (const t of r) {
							if (((t.offset -= s), t.offset == e || t.offset == n)) continue;
							this.mergeAttributes(t).isEqual(t) || (s++, n--);
						}
						return xi._createFromParentsAndOffsets(t, e, t, n);
					}
					_wrapRange(t, e) {
						const { start: n, end: o } = this._breakAttributesRange(t, !0),
							i = n.parent,
							r = this._wrapChildren(i, n.offset, o.offset, e),
							s = this.mergeAttributes(r.start);
						s.isEqual(r.start) || r.end.offset--;
						const a = this.mergeAttributes(r.end);
						return new xi(s, a);
					}
					_wrapPosition(t, e) {
						if (e.isSimilar(t.parent)) return dr(t.clone());
						t.parent.is("$text") && (t = ur(t));
						const n = this.createAttributeElement("_wrapPosition-fake-element");
						(n._priority = Number.POSITIVE_INFINITY),
							(n.isSimilar = () => !1),
							t.parent._insertChild(t.offset, n);
						const o = new xi(t, t.getShiftedBy(1));
						this.wrap(o, e);
						const i = new yi(n.parent, n.index);
						n._remove();
						const r = i.nodeBefore,
							s = i.nodeAfter;
						return r instanceof go && s instanceof go ? hr(r, s) : dr(i);
					}
					_wrapAttributeElement(t, e) {
						if (!kr(t, e)) return !1;
						if (t.name !== e.name || t.priority !== e.priority) return !1;
						for (const n of t.getAttributeKeys())
							if (
								"class" !== n &&
								"style" !== n &&
								e.hasAttribute(n) &&
								e.getAttribute(n) !== t.getAttribute(n)
							)
								return !1;
						for (const n of t.getStyleNames())
							if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) return !1;
						for (const n of t.getAttributeKeys())
							"class" !== n &&
								"style" !== n &&
								(e.hasAttribute(n) ||
									this.setAttribute(n, t.getAttribute(n), e));
						for (const n of t.getStyleNames())
							e.hasStyle(n) || this.setStyle(n, t.getStyle(n), e);
						for (const n of t.getClassNames())
							e.hasClass(n) || this.addClass(n, e);
						return !0;
					}
					_unwrapAttributeElement(t, e) {
						if (!kr(t, e)) return !1;
						if (t.name !== e.name || t.priority !== e.priority) return !1;
						for (const n of t.getAttributeKeys())
							if (
								"class" !== n &&
								"style" !== n &&
								(!e.hasAttribute(n) || e.getAttribute(n) !== t.getAttribute(n))
							)
								return !1;
						if (!e.hasClass(...t.getClassNames())) return !1;
						for (const n of t.getStyleNames())
							if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) return !1;
						for (const n of t.getAttributeKeys())
							"class" !== n && "style" !== n && this.removeAttribute(n, e);
						return (
							this.removeClass(Array.from(t.getClassNames()), e),
							this.removeStyle(Array.from(t.getStyleNames()), e),
							!0
						);
					}
					_breakAttributesRange(t, e = !1) {
						const n = t.start,
							o = t.end;
						if ((mr(t, this.document), t.isCollapsed)) {
							const n = this._breakAttributes(t.start, e);
							return new xi(n, n);
						}
						const i = this._breakAttributes(o, e),
							r = i.parent.childCount,
							s = this._breakAttributes(n, e);
						return (i.offset += i.parent.childCount - r), new xi(s, i);
					}
					_breakAttributes(t, e = !1) {
						const n = t.offset,
							o = t.parent;
						if (t.parent.is("emptyElement"))
							throw new l.a(
								"view-writer-cannot-break-empty-element",
								this.document,
							);
						if (t.parent.is("uiElement"))
							throw new l.a(
								"view-writer-cannot-break-ui-element",
								this.document,
							);
						if (t.parent.is("rawElement"))
							throw new l.a(
								"view-writer-cannot-break-raw-element",
								this.document,
							);
						if (!e && o.is("$text") && fr(o.parent)) return t.clone();
						if (fr(o)) return t.clone();
						if (o.is("$text")) return this._breakAttributes(ur(t), e);
						if (n == o.childCount) {
							const t = new yi(o.parent, o.index + 1);
							return this._breakAttributes(t, e);
						}
						if (0 === n) {
							const t = new yi(o.parent, o.index);
							return this._breakAttributes(t, e);
						}
						{
							const t = o.index + 1,
								i = o._clone();
							o.parent._insertChild(t, i), this._addToClonedElementsGroup(i);
							const r = o.childCount - n,
								s = o._removeChildren(n, r);
							i._appendChild(s);
							const a = new yi(o.parent, t);
							return this._breakAttributes(a, e);
						}
					}
					_addToClonedElementsGroup(t) {
						if (!t.root.is("rootElement")) return;
						if (t.is("element"))
							for (const e of t.getChildren())
								this._addToClonedElementsGroup(e);
						const e = t.id;
						if (!e) return;
						let n = this._cloneGroups.get(e);
						n || ((n = new Set()), this._cloneGroups.set(e, n)),
							n.add(t),
							(t._clonesGroup = n);
					}
					_removeFromClonedElementsGroup(t) {
						if (t.is("element"))
							for (const e of t.getChildren())
								this._removeFromClonedElementsGroup(e);
						const e = t.id;
						if (!e) return;
						const n = this._cloneGroups.get(e);
						n && n.delete(t);
					}
				}
				function cr(t) {
					let e = t.parent;
					for (; !fr(e); ) {
						if (!e) return;
						e = e.parent;
					}
					return e;
				}
				function lr(t, e) {
					return (
						t.priority < e.priority ||
						(!(t.priority > e.priority) && t.getIdentity() < e.getIdentity())
					);
				}
				function dr(t) {
					const e = t.nodeBefore;
					if (e && e.is("$text")) return new yi(e, e.data.length);
					const n = t.nodeAfter;
					return n && n.is("$text") ? new yi(n, 0) : t;
				}
				function ur(t) {
					if (t.offset == t.parent.data.length)
						return new yi(t.parent.parent, t.parent.index + 1);
					if (0 === t.offset) return new yi(t.parent.parent, t.parent.index);
					const e = t.parent.data.slice(t.offset);
					return (
						(t.parent._data = t.parent.data.slice(0, t.offset)),
						t.parent.parent._insertChild(
							t.parent.index + 1,
							new go(t.root.document, e),
						),
						new yi(t.parent.parent, t.parent.index + 1)
					);
				}
				function hr(t, e) {
					const n = t.data.length;
					return (t._data += e.data), e._remove(), new yi(t, n);
				}
				const pr = [go, Ni, bi, ji, ir, er];
				function gr(t, e) {
					for (const n of t) {
						if (!pr.some((t) => n instanceof t))
							throw new l.a("view-writer-insert-invalid-node-type", e);
						n.is("$text") || gr(n.getChildren(), e);
					}
				}
				function fr(t) {
					return t && (t.is("containerElement") || t.is("documentFragment"));
				}
				function mr(t, e) {
					const n = cr(t.start),
						o = cr(t.end);
					if (!n || !o || n !== o)
						throw new l.a("view-writer-invalid-range-container", e);
				}
				function kr(t, e) {
					return null === t.id && null === e.id;
				}
				function br(t) {
					return "[object Text]" == Object.prototype.toString.call(t);
				}
				const wr = (t) => t.createTextNode(" "),
					Ar = (t) => {
						const e = t.createElement("span");
						return (e.dataset.ckeFiller = "true"), (e.innerText = " "), e;
					},
					_r = (t) => {
						const e = t.createElement("br");
						return (e.dataset.ckeFiller = "true"), e;
					},
					Cr = "⁠".repeat(7);
				function vr(t) {
					return br(t) && t.data.substr(0, 7) === Cr;
				}
				function yr(t) {
					return 7 == t.data.length && vr(t);
				}
				function xr(t) {
					return vr(t) ? t.data.slice(7) : t.data;
				}
				function Dr(t, e) {
					if (e.keyCode == Ji.arrowleft) {
						const t = e.domTarget.ownerDocument.defaultView.getSelection();
						if (1 == t.rangeCount && t.getRangeAt(0).collapsed) {
							const e = t.getRangeAt(0).startContainer,
								n = t.getRangeAt(0).startOffset;
							vr(e) && n <= 7 && t.collapse(e, 0);
						}
					}
				}
				function Er(t, e, n, o = !1) {
					n =
						n ||
						function (t, e) {
							return t === e;
						};
					const i = Array.isArray(t) ? t : Array.prototype.slice.call(t),
						r = Array.isArray(e) ? e : Array.prototype.slice.call(e),
						s = (function (t, e, n) {
							const o = Sr(t, e, n);
							if (-1 === o)
								return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
							const i = Br(t, o),
								r = Br(e, o),
								s = Sr(i, r, n),
								a = t.length - s,
								c = e.length - s;
							return { firstIndex: o, lastIndexOld: a, lastIndexNew: c };
						})(i, r, n);
					return o
						? (function (t, e) {
								const { firstIndex: n, lastIndexOld: o, lastIndexNew: i } = t;
								if (-1 === n) return Array(e).fill("equal");
								let r = [];
								n > 0 && (r = r.concat(Array(n).fill("equal")));
								i - n > 0 && (r = r.concat(Array(i - n).fill("insert")));
								o - n > 0 && (r = r.concat(Array(o - n).fill("delete")));
								i < e && (r = r.concat(Array(e - i).fill("equal")));
								return r;
							})(s, r.length)
						: (function (t, e) {
								const n = [],
									{ firstIndex: o, lastIndexOld: i, lastIndexNew: r } = e;
								r - o > 0 &&
									n.push({ index: o, type: "insert", values: t.slice(o, r) });
								i - o > 0 &&
									n.push({
										index: o + (r - o),
										type: "delete",
										howMany: i - o,
									});
								return n;
							})(r, s);
				}
				function Sr(t, e, n) {
					for (let o = 0; o < Math.max(t.length, e.length); o++)
						if (void 0 === t[o] || void 0 === e[o] || !n(t[o], e[o])) return o;
					return -1;
				}
				function Br(t, e) {
					return t.slice(e).reverse();
				}
				function Tr(t, e, n) {
					n =
						n ||
						function (t, e) {
							return t === e;
						};
					const o = t.length,
						i = e.length;
					if (o > 200 || i > 200 || o + i > 300)
						return Tr.fastDiff(t, e, n, !0);
					let r, s;
					if (i < o) {
						const n = t;
						(t = e), (e = n), (r = "delete"), (s = "insert");
					} else (r = "insert"), (s = "delete");
					const a = t.length,
						c = e.length,
						l = c - a,
						d = {},
						u = {};
					function h(o) {
						const i = (void 0 !== u[o - 1] ? u[o - 1] : -1) + 1,
							l = void 0 !== u[o + 1] ? u[o + 1] : -1,
							h = i > l ? -1 : 1;
						d[o + h] && (d[o] = d[o + h].slice(0)),
							d[o] || (d[o] = []),
							d[o].push(i > l ? r : s);
						let p = Math.max(i, l),
							g = p - o;
						for (; g < a && p < c && n(t[g], e[p]); )
							g++, p++, d[o].push("equal");
						return p;
					}
					let p,
						g = 0;
					do {
						for (p = -g; p < l; p++) u[p] = h(p);
						for (p = l + g; p > l; p--) u[p] = h(p);
						(u[l] = h(l)), g++;
					} while (u[l] !== c);
					return d[l].slice(1);
				}
				function Pr(t, e, n) {
					t.insertBefore(n, t.childNodes[e] || null);
				}
				function Fr(t) {
					const e = t.parentNode;
					e && e.removeChild(t);
				}
				function Ir(t) {
					return t && t.nodeType === Node.COMMENT_NODE;
				}
				function zr(t) {
					if (t) {
						if (t.defaultView) return t instanceof t.defaultView.Document;
						if (t.ownerDocument && t.ownerDocument.defaultView)
							return t instanceof t.ownerDocument.defaultView.Node;
					}
					return !1;
				}
				Tr.fastDiff = Er;
				var Rr = n(1),
					Or = n.n(Rr),
					Mr = n(15),
					Nr = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Mr.a, Nr), Mr.a.locals;
				class Vr extends B {
					constructor(t, e) {
						super(),
							(this.domDocuments = new Set()),
							(this.domConverter = t),
							(this.markedAttributes = new Set()),
							(this.markedChildren = new Set()),
							(this.markedTexts = new Set()),
							(this.selection = e),
							this.set("isFocused", !1),
							this.set("isSelecting", !1),
							Ui.isBlink &&
								!Ui.isAndroid &&
								this.on("change:isSelecting", () => {
									this.isSelecting || this.render();
								}),
							this.set("isComposing", !1),
							this.on("change:isComposing", () => {
								this.isComposing || this.render();
							}),
							(this._inlineFiller = null),
							(this._fakeSelectionContainer = null);
					}
					markToSync(t, e) {
						if ("text" === t)
							this.domConverter.mapViewToDom(e.parent) &&
								this.markedTexts.add(e);
						else {
							if (!this.domConverter.mapViewToDom(e)) return;
							if ("attributes" === t) this.markedAttributes.add(e);
							else {
								if ("children" !== t)
									throw new l.a("view-renderer-unknown-type", this);
								this.markedChildren.add(e);
							}
						}
					}
					render() {
						if (this.isComposing && !Ui.isAndroid) return;
						let t = null;
						const e = !(Ui.isBlink && !Ui.isAndroid) || !this.isSelecting;
						for (const t of this.markedChildren)
							this._updateChildrenMappings(t);
						e
							? (this._inlineFiller &&
									!this._isSelectionInInlineFiller() &&
									this._removeInlineFiller(),
								this._inlineFiller
									? (t = this._getInlineFillerPosition())
									: this._needsInlineFillerAtSelection() &&
										((t = this.selection.getFirstPosition()),
										this.markedChildren.add(t.parent)))
							: this._inlineFiller &&
								this._inlineFiller.parentNode &&
								((t = this.domConverter.domPositionToView(this._inlineFiller)),
								t && t.parent.is("$text") && (t = yi._createBefore(t.parent)));
						for (const t of this.markedAttributes) this._updateAttrs(t);
						for (const e of this.markedChildren)
							this._updateChildren(e, { inlineFillerPosition: t });
						for (const e of this.markedTexts)
							!this.markedChildren.has(e.parent) &&
								this.domConverter.mapViewToDom(e.parent) &&
								this._updateText(e, { inlineFillerPosition: t });
						if (e)
							if (t) {
								const e = this.domConverter.viewPositionToDom(t),
									n = e.parent.ownerDocument;
								vr(e.parent)
									? (this._inlineFiller = e.parent)
									: (this._inlineFiller = Lr(n, e.parent, e.offset));
							} else this._inlineFiller = null;
						this._updateFocus(),
							this._updateSelection(),
							this.markedTexts.clear(),
							this.markedAttributes.clear(),
							this.markedChildren.clear();
					}
					_updateChildrenMappings(t) {
						if (!this.domConverter.mapViewToDom(t)) return;
						const e = Array.from(this.domConverter.mapViewToDom(t).childNodes),
							n = Array.from(
								this.domConverter.viewChildrenToDom(t, { withChildren: !1 }),
							),
							o = this._diffNodeLists(e, n),
							i = this._findReplaceActions(o, e, n);
						if (-1 !== i.indexOf("replace")) {
							const o = { equal: 0, insert: 0, delete: 0 };
							for (const r of i)
								if ("replace" === r) {
									const i = o.equal + o.insert,
										r = o.equal + o.delete,
										s = t.getChild(i);
									!s ||
										s.is("uiElement") ||
										s.is("rawElement") ||
										this._updateElementMappings(s, e[r]),
										Fr(n[i]),
										o.equal++;
								} else o[r]++;
						}
					}
					_updateElementMappings(t, e) {
						this.domConverter.unbindDomElement(e),
							this.domConverter.bindElements(e, t),
							this.markedChildren.add(t),
							this.markedAttributes.add(t);
					}
					_getInlineFillerPosition() {
						const t = this.selection.getFirstPosition();
						return t.parent.is("$text") ? yi._createBefore(t.parent) : t;
					}
					_isSelectionInInlineFiller() {
						if (1 != this.selection.rangeCount || !this.selection.isCollapsed)
							return !1;
						const t = this.selection.getFirstPosition(),
							e = this.domConverter.viewPositionToDom(t);
						return !!(e && br(e.parent) && vr(e.parent));
					}
					_removeInlineFiller() {
						const t = this._inlineFiller;
						if (!vr(t)) throw new l.a("view-renderer-filler-was-lost", this);
						yr(t) ? t.remove() : (t.data = t.data.substr(7)),
							(this._inlineFiller = null);
					}
					_needsInlineFillerAtSelection() {
						if (1 != this.selection.rangeCount || !this.selection.isCollapsed)
							return !1;
						const t = this.selection.getFirstPosition(),
							e = t.parent,
							n = t.offset;
						if (!this.domConverter.mapViewToDom(e.root)) return !1;
						if (!e.is("element")) return !1;
						if (
							!(function (t) {
								if ("false" == t.getAttribute("contenteditable")) return !1;
								const e = t.findAncestor((t) =>
									t.hasAttribute("contenteditable"),
								);
								return !e || "true" == e.getAttribute("contenteditable");
							})(e)
						)
							return !1;
						if (n === e.getFillerOffset()) return !1;
						const o = t.nodeBefore,
							i = t.nodeAfter;
						return (
							!(o instanceof go || i instanceof go) &&
							(!Ui.isAndroid || (!o && !i))
						);
					}
					_updateText(t, e) {
						const n = this.domConverter.findCorrespondingDomText(t);
						let o = this.domConverter.viewToDom(t).data;
						const i = e.inlineFillerPosition;
						i && i.parent == t.parent && i.offset == t.index && (o = Cr + o),
							qr(n, o);
					}
					_updateAttrs(t) {
						const e = this.domConverter.mapViewToDom(t);
						if (!e) return;
						const n = Array.from(e.attributes).map((t) => t.name),
							o = t.getAttributeKeys();
						for (const n of o)
							this.domConverter.setDomElementAttribute(
								e,
								n,
								t.getAttribute(n),
								t,
							);
						for (const o of n)
							t.hasAttribute(o) ||
								this.domConverter.removeDomElementAttribute(e, o);
					}
					_updateChildren(t, e) {
						const n = this.domConverter.mapViewToDom(t);
						if (!n) return;
						if (Ui.isAndroid) {
							let t = null;
							for (const e of Array.from(n.childNodes)) {
								if (t && br(t) && br(e)) {
									n.normalize();
									break;
								}
								t = e;
							}
						}
						const o = e.inlineFillerPosition,
							i = n.childNodes,
							r = Array.from(
								this.domConverter.viewChildrenToDom(t, { bind: !0 }),
							);
						o && o.parent === t && Lr(n.ownerDocument, r, o.offset);
						const s = this._diffNodeLists(i, r),
							a = Ui.isAndroid
								? this._findReplaceActions(s, i, r, { replaceText: !0 })
								: s;
						let c = 0;
						const l = new Set();
						for (const t of a)
							"delete" === t
								? (l.add(i[c]), Fr(i[c]))
								: ("equal" !== t && "replace" !== t) || c++;
						c = 0;
						for (const t of a)
							"insert" === t
								? (Pr(n, c, r[c]), c++)
								: "replace" === t
									? (qr(i[c], r[c].data), c++)
									: "equal" === t &&
										(this._markDescendantTextToSync(
											this.domConverter.domToView(r[c]),
										),
										c++);
						for (const t of l)
							t.parentNode || this.domConverter.unbindDomElement(t);
					}
					_diffNodeLists(t, e) {
						return Tr(
							(t = (function (t, e) {
								const n = Array.from(t);
								if (0 == n.length || !e) return n;
								n[n.length - 1] == e && n.pop();
								return n;
							})(t, this._fakeSelectionContainer)),
							e,
							$r.bind(null, this.domConverter),
						);
					}
					_findReplaceActions(t, e, n, o = {}) {
						if (-1 === t.indexOf("insert") || -1 === t.indexOf("delete"))
							return t;
						let i = [],
							r = [],
							s = [];
						const a = { equal: 0, insert: 0, delete: 0 };
						for (const c of t)
							"insert" === c
								? s.push(n[a.equal + a.insert])
								: "delete" === c
									? r.push(e[a.equal + a.delete])
									: ((i = i.concat(
											Tr(r, s, o.replaceText ? Hr : jr).map((t) =>
												"equal" === t ? "replace" : t,
											),
										)),
										i.push("equal"),
										(r = []),
										(s = [])),
								a[c]++;
						return i.concat(
							Tr(r, s, o.replaceText ? Hr : jr).map((t) =>
								"equal" === t ? "replace" : t,
							),
						);
					}
					_markDescendantTextToSync(t) {
						if (t)
							if (t.is("$text")) this.markedTexts.add(t);
							else if (t.is("element"))
								for (const e of t.getChildren())
									this._markDescendantTextToSync(e);
					}
					_updateSelection() {
						if (
							Ui.isBlink &&
							!Ui.isAndroid &&
							this.isSelecting &&
							!this.markedChildren.size
						)
							return;
						if (0 === this.selection.rangeCount)
							return (
								this._removeDomSelection(), void this._removeFakeSelection()
							);
						const t = this.domConverter.mapViewToDom(
							this.selection.editableElement,
						);
						this.isFocused &&
							t &&
							(this.selection.isFake
								? this._updateFakeSelection(t)
								: this._fakeSelectionContainer &&
										this._fakeSelectionContainer.isConnected
									? (this._removeFakeSelection(), this._updateDomSelection(t))
									: (this.isComposing && Ui.isAndroid) ||
										this._updateDomSelection(t));
					}
					_updateFakeSelection(t) {
						const e = t.ownerDocument;
						this._fakeSelectionContainer ||
							(this._fakeSelectionContainer = (function (t) {
								const e = t.createElement("div");
								return (
									(e.className = "ck-fake-selection-container"),
									Object.assign(e.style, {
										position: "fixed",
										top: 0,
										left: "-9999px",
										width: "42px",
									}),
									(e.textContent = " "),
									e
								);
							})(e));
						const n = this._fakeSelectionContainer;
						if (
							(this.domConverter.bindFakeSelection(n, this.selection),
							!this._fakeSelectionNeedsUpdate(t))
						)
							return;
						(n.parentElement && n.parentElement == t) || t.appendChild(n),
							(n.textContent = this.selection.fakeSelectionLabel || " ");
						const o = e.getSelection(),
							i = e.createRange();
						o.removeAllRanges(), i.selectNodeContents(n), o.addRange(i);
					}
					_updateDomSelection(t) {
						const e = t.ownerDocument.defaultView.getSelection();
						if (!this._domSelectionNeedsUpdate(e)) return;
						const n = this.domConverter.viewPositionToDom(
								this.selection.anchor,
							),
							o = this.domConverter.viewPositionToDom(this.selection.focus);
						e.collapse(n.parent, n.offset),
							e.extend(o.parent, o.offset),
							Ui.isGecko &&
								(function (t, e) {
									const n = t.parent;
									if (
										n.nodeType != Node.ELEMENT_NODE ||
										t.offset != n.childNodes.length - 1
									)
										return;
									const o = n.childNodes[t.offset];
									o && "BR" == o.tagName && e.addRange(e.getRangeAt(0));
								})(o, e);
					}
					_domSelectionNeedsUpdate(t) {
						if (!this.domConverter.isDomSelectionCorrect(t)) return !0;
						const e = t && this.domConverter.domSelectionToView(t);
						return (
							(!e || !this.selection.isEqual(e)) &&
							!(!this.selection.isCollapsed && this.selection.isSimilar(e))
						);
					}
					_fakeSelectionNeedsUpdate(t) {
						const e = this._fakeSelectionContainer,
							n = t.ownerDocument.getSelection();
						return (
							!e ||
							e.parentElement !== t ||
							(n.anchorNode !== e && !e.contains(n.anchorNode)) ||
							e.textContent !== this.selection.fakeSelectionLabel
						);
					}
					_removeDomSelection() {
						for (const t of this.domDocuments) {
							const e = t.getSelection();
							if (e.rangeCount) {
								const n = t.activeElement,
									o = this.domConverter.mapDomToView(n);
								n && o && e.removeAllRanges();
							}
						}
					}
					_removeFakeSelection() {
						const t = this._fakeSelectionContainer;
						t && t.remove();
					}
					_updateFocus() {
						if (this.isFocused) {
							const t = this.selection.editableElement;
							t && this.domConverter.focus(t);
						}
					}
				}
				function Lr(t, e, n) {
					const o = e instanceof Array ? e : e.childNodes,
						i = o[n];
					if (br(i)) return (i.data = Cr + i.data), i;
					{
						const i = t.createTextNode(Cr);
						return Array.isArray(e) ? o.splice(n, 0, i) : Pr(e, n, i), i;
					}
				}
				function jr(t, e) {
					return (
						zr(t) &&
						zr(e) &&
						!br(t) &&
						!br(e) &&
						!Ir(t) &&
						!Ir(e) &&
						t.tagName.toLowerCase() === e.tagName.toLowerCase()
					);
				}
				function Hr(t, e) {
					return zr(t) && zr(e) && br(t) && br(e);
				}
				function $r(t, e, n) {
					return (
						e === n ||
						(br(e) && br(n)
							? e.data === n.data
							: !(!t.isBlockFiller(e) || !t.isBlockFiller(n)))
					);
				}
				function qr(t, e) {
					const n = t.data;
					if (n == e) return;
					const o = Er(n, e);
					for (const e of o)
						"insert" === e.type
							? t.insertData(e.index, e.values.join(""))
							: t.deleteData(e.index, e.howMany);
				}
				function Ur(t) {
					let e = 0;
					for (; t.previousSibling; ) (t = t.previousSibling), e++;
					return e;
				}
				function Wr(t) {
					const e = [];
					let n = t;
					for (; n && n.nodeType != Node.DOCUMENT_NODE; )
						e.unshift(n), (n = n.parentNode);
					return e;
				}
				const Kr = _r(no.document),
					Gr = wr(no.document),
					Jr = Ar(no.document),
					Yr = "data-ck-unsafe-attribute-",
					Qr = "data-ck-unsafe-element";
				class Xr {
					constructor(t, e = {}) {
						(this.document = t),
							(this.renderingMode = e.renderingMode || "editing"),
							(this.blockFillerMode =
								e.blockFillerMode ||
								("editing" === this.renderingMode ? "br" : "nbsp")),
							(this.preElements = ["pre"]),
							(this.blockElements = [
								"address",
								"article",
								"aside",
								"blockquote",
								"caption",
								"center",
								"dd",
								"details",
								"dir",
								"div",
								"dl",
								"dt",
								"fieldset",
								"figcaption",
								"figure",
								"footer",
								"form",
								"h1",
								"h2",
								"h3",
								"h4",
								"h5",
								"h6",
								"header",
								"hgroup",
								"legend",
								"li",
								"main",
								"menu",
								"nav",
								"ol",
								"p",
								"pre",
								"section",
								"summary",
								"table",
								"tbody",
								"td",
								"tfoot",
								"th",
								"thead",
								"tr",
								"ul",
							]),
							(this.inlineObjectElements = [
								"object",
								"iframe",
								"input",
								"button",
								"textarea",
								"select",
								"option",
								"video",
								"embed",
								"audio",
								"img",
								"canvas",
							]),
							(this.unsafeElements = ["script", "style"]),
							(this._domDocument =
								"editing" === this.renderingMode
									? no.document
									: no.document.implementation.createHTMLDocument("")),
							(this._domToViewMapping = new WeakMap()),
							(this._viewToDomMapping = new WeakMap()),
							(this._fakeSelectionMapping = new WeakMap()),
							(this._rawContentElementMatcher = new ko()),
							(this._encounteredRawContentDomNodes = new WeakSet());
					}
					bindFakeSelection(t, e) {
						this._fakeSelectionMapping.set(t, new Si(e));
					}
					fakeSelectionToView(t) {
						return this._fakeSelectionMapping.get(t);
					}
					bindElements(t, e) {
						this._domToViewMapping.set(t, e), this._viewToDomMapping.set(e, t);
					}
					unbindDomElement(t) {
						const e = this._domToViewMapping.get(t);
						if (e) {
							this._domToViewMapping.delete(t),
								this._viewToDomMapping.delete(e);
							for (const e of Array.from(t.children)) this.unbindDomElement(e);
						}
					}
					bindDocumentFragments(t, e) {
						this._domToViewMapping.set(t, e), this._viewToDomMapping.set(e, t);
					}
					shouldRenderAttribute(t, e, n) {
						return (
							"data" === this.renderingMode ||
							(!(t = t.toLowerCase()).startsWith("on") &&
								("srcdoc" !== t ||
									!e.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) &&
								(("img" === n && ("src" === t || "srcset" === t)) ||
									("source" === n && "srcset" === t) ||
									!e.match(
										/^\s*(javascript:|data:(image\/svg|text\/x?html))/i,
									)))
						);
					}
					setContentOf(t, e) {
						if ("data" === this.renderingMode) return void (t.innerHTML = e);
						const n = new DOMParser().parseFromString(e, "text/html"),
							o = n.createDocumentFragment(),
							i = n.body.childNodes;
						for (; i.length > 0; ) o.appendChild(i[0]);
						const r = n.createTreeWalker(o, NodeFilter.SHOW_ELEMENT),
							s = [];
						let a;
						for (; (a = r.nextNode()); ) s.push(a);
						for (const t of s) {
							for (const e of t.getAttributeNames())
								this.setDomElementAttribute(t, e, t.getAttribute(e));
							const e = t.tagName.toLowerCase();
							this._shouldRenameElement(e) &&
								(es(e), t.replaceWith(this._createReplacementDomElement(e, t)));
						}
						for (; t.firstChild; ) t.firstChild.remove();
						t.append(o);
					}
					viewToDom(t, e = {}) {
						if (t.is("$text")) {
							const e = this._processDataFromViewText(t);
							return this._domDocument.createTextNode(e);
						}
						{
							if (this.mapViewToDom(t)) return this.mapViewToDom(t);
							let n;
							if (t.is("documentFragment"))
								(n = this._domDocument.createDocumentFragment()),
									e.bind && this.bindDocumentFragments(n, t);
							else {
								if (t.is("uiElement"))
									return (
										(n =
											"$comment" === t.name
												? this._domDocument.createComment(
														t.getCustomProperty("$rawContent"),
													)
												: t.render(this._domDocument, this)),
										e.bind && this.bindElements(n, t),
										n
									);
								this._shouldRenameElement(t.name)
									? (es(t.name),
										(n = this._createReplacementDomElement(t.name)))
									: (n = t.hasAttribute("xmlns")
											? this._domDocument.createElementNS(
													t.getAttribute("xmlns"),
													t.name,
												)
											: this._domDocument.createElement(t.name)),
									t.is("rawElement") && t.render(n, this),
									e.bind && this.bindElements(n, t);
								for (const e of t.getAttributeKeys())
									this.setDomElementAttribute(n, e, t.getAttribute(e), t);
							}
							if (!1 !== e.withChildren)
								for (const o of this.viewChildrenToDom(t, e)) n.appendChild(o);
							return n;
						}
					}
					setDomElementAttribute(t, e, n, o) {
						const i =
							this.shouldRenderAttribute(e, n, t.tagName.toLowerCase()) ||
							(o && o.shouldRenderUnsafeAttribute(e));
						i ||
							Object(l.b)("domconverter-unsafe-attribute-detected", {
								domElement: t,
								key: e,
								value: n,
							}),
							t.hasAttribute(e) && !i
								? t.removeAttribute(e)
								: t.hasAttribute(Yr + e) && i && t.removeAttribute(Yr + e),
							t.setAttribute(i ? e : Yr + e, n);
					}
					removeDomElementAttribute(t, e) {
						e != Qr && (t.removeAttribute(e), t.removeAttribute(Yr + e));
					}
					*viewChildrenToDom(t, e = {}) {
						const n = t.getFillerOffset && t.getFillerOffset();
						let o = 0;
						for (const i of t.getChildren()) {
							n === o && (yield this._getBlockFiller());
							const t =
								i.is("element") &&
								i.getCustomProperty("dataPipeline:transparentRendering");
							t && "data" == this.renderingMode
								? yield* this.viewChildrenToDom(i, e)
								: (t &&
										Object(l.b)(
											"domconverter-transparent-rendering-unsupported-in-editing-pipeline",
											{ viewElement: i },
										),
									yield this.viewToDom(i, e)),
								o++;
						}
						n === o && (yield this._getBlockFiller());
					}
					viewRangeToDom(t) {
						const e = this.viewPositionToDom(t.start),
							n = this.viewPositionToDom(t.end),
							o = this._domDocument.createRange();
						return (
							o.setStart(e.parent, e.offset), o.setEnd(n.parent, n.offset), o
						);
					}
					viewPositionToDom(t) {
						const e = t.parent;
						if (e.is("$text")) {
							const n = this.findCorrespondingDomText(e);
							if (!n) return null;
							let o = t.offset;
							return vr(n) && (o += 7), { parent: n, offset: o };
						}
						{
							let n, o, i;
							if (0 === t.offset) {
								if (((n = this.mapViewToDom(e)), !n)) return null;
								i = n.childNodes[0];
							} else {
								const e = t.nodeBefore;
								if (
									((o = e.is("$text")
										? this.findCorrespondingDomText(e)
										: this.mapViewToDom(e)),
									!o)
								)
									return null;
								(n = o.parentNode), (i = o.nextSibling);
							}
							if (br(i) && vr(i)) return { parent: i, offset: 7 };
							return { parent: n, offset: o ? Ur(o) + 1 : 0 };
						}
					}
					domToView(t, e = {}) {
						if (this.isBlockFiller(t)) return null;
						const n = this.getHostViewElement(t);
						if (n) return n;
						if (Ir(t) && e.skipComments) return null;
						if (br(t)) {
							if (yr(t)) return null;
							{
								const e = this._processDataFromDomText(t);
								return "" === e ? null : new go(this.document, e);
							}
						}
						{
							if (this.mapDomToView(t)) return this.mapDomToView(t);
							let n;
							if (this.isDocumentFragment(t))
								(n = new sr(this.document)),
									e.bind && this.bindDocumentFragments(t, n);
							else {
								(n = this._createViewElement(t, e)),
									e.bind && this.bindElements(t, n);
								const o = t.attributes;
								if (o)
									for (let t = o.length, e = 0; e < t; e++)
										n._setAttribute(o[e].name, o[e].value);
								if (this._isViewElementWithRawContent(n, e) || Ir(t)) {
									const e = Ir(t) ? t.data : t.innerHTML;
									return (
										n._setCustomProperty("$rawContent", e),
										this._encounteredRawContentDomNodes.add(t),
										n
									);
								}
							}
							if (!1 !== e.withChildren)
								for (const o of this.domChildrenToView(t, e)) n._appendChild(o);
							return n;
						}
					}
					*domChildrenToView(t, e) {
						for (let n = 0; n < t.childNodes.length; n++) {
							const o = t.childNodes[n],
								i = this.domToView(o, e);
							null !== i && (yield i);
						}
					}
					domSelectionToView(t) {
						if (1 === t.rangeCount) {
							let e = t.getRangeAt(0).startContainer;
							br(e) && (e = e.parentNode);
							const n = this.fakeSelectionToView(e);
							if (n) return n;
						}
						const e = this.isDomSelectionBackward(t),
							n = [];
						for (let e = 0; e < t.rangeCount; e++) {
							const o = t.getRangeAt(e),
								i = this.domRangeToView(o);
							i && n.push(i);
						}
						return new Si(n, { backward: e });
					}
					domRangeToView(t) {
						const e = this.domPositionToView(t.startContainer, t.startOffset),
							n = this.domPositionToView(t.endContainer, t.endOffset);
						return e && n ? new xi(e, n) : null;
					}
					domPositionToView(t, e = 0) {
						if (this.isBlockFiller(t))
							return this.domPositionToView(t.parentNode, Ur(t));
						const n = this.mapDomToView(t);
						if (n && (n.is("uiElement") || n.is("rawElement")))
							return yi._createBefore(n);
						if (br(t)) {
							if (yr(t)) return this.domPositionToView(t.parentNode, Ur(t));
							const n = this.findCorrespondingViewText(t);
							let o = e;
							return n
								? (vr(t) && ((o -= 7), (o = o < 0 ? 0 : o)), new yi(n, o))
								: null;
						}
						if (0 === e) {
							const e = this.mapDomToView(t);
							if (e) return new yi(e, 0);
						} else {
							const n = t.childNodes[e - 1];
							if (br(n) && yr(n))
								return this.domPositionToView(n.parentNode, Ur(n));
							const o = br(n)
								? this.findCorrespondingViewText(n)
								: this.mapDomToView(n);
							if (o && o.parent) return new yi(o.parent, o.index + 1);
						}
						return null;
					}
					mapDomToView(t) {
						return this.getHostViewElement(t) || this._domToViewMapping.get(t);
					}
					findCorrespondingViewText(t) {
						if (yr(t)) return null;
						const e = this.getHostViewElement(t);
						if (e) return e;
						const n = t.previousSibling;
						if (n) {
							if (!this.isElement(n)) return null;
							const t = this.mapDomToView(n);
							if (t) {
								const e = t.nextSibling;
								return e instanceof go ? e : null;
							}
						} else {
							const e = this.mapDomToView(t.parentNode);
							if (e) {
								const t = e.getChild(0);
								return t instanceof go ? t : null;
							}
						}
						return null;
					}
					mapViewToDom(t) {
						return this._viewToDomMapping.get(t);
					}
					findCorrespondingDomText(t) {
						const e = t.previousSibling;
						return e && this.mapViewToDom(e)
							? this.mapViewToDom(e).nextSibling
							: !e && t.parent && this.mapViewToDom(t.parent)
								? this.mapViewToDom(t.parent).childNodes[0]
								: null;
					}
					focus(t) {
						const e = this.mapViewToDom(t);
						if (e && e.ownerDocument.activeElement !== e) {
							const { scrollX: t, scrollY: n } = no.window,
								o = [];
							Zr(e, (t) => {
								const { scrollLeft: e, scrollTop: n } = t;
								o.push([e, n]);
							}),
								e.focus(),
								Zr(e, (t) => {
									const [e, n] = o.shift();
									(t.scrollLeft = e), (t.scrollTop = n);
								}),
								no.window.scrollTo(t, n);
						}
					}
					isElement(t) {
						return t && t.nodeType == Node.ELEMENT_NODE;
					}
					isDocumentFragment(t) {
						return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
					}
					isBlockFiller(t) {
						return "br" == this.blockFillerMode
							? t.isEqualNode(Kr)
							: !(
									"BR" !== t.tagName ||
									!ts(t, this.blockElements) ||
									1 !== t.parentNode.childNodes.length
								) ||
									t.isEqualNode(Jr) ||
									(function (t, e) {
										return (
											t.isEqualNode(Gr) &&
											ts(t, e) &&
											1 === t.parentNode.childNodes.length
										);
									})(t, this.blockElements);
					}
					isDomSelectionBackward(t) {
						if (t.isCollapsed) return !1;
						const e = this._domDocument.createRange();
						try {
							e.setStart(t.anchorNode, t.anchorOffset),
								e.setEnd(t.focusNode, t.focusOffset);
						} catch (t) {
							return !1;
						}
						const n = e.collapsed;
						return e.detach(), n;
					}
					getHostViewElement(t) {
						const e = Wr(t);
						for (e.pop(); e.length; ) {
							const t = e.pop(),
								n = this._domToViewMapping.get(t);
							if (n && (n.is("uiElement") || n.is("rawElement"))) return n;
						}
						return null;
					}
					isDomSelectionCorrect(t) {
						return (
							this._isDomSelectionPositionCorrect(
								t.anchorNode,
								t.anchorOffset,
							) &&
							this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset)
						);
					}
					registerRawContentMatcher(t) {
						this._rawContentElementMatcher.add(t);
					}
					_getBlockFiller() {
						switch (this.blockFillerMode) {
							case "nbsp":
								return wr(this._domDocument);
							case "markedNbsp":
								return Ar(this._domDocument);
							case "br":
								return _r(this._domDocument);
						}
					}
					_isDomSelectionPositionCorrect(t, e) {
						if (br(t) && vr(t) && e < 7) return !1;
						if (this.isElement(t) && vr(t.childNodes[e])) return !1;
						const n = this.mapDomToView(t);
						return !n || (!n.is("uiElement") && !n.is("rawElement"));
					}
					_processDataFromViewText(t) {
						let e = t.data;
						if (t.getAncestors().some((t) => this.preElements.includes(t.name)))
							return e;
						if (" " == e.charAt(0)) {
							const n = this._getTouchingInlineViewNode(t, !1);
							(!(n && n.is("$textProxy") && this._nodeEndsWithSpace(n)) && n) ||
								(e = " " + e.substr(1));
						}
						if (" " == e.charAt(e.length - 1)) {
							const n = this._getTouchingInlineViewNode(t, !0),
								o = n && n.is("$textProxy") && " " == n.data.charAt(0);
							(" " != e.charAt(e.length - 2) && n && !o) ||
								(e = e.substr(0, e.length - 1) + " ");
						}
						return e.replace(/ {2}/g, "  ");
					}
					_nodeEndsWithSpace(t) {
						if (t.getAncestors().some((t) => this.preElements.includes(t.name)))
							return !1;
						const e = this._processDataFromViewText(t);
						return " " == e.charAt(e.length - 1);
					}
					_processDataFromDomText(t) {
						let e = t.data;
						if (
							(function (t, e) {
								return Wr(t).some(
									(t) => t.tagName && e.includes(t.tagName.toLowerCase()),
								);
							})(t, this.preElements)
						)
							return xr(t);
						e = e.replace(/[ \n\t\r]{1,}/g, " ");
						const n = this._getTouchingInlineDomNode(t, !1),
							o = this._getTouchingInlineDomNode(t, !0),
							i = this._checkShouldLeftTrimDomText(t, n),
							r = this._checkShouldRightTrimDomText(t, o);
						i && (e = e.replace(/^ /, "")),
							r && (e = e.replace(/ $/, "")),
							(e = xr(new Text(e))),
							(e = e.replace(/ \u00A0/g, "  "));
						const s = o && this.isElement(o) && "BR" != o.tagName,
							a = o && br(o) && " " == o.data.charAt(0);
						return (
							(/( |\u00A0)\u00A0$/.test(e) || !o || s || a) &&
								(e = e.replace(/\u00A0$/, " ")),
							(i || (n && this.isElement(n) && "BR" != n.tagName)) &&
								(e = e.replace(/^\u00A0/, " ")),
							e
						);
					}
					_checkShouldLeftTrimDomText(t, e) {
						return (
							!e ||
							(this.isElement(e)
								? "BR" === e.tagName
								: !this._encounteredRawContentDomNodes.has(t.previousSibling) &&
									/[^\S\u00A0]/.test(e.data.charAt(e.data.length - 1)))
						);
					}
					_checkShouldRightTrimDomText(t, e) {
						return !e && !vr(t);
					}
					_getTouchingInlineViewNode(t, e) {
						const n = new vi({
							startPosition: e ? yi._createAfter(t) : yi._createBefore(t),
							direction: e ? "forward" : "backward",
						});
						for (const t of n) {
							if (
								t.item.is("element") &&
								this.inlineObjectElements.includes(t.item.name)
							)
								return t.item;
							if (t.item.is("containerElement")) return null;
							if (t.item.is("element", "br")) return null;
							if (t.item.is("$textProxy")) return t.item;
						}
						return null;
					}
					_getTouchingInlineDomNode(t, e) {
						if (!t.parentNode) return null;
						const n = e ? "firstChild" : "lastChild",
							o = e ? "nextSibling" : "previousSibling";
						let i = !0,
							r = t;
						do {
							if (
								(!i && r[n]
									? (r = r[n])
									: r[o]
										? ((r = r[o]), (i = !1))
										: ((r = r.parentNode), (i = !0)),
								!r || this._isBlockElement(r))
							)
								return null;
						} while (
							!br(r) &&
							"BR" != r.tagName &&
							!this._isInlineObjectElement(r)
						);
						return r;
					}
					_isBlockElement(t) {
						return (
							this.isElement(t) &&
							this.blockElements.includes(t.tagName.toLowerCase())
						);
					}
					_isInlineObjectElement(t) {
						return (
							this.isElement(t) &&
							this.inlineObjectElements.includes(t.tagName.toLowerCase())
						);
					}
					_createViewElement(t, e) {
						if (Ir(t)) return new er(this.document, "$comment");
						const n = e.keepOriginalCase ? t.tagName : t.tagName.toLowerCase();
						return new mi(this.document, n);
					}
					_isViewElementWithRawContent(t, e) {
						return (
							!1 !== e.withChildren && !!this._rawContentElementMatcher.match(t)
						);
					}
					_shouldRenameElement(t) {
						const e = t.toLowerCase();
						return (
							"editing" === this.renderingMode &&
							this.unsafeElements.includes(e)
						);
					}
					_createReplacementDomElement(t, e) {
						const n = this._domDocument.createElement("span");
						if ((n.setAttribute(Qr, t), e)) {
							for (; e.firstChild; ) n.appendChild(e.firstChild);
							for (const t of e.getAttributeNames())
								n.setAttribute(t, e.getAttribute(t));
						}
						return n;
					}
				}
				function Zr(t, e) {
					let n = t;
					for (; n; ) e(n), (n = n.parentElement);
				}
				function ts(t, e) {
					const n = t.parentNode;
					return !!n && !!n.tagName && e.includes(n.tagName.toLowerCase());
				}
				function es(t) {
					"script" === t &&
						Object(l.b)("domconverter-unsafe-script-element-detected"),
						"style" === t &&
							Object(l.b)("domconverter-unsafe-style-element-detected");
				}
				function ns(t) {
					const e = Object.prototype.toString.apply(t);
					return "[object Window]" == e || "[object global]" == e;
				}
				function os(t) {
					return class extends t {
						listenTo(t, e, n, o = {}) {
							if (zr(t) || ns(t)) {
								const i = { capture: !!o.useCapture, passive: !!o.usePassive },
									r = this._getProxyEmitter(t, i) || new rs(t, i);
								this.listenTo(r, e, n, o);
							} else g.prototype.listenTo.call(this, t, e, n, o);
						}
						stopListening(t, e, n) {
							if (zr(t) || ns(t)) {
								const o = this._getAllProxyEmitters(t);
								for (const t of o) this.stopListening(t, e, n);
							} else g.prototype.stopListening.call(this, t, e, n);
						}
						_getProxyEmitter(t, e) {
							return (function (t, e) {
								const n = t[d];
								return n && n[e] ? n[e].emitter : null;
							})(this, ss(t, e));
						}
						_getAllProxyEmitters(t) {
							return [
								{ capture: !1, passive: !1 },
								{ capture: !1, passive: !0 },
								{ capture: !0, passive: !1 },
								{ capture: !0, passive: !0 },
							]
								.map((e) => this._getProxyEmitter(t, e))
								.filter((t) => !!t);
						}
					};
				}
				const is = os(g);
				[
					"_getProxyEmitter",
					"_getAllProxyEmitters",
					"on",
					"once",
					"off",
					"listenTo",
					"stopListening",
					"fire",
					"delegate",
					"stopDelegating",
					"_addEventListener",
					"_removeEventListener",
				].forEach((t) => {
					os[t] = is.prototype[t];
				});
				class rs extends g {
					constructor(t, e) {
						super(),
							f(this, ss(t, e)),
							(this._domNode = t),
							(this._options = e);
					}
					attach(t) {
						if (this._domListeners && this._domListeners[t]) return;
						const e = this._createDomListener(t);
						this._domNode.addEventListener(t, e, this._options),
							this._domListeners || (this._domListeners = {}),
							(this._domListeners[t] = e);
					}
					detach(t) {
						let e;
						!this._domListeners[t] ||
							((e = this._events[t]) && e.callbacks.length) ||
							this._domListeners[t].removeListener();
					}
					_addEventListener(t, e, n) {
						this.attach(t), g.prototype._addEventListener.call(this, t, e, n);
					}
					_removeEventListener(t, e) {
						g.prototype._removeEventListener.call(this, t, e), this.detach(t);
					}
					_createDomListener(t) {
						const e = (e) => {
							this.fire(t, e);
						};
						return (
							(e.removeListener = () => {
								this._domNode.removeEventListener(t, e, this._options),
									delete this._domListeners[t];
							}),
							e
						);
					}
				}
				function ss(t, e) {
					let n = (function (t) {
						return t["data-ck-expando"] || (t["data-ck-expando"] = s());
					})(t);
					for (const t of Object.keys(e).sort()) e[t] && (n += "-" + t);
					return n;
				}
				class as extends is {
					constructor(t) {
						super(),
							(this.view = t),
							(this.document = t.document),
							(this.isEnabled = !1);
					}
					enable() {
						this.isEnabled = !0;
					}
					disable() {
						this.isEnabled = !1;
					}
					destroy() {
						this.disable(), this.stopListening();
					}
					checkShouldIgnoreEventFromTarget(t) {
						return (
							t && 3 === t.nodeType && (t = t.parentNode),
							!(!t || 1 !== t.nodeType) &&
								t.matches(
									"[data-cke-ignore-events], [data-cke-ignore-events] *",
								)
						);
					}
				}
				var cs = ci(function (t, e) {
					le(e, je(e), t);
				});
				class ls {
					constructor(t, e, n) {
						(this.view = t),
							(this.document = t.document),
							(this.domEvent = e),
							(this.domTarget = e.target),
							cs(this, n);
					}
					get target() {
						return this.view.domConverter.mapDomToView(this.domTarget);
					}
					preventDefault() {
						this.domEvent.preventDefault();
					}
					stopPropagation() {
						this.domEvent.stopPropagation();
					}
				}
				class ds extends as {
					constructor(t) {
						super(t), (this.useCapture = !1);
					}
					observe(t) {
						("string" == typeof this.domEventType
							? [this.domEventType]
							: this.domEventType
						).forEach((e) => {
							this.listenTo(
								t,
								e,
								(t, e) => {
									this.isEnabled &&
										!this.checkShouldIgnoreEventFromTarget(e.target) &&
										this.onDomEvent(e);
								},
								{ useCapture: this.useCapture },
							);
						});
					}
					fire(t, e, n) {
						this.isEnabled && this.document.fire(t, new ls(this.view, e, n));
					}
				}
				class us extends ds {
					constructor(t) {
						super(t), (this.domEventType = ["keydown", "keyup"]);
					}
					onDomEvent(t) {
						const e = {
							keyCode: t.keyCode,
							altKey: t.altKey,
							ctrlKey: t.ctrlKey,
							shiftKey: t.shiftKey,
							metaKey: t.metaKey,
							get keystroke() {
								return Qi(this);
							},
						};
						this.fire(t.type, t, e);
					}
				}
				var hs = function () {
						return V.a.Date.now();
					},
					ps = /\s/;
				var gs = function (t) {
						for (var e = t.length; e-- && ps.test(t.charAt(e)); );
						return e;
					},
					fs = /^\s+/;
				var ms = function (t) {
						return t ? t.slice(0, gs(t) + 1).replace(fs, "") : t;
					},
					ks = /^[-+]0x[0-9a-f]+$/i,
					bs = /^0b[01]+$/i,
					ws = /^0o[0-7]+$/i,
					As = parseInt;
				var _s = function (t) {
						if ("number" == typeof t) return t;
						if (Ao(t)) return NaN;
						if (C(t)) {
							var e = "function" == typeof t.valueOf ? t.valueOf() : t;
							t = C(e) ? e + "" : e;
						}
						if ("string" != typeof t) return 0 === t ? t : +t;
						t = ms(t);
						var n = bs.test(t);
						return n || ws.test(t)
							? As(t.slice(2), n ? 2 : 8)
							: ks.test(t)
								? NaN
								: +t;
					},
					Cs = Math.max,
					vs = Math.min;
				var ys = function (t, e, n) {
					var o,
						i,
						r,
						s,
						a,
						c,
						l = 0,
						d = !1,
						u = !1,
						h = !0;
					if ("function" != typeof t)
						throw new TypeError("Expected a function");
					function p(e) {
						var n = o,
							r = i;
						return (o = i = void 0), (l = e), (s = t.apply(r, n));
					}
					function g(t) {
						return (l = t), (a = setTimeout(m, e)), d ? p(t) : s;
					}
					function f(t) {
						var n = t - c;
						return void 0 === c || n >= e || n < 0 || (u && t - l >= r);
					}
					function m() {
						var t = hs();
						if (f(t)) return k(t);
						a = setTimeout(
							m,
							(function (t) {
								var n = e - (t - c);
								return u ? vs(n, r - (t - l)) : n;
							})(t),
						);
					}
					function k(t) {
						return (a = void 0), h && o ? p(t) : ((o = i = void 0), s);
					}
					function b() {
						var t = hs(),
							n = f(t);
						if (((o = arguments), (i = this), (c = t), n)) {
							if (void 0 === a) return g(c);
							if (u) return clearTimeout(a), (a = setTimeout(m, e)), p(c);
						}
						return void 0 === a && (a = setTimeout(m, e)), s;
					}
					return (
						(e = _s(e) || 0),
						C(n) &&
							((d = !!n.leading),
							(r = (u = "maxWait" in n) ? Cs(_s(n.maxWait) || 0, e) : r),
							(h = "trailing" in n ? !!n.trailing : h)),
						(b.cancel = function () {
							void 0 !== a && clearTimeout(a),
								(l = 0),
								(o = c = i = a = void 0);
						}),
						(b.flush = function () {
							return void 0 === a ? s : k(hs());
						}),
						b
					);
				};
				class xs extends as {
					constructor(t) {
						super(t),
							(this._fireSelectionChangeDoneDebounced = ys((t) => {
								this.document.fire("selectionChangeDone", t);
							}, 200));
					}
					observe() {
						const t = this.document;
						t.on(
							"arrowKey",
							(e, n) => {
								t.selection.isFake && this.isEnabled && n.preventDefault();
							},
							{ context: "$capture" },
						),
							t.on(
								"arrowKey",
								(e, n) => {
									t.selection.isFake &&
										this.isEnabled &&
										this._handleSelectionMove(n.keyCode);
								},
								{ priority: "lowest" },
							);
					}
					destroy() {
						super.destroy(), this._fireSelectionChangeDoneDebounced.cancel();
					}
					_handleSelectionMove(t) {
						const e = this.document.selection,
							n = new Si(e.getRanges(), { backward: e.isBackward, fake: !1 });
						(t != Ji.arrowleft && t != Ji.arrowup) ||
							n.setTo(n.getFirstPosition()),
							(t != Ji.arrowright && t != Ji.arrowdown) ||
								n.setTo(n.getLastPosition());
						const o = { oldSelection: e, newSelection: n, domSelection: null };
						this.document.fire("selectionChange", o),
							this._fireSelectionChangeDoneDebounced(o);
					}
				}
				var Ds = function (t) {
					return this.__data__.set(t, "__lodash_hash_undefined__"), this;
				};
				var Es = function (t) {
					return this.__data__.has(t);
				};
				function Ss(t) {
					var e = -1,
						n = null == t ? 0 : t.length;
					for (this.__data__ = new te(); ++e < n; ) this.add(t[e]);
				}
				(Ss.prototype.add = Ss.prototype.push = Ds), (Ss.prototype.has = Es);
				var Bs = Ss;
				var Ts = function (t, e) {
					for (var n = -1, o = null == t ? 0 : t.length; ++n < o; )
						if (e(t[n], n, t)) return !0;
					return !1;
				};
				var Ps = function (t, e) {
					return t.has(e);
				};
				var Fs = function (t, e, n, o, i, r) {
					var s = 1 & n,
						a = t.length,
						c = e.length;
					if (a != c && !(s && c > a)) return !1;
					var l = r.get(t),
						d = r.get(e);
					if (l && d) return l == e && d == t;
					var u = -1,
						h = !0,
						p = 2 & n ? new Bs() : void 0;
					for (r.set(t, e), r.set(e, t); ++u < a; ) {
						var g = t[u],
							f = e[u];
						if (o) var m = s ? o(f, g, u, e, t, r) : o(g, f, u, t, e, r);
						if (void 0 !== m) {
							if (m) continue;
							h = !1;
							break;
						}
						if (p) {
							if (
								!Ts(e, function (t, e) {
									if (!Ps(p, e) && (g === t || i(g, t, n, o, r)))
										return p.push(e);
								})
							) {
								h = !1;
								break;
							}
						} else if (g !== f && !i(g, f, n, o, r)) {
							h = !1;
							break;
						}
					}
					return r.delete(t), r.delete(e), h;
				};
				var Is = function (t) {
					var e = -1,
						n = Array(t.size);
					return (
						t.forEach(function (t, o) {
							n[++e] = [o, t];
						}),
						n
					);
				};
				var zs = function (t) {
						var e = -1,
							n = Array(t.size);
						return (
							t.forEach(function (t) {
								n[++e] = t;
							}),
							n
						);
					},
					Rs = L ? L.prototype : void 0,
					Os = Rs ? Rs.valueOf : void 0;
				var Ms = function (t, e, n, o, i, r, s) {
						switch (n) {
							case "[object DataView]":
								if (
									t.byteLength != e.byteLength ||
									t.byteOffset != e.byteOffset
								)
									return !1;
								(t = t.buffer), (e = e.buffer);
							case "[object ArrayBuffer]":
								return !(
									t.byteLength != e.byteLength || !r(new Cn(t), new Cn(e))
								);
							case "[object Boolean]":
							case "[object Date]":
							case "[object Number]":
								return st(+t, +e);
							case "[object Error]":
								return t.name == e.name && t.message == e.message;
							case "[object RegExp]":
							case "[object String]":
								return t == e + "";
							case "[object Map]":
								var a = Is;
							case "[object Set]":
								var c = 1 & o;
								if ((a || (a = zs), t.size != e.size && !c)) return !1;
								var l = s.get(t);
								if (l) return l == e;
								(o |= 2), s.set(t, e);
								var d = Fs(a(t), a(e), o, i, r, s);
								return s.delete(t), d;
							case "[object Symbol]":
								if (Os) return Os.call(t) == Os.call(e);
						}
						return !1;
					},
					Ns = Object.prototype.hasOwnProperty;
				var Vs = function (t, e, n, o, i, r) {
						var s = 1 & n,
							a = en(t),
							c = a.length;
						if (c != en(e).length && !s) return !1;
						for (var l = c; l--; ) {
							var d = a[l];
							if (!(s ? d in e : Ns.call(e, d))) return !1;
						}
						var u = r.get(t),
							h = r.get(e);
						if (u && h) return u == e && h == t;
						var p = !0;
						r.set(t, e), r.set(e, t);
						for (var g = s; ++l < c; ) {
							var f = t[(d = a[l])],
								m = e[d];
							if (o) var k = s ? o(m, f, d, e, t, r) : o(f, m, d, t, e, r);
							if (!(void 0 === k ? f === m || i(f, m, n, o, r) : k)) {
								p = !1;
								break;
							}
							g || (g = "constructor" == d);
						}
						if (p && !g) {
							var b = t.constructor,
								w = e.constructor;
							b == w ||
								!("constructor" in t) ||
								!("constructor" in e) ||
								("function" == typeof b &&
									b instanceof b &&
									"function" == typeof w &&
									w instanceof w) ||
								(p = !1);
						}
						return r.delete(t), r.delete(e), p;
					},
					Ls = "[object Arguments]",
					js = "[object Array]",
					Hs = "[object Object]",
					$s = Object.prototype.hasOwnProperty;
				var qs = function (t, e, n, o, i, r) {
					var s = ke(t),
						a = ke(e),
						c = s ? js : wn(t),
						l = a ? js : wn(e),
						d = (c = c == Ls ? Hs : c) == Hs,
						u = (l = l == Ls ? Hs : l) == Hs,
						h = c == l;
					if (h && Object(be.a)(t)) {
						if (!Object(be.a)(e)) return !1;
						(s = !0), (d = !1);
					}
					if (h && !d)
						return (
							r || (r = new oe()),
							s || Ee(t) ? Fs(t, e, n, o, i, r) : Ms(t, e, c, n, o, i, r)
						);
					if (!(1 & n)) {
						var p = d && $s.call(t, "__wrapped__"),
							g = u && $s.call(e, "__wrapped__");
						if (p || g) {
							var f = p ? t.value() : t,
								m = g ? e.value() : e;
							return r || (r = new oe()), i(f, m, n, o, r);
						}
					}
					return !!h && (r || (r = new oe()), Vs(t, e, n, o, i, r));
				};
				var Us = function t(e, n, o, i, r) {
					return (
						e === n ||
						(null == e || null == n || (!X(e) && !X(n))
							? e != e && n != n
							: qs(e, n, o, i, t, r))
					);
				};
				var Ws = function (t, e, n) {
					var o = (n = "function" == typeof n ? n : void 0) ? n(t, e) : void 0;
					return void 0 === o ? Us(t, e, void 0, n) : !!o;
				};
				class Ks extends as {
					constructor(t) {
						super(t),
							(this._config = {
								childList: !0,
								characterData: !0,
								subtree: !0,
							}),
							(this.domConverter = t.domConverter),
							(this.renderer = t._renderer),
							(this._domElements = []),
							(this._mutationObserver = new window.MutationObserver(
								this._onMutations.bind(this),
							));
					}
					flush() {
						this._onMutations(this._mutationObserver.takeRecords());
					}
					observe(t) {
						this._domElements.push(t),
							this.isEnabled && this._mutationObserver.observe(t, this._config);
					}
					enable() {
						super.enable();
						for (const t of this._domElements)
							this._mutationObserver.observe(t, this._config);
					}
					disable() {
						super.disable(), this._mutationObserver.disconnect();
					}
					destroy() {
						super.destroy(), this._mutationObserver.disconnect();
					}
					_onMutations(t) {
						if (0 === t.length) return;
						const e = this.domConverter,
							n = new Set(),
							o = new Set();
						for (const n of t) {
							const t = e.mapDomToView(n.target);
							t &&
								(t.is("uiElement") ||
									t.is("rawElement") ||
									"childList" !== n.type ||
									this._isBogusBrMutation(n) ||
									o.add(t));
						}
						for (const i of t) {
							const t = e.mapDomToView(i.target);
							if (
								(!t || (!t.is("uiElement") && !t.is("rawElement"))) &&
								"characterData" === i.type
							) {
								const t = e.findCorrespondingViewText(i.target);
								t && !o.has(t.parent)
									? n.add(t)
									: !t &&
										vr(i.target) &&
										o.add(e.mapDomToView(i.target.parentNode));
							}
						}
						let i = !1;
						for (const t of n) (i = !0), this.renderer.markToSync("text", t);
						for (const t of o) {
							const n = e.mapViewToDom(t),
								o = Array.from(t.getChildren()),
								r = Array.from(e.domChildrenToView(n, { withChildren: !1 }));
							Ws(o, r, Gs) ||
								((i = !0), this.renderer.markToSync("children", t));
						}
						i && this.view.forceRender();
					}
					_isBogusBrMutation(t) {
						let e = null;
						return (
							null === t.nextSibling &&
								0 === t.removedNodes.length &&
								1 == t.addedNodes.length &&
								(e = this.domConverter.domToView(t.addedNodes[0], {
									withChildren: !1,
								})),
							e && e.is("element", "br")
						);
					}
				}
				function Gs(t, e) {
					if (!Array.isArray(t))
						return (
							t === e ||
							(!(!t.is("$text") || !e.is("$text")) && t.data === e.data)
						);
				}
				class Js extends as {
					constructor(t) {
						super(t),
							(this.mutationObserver = t.getObserver(Ks)),
							(this.selection = this.document.selection),
							(this.domConverter = t.domConverter),
							(this._documents = new WeakSet()),
							(this._fireSelectionChangeDoneDebounced = ys((t) => {
								this.document.fire("selectionChangeDone", t);
							}, 200)),
							(this._clearInfiniteLoopInterval = setInterval(
								() => this._clearInfiniteLoop(),
								1e3,
							)),
							(this._documentIsSelectingInactivityTimeoutDebounced = ys(
								() => (this.document.isSelecting = !1),
								5e3,
							)),
							(this._loopbackCounter = 0);
					}
					observe(t) {
						const e = t.ownerDocument,
							n = () => {
								this.document.isSelecting &&
									(this._handleSelectionChange(null, e),
									(this.document.isSelecting = !1),
									this._documentIsSelectingInactivityTimeoutDebounced.cancel());
							};
						this.listenTo(
							t,
							"selectstart",
							() => {
								(this.document.isSelecting = !0),
									this._documentIsSelectingInactivityTimeoutDebounced();
							},
							{ priority: "highest" },
						),
							this.listenTo(t, "keydown", n, {
								priority: "highest",
								useCapture: !0,
							}),
							this.listenTo(t, "keyup", n, {
								priority: "highest",
								useCapture: !0,
							}),
							this._documents.has(e) ||
								(this.listenTo(e, "mouseup", n, {
									priority: "highest",
									useCapture: !0,
								}),
								this.listenTo(e, "selectionchange", (t, n) => {
									(this.document.isComposing && !Ui.isAndroid) ||
										(this._handleSelectionChange(n, e),
										this._documentIsSelectingInactivityTimeoutDebounced());
								}),
								this._documents.add(e));
					}
					destroy() {
						super.destroy(),
							clearInterval(this._clearInfiniteLoopInterval),
							this._fireSelectionChangeDoneDebounced.cancel(),
							this._documentIsSelectingInactivityTimeoutDebounced.cancel();
					}
					_handleSelectionChange(t, e) {
						if (!this.isEnabled) return;
						const n = e.defaultView.getSelection();
						if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) return;
						this.mutationObserver.flush();
						const o = this.domConverter.domSelectionToView(n);
						if (0 != o.rangeCount) {
							if (
								((this.view.hasDomSelection = !0),
								!(
									(this.selection.isEqual(o) &&
										this.domConverter.isDomSelectionCorrect(n)) ||
									++this._loopbackCounter > 60
								))
							)
								if (this.selection.isSimilar(o)) this.view.forceRender();
								else {
									const t = {
										oldSelection: this.selection,
										newSelection: o,
										domSelection: n,
									};
									this.document.fire("selectionChange", t),
										this._fireSelectionChangeDoneDebounced(t);
								}
						} else this.view.hasDomSelection = !1;
					}
					_clearInfiniteLoop() {
						this._loopbackCounter = 0;
					}
				}
				class Ys extends ds {
					constructor(t) {
						super(t),
							(this.domEventType = ["focus", "blur"]),
							(this.useCapture = !0);
						const e = this.document;
						e.on("focus", () => {
							(e.isFocused = !0),
								(this._renderTimeoutId = setTimeout(
									() => t.change(() => {}),
									50,
								));
						}),
							e.on("blur", (n, o) => {
								const i = e.selection.editableElement;
								(null !== i && i !== o.target) ||
									((e.isFocused = !1), t.change(() => {}));
							});
					}
					onDomEvent(t) {
						this.fire(t.type, t);
					}
					destroy() {
						this._renderTimeoutId && clearTimeout(this._renderTimeoutId),
							super.destroy();
					}
				}
				class Qs extends ds {
					constructor(t) {
						super(t),
							(this.domEventType = [
								"compositionstart",
								"compositionupdate",
								"compositionend",
							]);
						const e = this.document;
						e.on(
							"compositionstart",
							() => {
								e.isComposing = !0;
							},
							{ priority: "low" },
						),
							e.on(
								"compositionend",
								() => {
									e.isComposing = !1;
								},
								{ priority: "low" },
							);
					}
					onDomEvent(t) {
						this.fire(t.type, t, { data: t.data });
					}
				}
				class Xs {
					constructor(t) {
						(this.files = (function (t) {
							const e = Array.from(t.files || []),
								n = Array.from(t.items || []);
							if (e.length) return e;
							return n
								.filter((t) => "file" === t.kind)
								.map((t) => t.getAsFile());
						})(t)),
							(this._native = t);
					}
					get types() {
						return this._native.types;
					}
					getData(t) {
						return this._native.getData(t);
					}
					setData(t, e) {
						this._native.setData(t, e);
					}
					set effectAllowed(t) {
						this._native.effectAllowed = t;
					}
					get effectAllowed() {
						return this._native.effectAllowed;
					}
					set dropEffect(t) {
						this._native.dropEffect = t;
					}
					get dropEffect() {
						return this._native.dropEffect;
					}
					get isCanceled() {
						return (
							"none" == this._native.dropEffect ||
							!!this._native.mozUserCancelled
						);
					}
				}
				class Zs extends ds {
					constructor(t) {
						super(t), (this.domEventType = ["beforeinput"]);
					}
					onDomEvent(t) {
						const e = t.getTargetRanges(),
							n = this.view,
							o = n.document;
						let i = null,
							r = null,
							s = [];
						if (
							(t.dataTransfer && (i = new Xs(t.dataTransfer)),
							null !== t.data
								? (r = t.data)
								: i && (r = i.getData("text/plain")),
							o.selection.isFake)
						)
							s = Array.from(o.selection.getRanges());
						else if (e.length)
							s = e.map((t) => n.domConverter.domRangeToView(t));
						else if (Ui.isAndroid) {
							const e = t.target.ownerDocument.defaultView.getSelection();
							s = Array.from(n.domConverter.domSelectionToView(e).getRanges());
						}
						Ui.isAndroid &&
						"insertCompositionText" == t.inputType &&
						r &&
						r.endsWith("\n")
							? this.fire(t.type, t, {
									inputType: "insertParagraph",
									targetRanges: [n.createRange(s[0].end)],
								})
							: this.fire(t.type, t, {
									data: r,
									dataTransfer: i,
									targetRanges: s,
									inputType: t.inputType,
									isComposing: t.isComposing,
								});
					}
				}
				function ta(t, ...e) {
					e.forEach((e) => {
						const n = Object.getOwnPropertyNames(e),
							o = Object.getOwnPropertySymbols(e);
						n.concat(o).forEach((n) => {
							if (n in t.prototype) return;
							if (
								"function" == typeof e &&
								("length" == n || "name" == n || "prototype" == n)
							)
								return;
							const o = Object.getOwnPropertyDescriptor(e, n);
							(o.enumerable = !1), Object.defineProperty(t.prototype, n, o);
						});
					});
				}
				class ea {
					constructor() {
						this._replacedElements = [];
					}
					replace(t, e) {
						this._replacedElements.push({ element: t, newElement: e }),
							(t.style.display = "none"),
							e && t.parentNode.insertBefore(e, t.nextSibling);
					}
					restore() {
						this._replacedElements.forEach(({ element: t, newElement: e }) => {
							(t.style.display = ""), e && e.remove();
						}),
							(this._replacedElements = []);
					}
				}
				var na = function (t) {
					return (
						"string" == typeof t ||
						(!ke(t) && X(t) && "[object String]" == J(t))
					);
				};
				function oa(t, e, n = {}, o = []) {
					const i = n && n.xmlns,
						r = i ? t.createElementNS(i, e) : t.createElement(e);
					for (const t in n) r.setAttribute(t, n[t]);
					(!na(o) && Qn(o)) || (o = [o]);
					for (let e of o) na(e) && (e = t.createTextNode(e)), r.appendChild(e);
					return r;
				}
				function ia(t) {
					return "[object Range]" == Object.prototype.toString.apply(t);
				}
				function ra(t) {
					const e = t.ownerDocument.defaultView.getComputedStyle(t);
					return {
						top: parseInt(e.borderTopWidth, 10),
						right: parseInt(e.borderRightWidth, 10),
						bottom: parseInt(e.borderBottomWidth, 10),
						left: parseInt(e.borderLeftWidth, 10),
					};
				}
				const sa = ["top", "right", "bottom", "left", "width", "height"];
				class aa {
					constructor(t) {
						const e = ia(t);
						if (
							(Object.defineProperty(this, "_source", {
								value: t._source || t,
								writable: !0,
								enumerable: !1,
							}),
							da(t) || e)
						)
							if (e) {
								const e = aa.getDomRangeRects(t);
								ca(this, aa.getBoundingRect(e));
							} else ca(this, t.getBoundingClientRect());
						else if (ns(t)) {
							const { innerWidth: e, innerHeight: n } = t;
							ca(this, {
								top: 0,
								right: e,
								bottom: n,
								left: 0,
								width: e,
								height: n,
							});
						} else ca(this, t);
					}
					clone() {
						return new aa(this);
					}
					moveTo(t, e) {
						return (
							(this.top = e),
							(this.right = t + this.width),
							(this.bottom = e + this.height),
							(this.left = t),
							this
						);
					}
					moveBy(t, e) {
						return (
							(this.top += e),
							(this.right += t),
							(this.left += t),
							(this.bottom += e),
							this
						);
					}
					getIntersection(t) {
						const e = {
							top: Math.max(this.top, t.top),
							right: Math.min(this.right, t.right),
							bottom: Math.min(this.bottom, t.bottom),
							left: Math.max(this.left, t.left),
							width: 0,
							height: 0,
						};
						return (
							(e.width = e.right - e.left),
							(e.height = e.bottom - e.top),
							e.width < 0 || e.height < 0 ? null : new aa(e)
						);
					}
					getIntersectionArea(t) {
						const e = this.getIntersection(t);
						return e ? e.getArea() : 0;
					}
					getArea() {
						return this.width * this.height;
					}
					getVisible() {
						const t = this._source;
						let e = this.clone();
						if (!la(t)) {
							let n = t.parentNode || t.commonAncestorContainer;
							for (; n && !la(n); ) {
								const t = new aa(n),
									o = e.getIntersection(t);
								if (!o) return null;
								o.getArea() < e.getArea() && (e = o), (n = n.parentNode);
							}
						}
						return e;
					}
					isEqual(t) {
						for (const e of sa) if (this[e] !== t[e]) return !1;
						return !0;
					}
					contains(t) {
						const e = this.getIntersection(t);
						return !(!e || !e.isEqual(t));
					}
					excludeScrollbarsAndBorders() {
						const t = this._source;
						let e, n, o;
						if (ns(t))
							(e = t.innerWidth - t.document.documentElement.clientWidth),
								(n = t.innerHeight - t.document.documentElement.clientHeight),
								(o = t.getComputedStyle(t.document.documentElement).direction);
						else {
							const i = ra(t);
							(e = t.offsetWidth - t.clientWidth - i.left - i.right),
								(n = t.offsetHeight - t.clientHeight - i.top - i.bottom),
								(o = t.ownerDocument.defaultView.getComputedStyle(t).direction),
								(this.left += i.left),
								(this.top += i.top),
								(this.right -= i.right),
								(this.bottom -= i.bottom),
								(this.width = this.right - this.left),
								(this.height = this.bottom - this.top);
						}
						return (
							(this.width -= e),
							"ltr" === o ? (this.right -= e) : (this.left += e),
							(this.height -= n),
							(this.bottom -= n),
							this
						);
					}
					static getDomRangeRects(t) {
						const e = [],
							n = Array.from(t.getClientRects());
						if (n.length) for (const t of n) e.push(new aa(t));
						else {
							let n = t.startContainer;
							br(n) && (n = n.parentNode);
							const o = new aa(n.getBoundingClientRect());
							(o.right = o.left), (o.width = 0), e.push(o);
						}
						return e;
					}
					static getBoundingRect(t) {
						const e = {
							left: Number.POSITIVE_INFINITY,
							top: Number.POSITIVE_INFINITY,
							right: Number.NEGATIVE_INFINITY,
							bottom: Number.NEGATIVE_INFINITY,
							width: 0,
							height: 0,
						};
						let n = 0;
						for (const o of t)
							n++,
								(e.left = Math.min(e.left, o.left)),
								(e.top = Math.min(e.top, o.top)),
								(e.right = Math.max(e.right, o.right)),
								(e.bottom = Math.max(e.bottom, o.bottom));
						return 0 == n
							? null
							: ((e.width = e.right - e.left),
								(e.height = e.bottom - e.top),
								new aa(e));
					}
				}
				function ca(t, e) {
					for (const n of sa) t[n] = e[n];
				}
				function la(t) {
					return !!da(t) && t === t.ownerDocument.body;
				}
				function da(t) {
					return (
						null !== t &&
						"object" == typeof t &&
						1 === t.nodeType &&
						"function" == typeof t.getBoundingClientRect
					);
				}
				class ua {
					constructor(t, e) {
						ua._observerInstance || ua._createObserver(),
							(this._element = t),
							(this._callback = e),
							ua._addElementCallback(t, e),
							ua._observerInstance.observe(t);
					}
					destroy() {
						ua._deleteElementCallback(this._element, this._callback);
					}
					static _addElementCallback(t, e) {
						ua._elementCallbacks || (ua._elementCallbacks = new Map());
						let n = ua._elementCallbacks.get(t);
						n || ((n = new Set()), ua._elementCallbacks.set(t, n)), n.add(e);
					}
					static _deleteElementCallback(t, e) {
						const n = ua._getElementCallbacks(t);
						n &&
							(n.delete(e),
							n.size ||
								(ua._elementCallbacks.delete(t),
								ua._observerInstance.unobserve(t))),
							ua._elementCallbacks &&
								!ua._elementCallbacks.size &&
								((ua._observerInstance = null), (ua._elementCallbacks = null));
					}
					static _getElementCallbacks(t) {
						return ua._elementCallbacks ? ua._elementCallbacks.get(t) : null;
					}
					static _createObserver() {
						ua._observerInstance = new no.window.ResizeObserver((t) => {
							for (const e of t) {
								const t = ua._getElementCallbacks(e.target);
								if (t) for (const n of t) n(e);
							}
						});
					}
				}
				function ha(t, e) {
					t instanceof HTMLTextAreaElement && (t.value = e), (t.innerHTML = e);
				}
				function pa(t) {
					return (e) => e + t;
				}
				function ga(t) {
					return !!(t && t.getClientRects && t.getClientRects().length);
				}
				function fa(t, e, n) {
					const o = e.clone().moveBy(0, n),
						i = e.clone().moveBy(0, -n),
						r = new aa(t).excludeScrollbarsAndBorders();
					if (![i, o].every((t) => r.contains(t))) {
						let { scrollX: s, scrollY: a } = t;
						ba(i, r)
							? (a -= r.top - e.top + n)
							: ka(o, r) && (a += e.bottom - r.bottom + n),
							wa(e, r)
								? (s -= r.left - e.left + n)
								: Aa(e, r) && (s += e.right - r.right + n),
							t.scrollTo(s, a);
					}
				}
				function ma(t, e) {
					const n = _a(t);
					let o, i;
					for (; t != n.document.body; )
						(i = e()),
							(o = new aa(t).excludeScrollbarsAndBorders()),
							o.contains(i) ||
								(ba(i, o)
									? (t.scrollTop -= o.top - i.top)
									: ka(i, o) && (t.scrollTop += i.bottom - o.bottom),
								wa(i, o)
									? (t.scrollLeft -= o.left - i.left)
									: Aa(i, o) && (t.scrollLeft += i.right - o.right)),
							(t = t.parentNode);
				}
				function ka(t, e) {
					return t.bottom > e.bottom;
				}
				function ba(t, e) {
					return t.top < e.top;
				}
				function wa(t, e) {
					return t.left < e.left;
				}
				function Aa(t, e) {
					return t.right > e.right;
				}
				function _a(t) {
					return ia(t)
						? t.startContainer.ownerDocument.defaultView
						: t.ownerDocument.defaultView;
				}
				function Ca(t) {
					if (ia(t)) {
						let e = t.commonAncestorContainer;
						return br(e) && (e = e.parentNode), e;
					}
					return t.parentNode;
				}
				function va(t, e) {
					const n = _a(t),
						o = new aa(t);
					if (n === e) return o;
					{
						let t = n;
						for (; t != e; ) {
							const e = t.frameElement,
								n = new aa(e).excludeScrollbarsAndBorders();
							o.moveBy(n.left, n.top), (t = t.parent);
						}
					}
					return o;
				}
				function ya(t) {
					const e = t.next();
					return e.done ? null : e.value;
				}
				(ua._observerInstance = null), (ua._elementCallbacks = null);
				class xa extends os(B) {
					constructor() {
						super(),
							this.set("isFocused", !1),
							this.set("focusedElement", null),
							(this._elements = new Set()),
							(this._nextEventLoopTimeout = null);
					}
					add(t) {
						if (this._elements.has(t))
							throw new l.a("focustracker-add-element-already-exist", this);
						this.listenTo(t, "focus", () => this._focus(t), { useCapture: !0 }),
							this.listenTo(t, "blur", () => this._blur(), { useCapture: !0 }),
							this._elements.add(t);
					}
					remove(t) {
						t === this.focusedElement && this._blur(),
							this._elements.has(t) &&
								(this.stopListening(t), this._elements.delete(t));
					}
					destroy() {
						this.stopListening();
					}
					_focus(t) {
						clearTimeout(this._nextEventLoopTimeout),
							(this.focusedElement = t),
							(this.isFocused = !0);
					}
					_blur() {
						clearTimeout(this._nextEventLoopTimeout),
							(this._nextEventLoopTimeout = setTimeout(() => {
								(this.focusedElement = null), (this.isFocused = !1);
							}, 0));
					}
				}
				class Da {
					constructor() {
						this._listener = new is();
					}
					listenTo(t) {
						this._listener.listenTo(t, "keydown", (t, e) => {
							this._listener.fire("_keydown:" + Qi(e), e);
						});
					}
					set(t, e, n = {}) {
						const o = Xi(t),
							i = n.priority;
						this._listener.listenTo(
							this._listener,
							"_keydown:" + o,
							(t, n) => {
								e(n, () => {
									n.preventDefault(), n.stopPropagation(), t.stop();
								}),
									(t.return = !0);
							},
							{ priority: i },
						);
					}
					press(t) {
						return !!this._listener.fire("_keydown:" + Qi(t), t);
					}
					destroy() {
						this._listener.stopListening();
					}
				}
				class Ea extends as {
					constructor(t) {
						super(t),
							this.document.on("keydown", (t, e) => {
								if (
									this.isEnabled &&
									((n = e.keyCode) == Ji.arrowright ||
										n == Ji.arrowleft ||
										n == Ji.arrowup ||
										n == Ji.arrowdown)
								) {
									const n = new Ti(
										this.document,
										"arrowKey",
										this.document.selection.getFirstRange(),
									);
									this.document.fire(n, e), n.stop.called && t.stop();
								}
								var n;
							});
					}
					observe() {}
				}
				class Sa extends as {
					constructor(t) {
						super(t);
						const e = this.document;
						e.on("keydown", (t, n) => {
							if (!this.isEnabled || n.keyCode != Ji.tab || n.ctrlKey) return;
							const o = new Ti(e, "tab", e.selection.getFirstRange());
							e.fire(o, n), o.stop.called && t.stop();
						});
					}
					observe() {}
				}
				class Ba extends B {
					constructor(t) {
						super(),
							(this.document = new Mi(t)),
							(this.domConverter = new Xr(this.document)),
							(this.domRoots = new Map()),
							this.set("isRenderingInProgress", !1),
							this.set("hasDomSelection", !1),
							(this._renderer = new Vr(
								this.domConverter,
								this.document.selection,
							)),
							this._renderer
								.bind("isFocused", "isSelecting", "isComposing")
								.to(this.document, "isFocused", "isSelecting", "isComposing"),
							(this._initialDomRootAttributes = new WeakMap()),
							(this._observers = new Map()),
							(this._ongoingChange = !1),
							(this._postFixersInProgress = !1),
							(this._renderingDisabled = !1),
							(this._hasChangedSinceTheLastRendering = !1),
							(this._writer = new ar(this.document)),
							this.addObserver(Ks),
							this.addObserver(Js),
							this.addObserver(Ys),
							this.addObserver(us),
							this.addObserver(xs),
							this.addObserver(Qs),
							this.addObserver(Ea),
							this.addObserver(Zs),
							this.addObserver(Sa),
							this.document.on("arrowKey", Dr, { priority: "low" }),
							nr(this),
							this.on("render", () => {
								this._render(),
									this.document.fire("layoutChanged"),
									(this._hasChangedSinceTheLastRendering = !1);
							}),
							this.listenTo(this.document.selection, "change", () => {
								this._hasChangedSinceTheLastRendering = !0;
							}),
							this.listenTo(this.document, "change:isFocused", () => {
								this._hasChangedSinceTheLastRendering = !0;
							});
					}
					attachDomRoot(t, e = "main") {
						const n = this.document.getRoot(e);
						n._name = t.tagName.toLowerCase();
						const o = {};
						for (const { name: e, value: i } of Array.from(t.attributes))
							(o[e] = i),
								"class" === e
									? this._writer.addClass(i.split(" "), n)
									: this._writer.setAttribute(e, i, n);
						this._initialDomRootAttributes.set(t, o);
						const i = () => {
							this._writer.setAttribute(
								"contenteditable",
								(!n.isReadOnly).toString(),
								n,
							),
								n.isReadOnly
									? this._writer.addClass("ck-read-only", n)
									: this._writer.removeClass("ck-read-only", n);
						};
						i(),
							this.domRoots.set(e, t),
							this.domConverter.bindElements(t, n),
							this._renderer.markToSync("children", n),
							this._renderer.markToSync("attributes", n),
							this._renderer.domDocuments.add(t.ownerDocument),
							n.on("change:children", (t, e) =>
								this._renderer.markToSync("children", e),
							),
							n.on("change:attributes", (t, e) =>
								this._renderer.markToSync("attributes", e),
							),
							n.on("change:text", (t, e) =>
								this._renderer.markToSync("text", e),
							),
							n.on("change:isReadOnly", () => this.change(i)),
							n.on("change", () => {
								this._hasChangedSinceTheLastRendering = !0;
							});
						for (const n of this._observers.values()) n.observe(t, e);
					}
					detachDomRoot(t) {
						const e = this.domRoots.get(t);
						Array.from(e.attributes).forEach(({ name: t }) =>
							e.removeAttribute(t),
						);
						const n = this._initialDomRootAttributes.get(e);
						for (const t in n) e.setAttribute(t, n[t]);
						this.domRoots.delete(t), this.domConverter.unbindDomElement(e);
					}
					getDomRoot(t = "main") {
						return this.domRoots.get(t);
					}
					addObserver(t) {
						let e = this._observers.get(t);
						if (e) return e;
						(e = new t(this)), this._observers.set(t, e);
						for (const [t, n] of this.domRoots) e.observe(n, t);
						return e.enable(), e;
					}
					getObserver(t) {
						return this._observers.get(t);
					}
					disableObservers() {
						for (const t of this._observers.values()) t.disable();
					}
					enableObservers() {
						for (const t of this._observers.values()) t.enable();
					}
					scrollToTheSelection() {
						const t = this.document.selection.getFirstRange();
						t &&
							(function ({ target: t, viewportOffset: e = 0 }) {
								const n = _a(t);
								let o = n,
									i = null;
								for (; o; ) {
									let r;
									(r = Ca(o == n ? t : i)), ma(r, () => va(t, o));
									const s = va(t, o);
									if ((fa(o, s, e), o.parent != o)) {
										if (((i = o.frameElement), (o = o.parent), !i)) return;
									} else o = null;
								}
							})({
								target: this.domConverter.viewRangeToDom(t),
								viewportOffset: 20,
							});
					}
					focus() {
						if (!this.document.isFocused) {
							const t = this.document.selection.editableElement;
							t && (this.domConverter.focus(t), this.forceRender());
						}
					}
					change(t) {
						if (this.isRenderingInProgress || this._postFixersInProgress)
							throw new l.a("cannot-change-view-tree", this);
						try {
							if (this._ongoingChange) return t(this._writer);
							this._ongoingChange = !0;
							const e = t(this._writer);
							return (
								(this._ongoingChange = !1),
								!this._renderingDisabled &&
									this._hasChangedSinceTheLastRendering &&
									((this._postFixersInProgress = !0),
									this.document._callPostFixers(this._writer),
									(this._postFixersInProgress = !1),
									this.fire("render")),
								e
							);
						} catch (t) {
							l.a.rethrowUnexpectedError(t, this);
						}
					}
					forceRender() {
						(this._hasChangedSinceTheLastRendering = !0), this.change(() => {});
					}
					destroy() {
						for (const t of this._observers.values()) t.destroy();
						this.document.destroy(), this.stopListening();
					}
					createPositionAt(t, e) {
						return yi._createAt(t, e);
					}
					createPositionAfter(t) {
						return yi._createAfter(t);
					}
					createPositionBefore(t) {
						return yi._createBefore(t);
					}
					createRange(...t) {
						return new xi(...t);
					}
					createRangeOn(t) {
						return xi._createOn(t);
					}
					createRangeIn(t) {
						return xi._createIn(t);
					}
					createSelection(...t) {
						return new Si(...t);
					}
					_disableRendering(t) {
						(this._renderingDisabled = t), 0 == t && this.change(() => {});
					}
					_render() {
						(this.isRenderingInProgress = !0),
							this.disableObservers(),
							this._renderer.render(),
							this.enableObservers(),
							(this.isRenderingInProgress = !1);
					}
				}
				class Ta {
					is() {
						throw new Error("is() method is abstract");
					}
				}
				class Pa extends Ta {
					constructor(t) {
						super(), (this.parent = null), (this._attrs = mo(t));
					}
					get document() {
						return null;
					}
					get index() {
						let t;
						if (!this.parent) return null;
						if (null === (t = this.parent.getChildIndex(this)))
							throw new l.a("model-node-not-found-in-parent", this);
						return t;
					}
					get startOffset() {
						let t;
						if (!this.parent) return null;
						if (null === (t = this.parent.getChildStartOffset(this)))
							throw new l.a("model-node-not-found-in-parent", this);
						return t;
					}
					get offsetSize() {
						return 1;
					}
					get endOffset() {
						return this.parent ? this.startOffset + this.offsetSize : null;
					}
					get nextSibling() {
						const t = this.index;
						return (null !== t && this.parent.getChild(t + 1)) || null;
					}
					get previousSibling() {
						const t = this.index;
						return (null !== t && this.parent.getChild(t - 1)) || null;
					}
					get root() {
						let t = this;
						for (; t.parent; ) t = t.parent;
						return t;
					}
					isAttached() {
						return this.root.is("rootElement");
					}
					getPath() {
						const t = [];
						let e = this;
						for (; e.parent; ) t.unshift(e.startOffset), (e = e.parent);
						return t;
					}
					getAncestors(t = {}) {
						const e = [];
						let n = t.includeSelf ? this : this.parent;
						for (; n; )
							e[t.parentFirst ? "push" : "unshift"](n), (n = n.parent);
						return e;
					}
					getCommonAncestor(t, e = {}) {
						const n = this.getAncestors(e),
							o = t.getAncestors(e);
						let i = 0;
						for (; n[i] == o[i] && n[i]; ) i++;
						return 0 === i ? null : n[i - 1];
					}
					isBefore(t) {
						if (this == t) return !1;
						if (this.root !== t.root) return !1;
						const e = this.getPath(),
							n = t.getPath(),
							o = uo(e, n);
						switch (o) {
							case "prefix":
								return !0;
							case "extension":
								return !1;
							default:
								return e[o] < n[o];
						}
					}
					isAfter(t) {
						return this != t && this.root === t.root && !this.isBefore(t);
					}
					hasAttribute(t) {
						return this._attrs.has(t);
					}
					getAttribute(t) {
						return this._attrs.get(t);
					}
					getAttributes() {
						return this._attrs.entries();
					}
					getAttributeKeys() {
						return this._attrs.keys();
					}
					toJSON() {
						const t = {};
						return (
							this._attrs.size &&
								(t.attributes = Array.from(this._attrs).reduce(
									(t, e) => ((t[e[0]] = e[1]), t),
									{},
								)),
							t
						);
					}
					_clone(t) {
						return new Pa(this._attrs);
					}
					_remove() {
						this.parent._removeChildren(this.index);
					}
					_setAttribute(t, e) {
						this._attrs.set(t, e);
					}
					_setAttributesTo(t) {
						this._attrs = mo(t);
					}
					_removeAttribute(t) {
						return this._attrs.delete(t);
					}
					_clearAttributes() {
						this._attrs.clear();
					}
				}
				Pa.prototype.is = function (t) {
					return "node" === t || "model:node" === t;
				};
				class Fa {
					constructor(t) {
						(this._nodes = []), t && this._insertNodes(0, t);
					}
					[Symbol.iterator]() {
						return this._nodes[Symbol.iterator]();
					}
					get length() {
						return this._nodes.length;
					}
					get maxOffset() {
						return this._nodes.reduce((t, e) => t + e.offsetSize, 0);
					}
					getNode(t) {
						return this._nodes[t] || null;
					}
					getNodeIndex(t) {
						const e = this._nodes.indexOf(t);
						return -1 == e ? null : e;
					}
					getNodeStartOffset(t) {
						const e = this.getNodeIndex(t);
						return null === e
							? null
							: this._nodes.slice(0, e).reduce((t, e) => t + e.offsetSize, 0);
					}
					indexToOffset(t) {
						if (t == this._nodes.length) return this.maxOffset;
						const e = this._nodes[t];
						if (!e) throw new l.a("model-nodelist-index-out-of-bounds", this);
						return this.getNodeStartOffset(e);
					}
					offsetToIndex(t) {
						let e = 0;
						for (const n of this._nodes) {
							if (t >= e && t < e + n.offsetSize) return this.getNodeIndex(n);
							e += n.offsetSize;
						}
						if (e != t)
							throw new l.a("model-nodelist-offset-out-of-bounds", this, {
								offset: t,
								nodeList: this,
							});
						return this.length;
					}
					_insertNodes(t, e) {
						for (const t of e)
							if (!(t instanceof Pa))
								throw new l.a("model-nodelist-insertnodes-not-node", this);
						this._nodes = (function (t, e, n, o) {
							if (Math.max(e.length, t.length) > 1e4)
								return t
									.slice(0, n)
									.concat(e)
									.concat(t.slice(n + o, t.length));
							{
								const i = Array.from(t);
								return i.splice(n, o, ...e), i;
							}
						})(this._nodes, Array.from(e), t, 0);
					}
					_removeNodes(t, e = 1) {
						return this._nodes.splice(t, e);
					}
					toJSON() {
						return this._nodes.map((t) => t.toJSON());
					}
				}
				class Ia extends Pa {
					constructor(t, e) {
						super(e), (this._data = t || "");
					}
					get offsetSize() {
						return this.data.length;
					}
					get data() {
						return this._data;
					}
					toJSON() {
						const t = super.toJSON();
						return (t.data = this.data), t;
					}
					_clone() {
						return new Ia(this.data, this.getAttributes());
					}
					static fromJSON(t) {
						return new Ia(t.data, t.attributes);
					}
				}
				Ia.prototype.is = function (t) {
					return (
						"$text" === t ||
						"model:$text" === t ||
						"text" === t ||
						"model:text" === t ||
						"node" === t ||
						"model:node" === t
					);
				};
				class za extends Ta {
					constructor(t, e, n) {
						if ((super(), (this.textNode = t), e < 0 || e > t.offsetSize))
							throw new l.a("model-textproxy-wrong-offsetintext", this);
						if (n < 0 || e + n > t.offsetSize)
							throw new l.a("model-textproxy-wrong-length", this);
						(this.data = t.data.substring(e, e + n)), (this.offsetInText = e);
					}
					get startOffset() {
						return null !== this.textNode.startOffset
							? this.textNode.startOffset + this.offsetInText
							: null;
					}
					get offsetSize() {
						return this.data.length;
					}
					get endOffset() {
						return null !== this.startOffset
							? this.startOffset + this.offsetSize
							: null;
					}
					get isPartial() {
						return this.offsetSize !== this.textNode.offsetSize;
					}
					get parent() {
						return this.textNode.parent;
					}
					get root() {
						return this.textNode.root;
					}
					getPath() {
						const t = this.textNode.getPath();
						return t.length > 0 && (t[t.length - 1] += this.offsetInText), t;
					}
					getAncestors(t = {}) {
						const e = [];
						let n = t.includeSelf ? this : this.parent;
						for (; n; )
							e[t.parentFirst ? "push" : "unshift"](n), (n = n.parent);
						return e;
					}
					hasAttribute(t) {
						return this.textNode.hasAttribute(t);
					}
					getAttribute(t) {
						return this.textNode.getAttribute(t);
					}
					getAttributes() {
						return this.textNode.getAttributes();
					}
					getAttributeKeys() {
						return this.textNode.getAttributeKeys();
					}
				}
				za.prototype.is = function (t) {
					return (
						"$textProxy" === t ||
						"model:$textProxy" === t ||
						"textProxy" === t ||
						"model:textProxy" === t
					);
				};
				class Ra extends Pa {
					constructor(t, e, n) {
						super(e),
							(this.name = t),
							(this._children = new Fa()),
							n && this._insertChild(0, n);
					}
					get childCount() {
						return this._children.length;
					}
					get maxOffset() {
						return this._children.maxOffset;
					}
					get isEmpty() {
						return 0 === this.childCount;
					}
					getChild(t) {
						return this._children.getNode(t);
					}
					getChildren() {
						return this._children[Symbol.iterator]();
					}
					getChildIndex(t) {
						return this._children.getNodeIndex(t);
					}
					getChildStartOffset(t) {
						return this._children.getNodeStartOffset(t);
					}
					offsetToIndex(t) {
						return this._children.offsetToIndex(t);
					}
					getNodeByPath(t) {
						let e = this;
						for (const n of t) e = e.getChild(e.offsetToIndex(n));
						return e;
					}
					findAncestor(t, e = {}) {
						let n = e.includeSelf ? this : this.parent;
						for (; n; ) {
							if (n.name === t) return n;
							n = n.parent;
						}
						return null;
					}
					toJSON() {
						const t = super.toJSON();
						if (((t.name = this.name), this._children.length > 0)) {
							t.children = [];
							for (const e of this._children) t.children.push(e.toJSON());
						}
						return t;
					}
					_clone(t = !1) {
						const e = t
							? Array.from(this._children).map((t) => t._clone(!0))
							: void 0;
						return new Ra(this.name, this.getAttributes(), e);
					}
					_appendChild(t) {
						this._insertChild(this.childCount, t);
					}
					_insertChild(t, e) {
						const n = (function (t) {
							if ("string" == typeof t) return [new Ia(t)];
							Qn(t) || (t = [t]);
							return Array.from(t).map((t) =>
								"string" == typeof t
									? new Ia(t)
									: t instanceof za
										? new Ia(t.data, t.getAttributes())
										: t,
							);
						})(e);
						for (const t of n)
							null !== t.parent && t._remove(), (t.parent = this);
						this._children._insertNodes(t, n);
					}
					_removeChildren(t, e = 1) {
						const n = this._children._removeNodes(t, e);
						for (const t of n) t.parent = null;
						return n;
					}
					static fromJSON(t) {
						let e;
						if (t.children) {
							e = [];
							for (const n of t.children)
								n.name ? e.push(Ra.fromJSON(n)) : e.push(Ia.fromJSON(n));
						}
						return new Ra(t.name, t.attributes, e);
					}
				}
				Ra.prototype.is = function (t, e) {
					return e
						? e === this.name && ("element" === t || "model:element" === t)
						: "element" === t ||
								"model:element" === t ||
								"node" === t ||
								"model:node" === t;
				};
				class Oa {
					constructor(t = {}) {
						if (!t.boundaries && !t.startPosition)
							throw new l.a("model-tree-walker-no-start-position", null);
						const e = t.direction || "forward";
						if ("forward" != e && "backward" != e)
							throw new l.a("model-tree-walker-unknown-direction", t, {
								direction: e,
							});
						(this.direction = e),
							(this.boundaries = t.boundaries || null),
							t.startPosition
								? (this.position = t.startPosition.clone())
								: (this.position = Na._createAt(
										this.boundaries[
											"backward" == this.direction ? "end" : "start"
										],
									)),
							(this.position.stickiness = "toNone"),
							(this.singleCharacters = !!t.singleCharacters),
							(this.shallow = !!t.shallow),
							(this.ignoreElementEnd = !!t.ignoreElementEnd),
							(this._boundaryStartParent = this.boundaries
								? this.boundaries.start.parent
								: null),
							(this._boundaryEndParent = this.boundaries
								? this.boundaries.end.parent
								: null),
							(this._visitedParent = this.position.parent);
					}
					[Symbol.iterator]() {
						return this;
					}
					skip(t) {
						let e, n, o, i;
						do {
							(o = this.position),
								(i = this._visitedParent),
								({ done: e, value: n } = this.next());
						} while (!e && t(n));
						e || ((this.position = o), (this._visitedParent = i));
					}
					next() {
						return "forward" == this.direction
							? this._next()
							: this._previous();
					}
					_next() {
						const t = this.position,
							e = this.position.clone(),
							n = this._visitedParent;
						if (null === n.parent && e.offset === n.maxOffset)
							return { done: !0, value: void 0 };
						if (
							n === this._boundaryEndParent &&
							e.offset == this.boundaries.end.offset
						)
							return { done: !0, value: void 0 };
						const o = Va(e, n),
							i = o || La(e, n, o);
						if (i instanceof Ra)
							return (
								this.shallow
									? e.offset++
									: (e.path.push(0), (this._visitedParent = i)),
								(this.position = e),
								Ma("elementStart", i, t, e, 1)
							);
						if (i instanceof Ia) {
							let o;
							if (this.singleCharacters) o = 1;
							else {
								let t = i.endOffset;
								this._boundaryEndParent == n &&
									this.boundaries.end.offset < t &&
									(t = this.boundaries.end.offset),
									(o = t - e.offset);
							}
							const r = e.offset - i.startOffset,
								s = new za(i, r, o);
							return (
								(e.offset += o), (this.position = e), Ma("text", s, t, e, o)
							);
						}
						return (
							e.path.pop(),
							e.offset++,
							(this.position = e),
							(this._visitedParent = n.parent),
							this.ignoreElementEnd ? this._next() : Ma("elementEnd", n, t, e)
						);
					}
					_previous() {
						const t = this.position,
							e = this.position.clone(),
							n = this._visitedParent;
						if (null === n.parent && 0 === e.offset)
							return { done: !0, value: void 0 };
						if (
							n == this._boundaryStartParent &&
							e.offset == this.boundaries.start.offset
						)
							return { done: !0, value: void 0 };
						const o = e.parent,
							i = Va(e, o),
							r = i || ja(e, o, i);
						if (r instanceof Ra)
							return (
								e.offset--,
								this.shallow
									? ((this.position = e), Ma("elementStart", r, t, e, 1))
									: (e.path.push(r.maxOffset),
										(this.position = e),
										(this._visitedParent = r),
										this.ignoreElementEnd
											? this._previous()
											: Ma("elementEnd", r, t, e))
							);
						if (r instanceof Ia) {
							let o;
							if (this.singleCharacters) o = 1;
							else {
								let t = r.startOffset;
								this._boundaryStartParent == n &&
									this.boundaries.start.offset > t &&
									(t = this.boundaries.start.offset),
									(o = e.offset - t);
							}
							const i = e.offset - r.startOffset,
								s = new za(r, i - o, o);
							return (
								(e.offset -= o), (this.position = e), Ma("text", s, t, e, o)
							);
						}
						return (
							e.path.pop(),
							(this.position = e),
							(this._visitedParent = n.parent),
							Ma("elementStart", n, t, e, 1)
						);
					}
				}
				function Ma(t, e, n, o, i) {
					return {
						done: !1,
						value: {
							type: t,
							item: e,
							previousPosition: n,
							nextPosition: o,
							length: i,
						},
					};
				}
				class Na extends Ta {
					constructor(t, e, n = "toNone") {
						if ((super(), !t.is("element") && !t.is("documentFragment")))
							throw new l.a("model-position-root-invalid", t);
						if (!(e instanceof Array) || 0 === e.length)
							throw new l.a("model-position-path-incorrect-format", t, {
								path: e,
							});
						t.is("rootElement")
							? (e = e.slice())
							: ((e = [...t.getPath(), ...e]), (t = t.root)),
							(this.root = t),
							(this.path = e),
							(this.stickiness = n);
					}
					get offset() {
						return this.path[this.path.length - 1];
					}
					set offset(t) {
						this.path[this.path.length - 1] = t;
					}
					get parent() {
						let t = this.root;
						for (let e = 0; e < this.path.length - 1; e++)
							if (((t = t.getChild(t.offsetToIndex(this.path[e]))), !t))
								throw new l.a("model-position-path-incorrect", this, {
									position: this,
								});
						if (t.is("$text"))
							throw new l.a("model-position-path-incorrect", this, {
								position: this,
							});
						return t;
					}
					get index() {
						return this.parent.offsetToIndex(this.offset);
					}
					get textNode() {
						return Va(this, this.parent);
					}
					get nodeAfter() {
						const t = this.parent;
						return La(this, t, Va(this, t));
					}
					get nodeBefore() {
						const t = this.parent;
						return ja(this, t, Va(this, t));
					}
					get isAtStart() {
						return 0 === this.offset;
					}
					get isAtEnd() {
						return this.offset == this.parent.maxOffset;
					}
					compareWith(t) {
						if (this.root != t.root) return "different";
						const e = uo(this.path, t.path);
						switch (e) {
							case "same":
								return "same";
							case "prefix":
								return "before";
							case "extension":
								return "after";
							default:
								return this.path[e] < t.path[e] ? "before" : "after";
						}
					}
					getLastMatchingPosition(t, e = {}) {
						e.startPosition = this;
						const n = new Oa(e);
						return n.skip(t), n.position;
					}
					getParentPath() {
						return this.path.slice(0, -1);
					}
					getAncestors() {
						const t = this.parent;
						return t.is("documentFragment")
							? [t]
							: t.getAncestors({ includeSelf: !0 });
					}
					findAncestor(t) {
						const e = this.parent;
						return e.is("element")
							? e.findAncestor(t, { includeSelf: !0 })
							: null;
					}
					getCommonPath(t) {
						if (this.root != t.root) return [];
						const e = uo(this.path, t.path),
							n =
								"string" == typeof e
									? Math.min(this.path.length, t.path.length)
									: e;
						return this.path.slice(0, n);
					}
					getCommonAncestor(t) {
						const e = this.getAncestors(),
							n = t.getAncestors();
						let o = 0;
						for (; e[o] == n[o] && e[o]; ) o++;
						return 0 === o ? null : e[o - 1];
					}
					getShiftedBy(t) {
						const e = this.clone(),
							n = e.offset + t;
						return (e.offset = n < 0 ? 0 : n), e;
					}
					isAfter(t) {
						return "after" == this.compareWith(t);
					}
					isBefore(t) {
						return "before" == this.compareWith(t);
					}
					isEqual(t) {
						return "same" == this.compareWith(t);
					}
					isTouching(t) {
						if (this.root !== t.root) return !1;
						const e = Math.min(this.path.length, t.path.length);
						for (let n = 0; n < e; n++) {
							const e = this.path[n] - t.path[n];
							if (e < -1 || e > 1) return !1;
							if (1 === e) return Ha(t, this, n);
							if (-1 === e) return Ha(this, t, n);
						}
						return (
							this.path.length === t.path.length ||
							(this.path.length > t.path.length
								? $a(this.path, e)
								: $a(t.path, e))
						);
					}
					hasSameParentAs(t) {
						if (this.root !== t.root) return !1;
						return "same" == uo(this.getParentPath(), t.getParentPath());
					}
					getTransformedByOperation(t) {
						let e;
						switch (t.type) {
							case "insert":
								e = this._getTransformedByInsertOperation(t);
								break;
							case "move":
							case "remove":
							case "reinsert":
								e = this._getTransformedByMoveOperation(t);
								break;
							case "split":
								e = this._getTransformedBySplitOperation(t);
								break;
							case "merge":
								e = this._getTransformedByMergeOperation(t);
								break;
							default:
								e = Na._createAt(this);
						}
						return e;
					}
					_getTransformedByInsertOperation(t) {
						return this._getTransformedByInsertion(t.position, t.howMany);
					}
					_getTransformedByMoveOperation(t) {
						return this._getTransformedByMove(
							t.sourcePosition,
							t.targetPosition,
							t.howMany,
						);
					}
					_getTransformedBySplitOperation(t) {
						const e = t.movedRange;
						return e.containsPosition(this) ||
							(e.start.isEqual(this) && "toNext" == this.stickiness)
							? this._getCombined(t.splitPosition, t.moveTargetPosition)
							: t.graveyardPosition
								? this._getTransformedByMove(
										t.graveyardPosition,
										t.insertionPosition,
										1,
									)
								: this._getTransformedByInsertion(t.insertionPosition, 1);
					}
					_getTransformedByMergeOperation(t) {
						const e = t.movedRange;
						let n;
						return (
							e.containsPosition(this) || e.start.isEqual(this)
								? ((n = this._getCombined(t.sourcePosition, t.targetPosition)),
									t.sourcePosition.isBefore(t.targetPosition) &&
										(n = n._getTransformedByDeletion(t.deletionPosition, 1)))
								: (n = this.isEqual(t.deletionPosition)
										? Na._createAt(t.deletionPosition)
										: this._getTransformedByMove(
												t.deletionPosition,
												t.graveyardPosition,
												1,
											)),
							n
						);
					}
					_getTransformedByDeletion(t, e) {
						const n = Na._createAt(this);
						if (this.root != t.root) return n;
						if ("same" == uo(t.getParentPath(), this.getParentPath())) {
							if (t.offset < this.offset) {
								if (t.offset + e > this.offset) return null;
								n.offset -= e;
							}
						} else if (
							"prefix" == uo(t.getParentPath(), this.getParentPath())
						) {
							const o = t.path.length - 1;
							if (t.offset <= this.path[o]) {
								if (t.offset + e > this.path[o]) return null;
								n.path[o] -= e;
							}
						}
						return n;
					}
					_getTransformedByInsertion(t, e) {
						const n = Na._createAt(this);
						if (this.root != t.root) return n;
						if ("same" == uo(t.getParentPath(), this.getParentPath()))
							(t.offset < this.offset ||
								(t.offset == this.offset && "toPrevious" != this.stickiness)) &&
								(n.offset += e);
						else if ("prefix" == uo(t.getParentPath(), this.getParentPath())) {
							const o = t.path.length - 1;
							t.offset <= this.path[o] && (n.path[o] += e);
						}
						return n;
					}
					_getTransformedByMove(t, e, n) {
						if (((e = e._getTransformedByDeletion(t, n)), t.isEqual(e)))
							return Na._createAt(this);
						const o = this._getTransformedByDeletion(t, n);
						return null === o ||
							(t.isEqual(this) && "toNext" == this.stickiness) ||
							(t.getShiftedBy(n).isEqual(this) &&
								"toPrevious" == this.stickiness)
							? this._getCombined(t, e)
							: o._getTransformedByInsertion(e, n);
					}
					_getCombined(t, e) {
						const n = t.path.length - 1,
							o = Na._createAt(e);
						return (
							(o.stickiness = this.stickiness),
							(o.offset = o.offset + this.path[n] - t.offset),
							(o.path = [...o.path, ...this.path.slice(n + 1)]),
							o
						);
					}
					toJSON() {
						return {
							root: this.root.toJSON(),
							path: Array.from(this.path),
							stickiness: this.stickiness,
						};
					}
					clone() {
						return new this.constructor(this.root, this.path, this.stickiness);
					}
					static _createAt(t, e, n = "toNone") {
						if (t instanceof Na) return new Na(t.root, t.path, t.stickiness);
						{
							const o = t;
							if ("end" == e) e = o.maxOffset;
							else {
								if ("before" == e) return this._createBefore(o, n);
								if ("after" == e) return this._createAfter(o, n);
								if (0 !== e && !e)
									throw new l.a("model-createpositionat-offset-required", [
										this,
										t,
									]);
							}
							if (!o.is("element") && !o.is("documentFragment"))
								throw new l.a("model-position-parent-incorrect", [this, t]);
							const i = o.getPath();
							return i.push(e), new this(o.root, i, n);
						}
					}
					static _createAfter(t, e) {
						if (!t.parent)
							throw new l.a("model-position-after-root", [this, t], {
								root: t,
							});
						return this._createAt(t.parent, t.endOffset, e);
					}
					static _createBefore(t, e) {
						if (!t.parent)
							throw new l.a("model-position-before-root", t, { root: t });
						return this._createAt(t.parent, t.startOffset, e);
					}
					static fromJSON(t, e) {
						if ("$graveyard" === t.root) {
							const n = new Na(e.graveyard, t.path);
							return (n.stickiness = t.stickiness), n;
						}
						if (!e.getRoot(t.root))
							throw new l.a("model-position-fromjson-no-root", e, {
								rootName: t.root,
							});
						return new Na(e.getRoot(t.root), t.path, t.stickiness);
					}
				}
				function Va(t, e) {
					const n = e.getChild(e.offsetToIndex(t.offset));
					return n && n.is("$text") && n.startOffset < t.offset ? n : null;
				}
				function La(t, e, n) {
					return null !== n ? null : e.getChild(e.offsetToIndex(t.offset));
				}
				function ja(t, e, n) {
					return null !== n ? null : e.getChild(e.offsetToIndex(t.offset) - 1);
				}
				function Ha(t, e, n) {
					return (
						n + 1 !== t.path.length &&
						!!$a(e.path, n + 1) &&
						!!(function (t, e) {
							let n = t.parent,
								o = t.path.length - 1,
								i = 0;
							for (; o >= e; ) {
								if (t.path[o] + i !== n.maxOffset) return !1;
								(i = 1), o--, (n = n.parent);
							}
							return !0;
						})(t, n + 1)
					);
				}
				function $a(t, e) {
					for (; e < t.length; ) {
						if (0 !== t[e]) return !1;
						e++;
					}
					return !0;
				}
				Na.prototype.is = function (t) {
					return "position" === t || "model:position" === t;
				};
				class qa extends Ta {
					constructor(t, e) {
						super(),
							(this.start = Na._createAt(t)),
							(this.end = e ? Na._createAt(e) : Na._createAt(t)),
							(this.start.stickiness = this.isCollapsed ? "toNone" : "toNext"),
							(this.end.stickiness = this.isCollapsed
								? "toNone"
								: "toPrevious");
					}
					*[Symbol.iterator]() {
						yield* new Oa({ boundaries: this, ignoreElementEnd: !0 });
					}
					get isCollapsed() {
						return this.start.isEqual(this.end);
					}
					get isFlat() {
						return (
							"same" == uo(this.start.getParentPath(), this.end.getParentPath())
						);
					}
					get root() {
						return this.start.root;
					}
					containsPosition(t) {
						return t.isAfter(this.start) && t.isBefore(this.end);
					}
					containsRange(t, e = !1) {
						t.isCollapsed && (e = !1);
						const n =
								this.containsPosition(t.start) ||
								(e && this.start.isEqual(t.start)),
							o =
								this.containsPosition(t.end) || (e && this.end.isEqual(t.end));
						return n && o;
					}
					containsItem(t) {
						const e = Na._createBefore(t);
						return this.containsPosition(e) || this.start.isEqual(e);
					}
					isEqual(t) {
						return this.start.isEqual(t.start) && this.end.isEqual(t.end);
					}
					isIntersecting(t) {
						return this.start.isBefore(t.end) && this.end.isAfter(t.start);
					}
					getDifference(t) {
						const e = [];
						return (
							this.isIntersecting(t)
								? (this.containsPosition(t.start) &&
										e.push(new qa(this.start, t.start)),
									this.containsPosition(t.end) &&
										e.push(new qa(t.end, this.end)))
								: e.push(new qa(this.start, this.end)),
							e
						);
					}
					getIntersection(t) {
						if (this.isIntersecting(t)) {
							let e = this.start,
								n = this.end;
							return (
								this.containsPosition(t.start) && (e = t.start),
								this.containsPosition(t.end) && (n = t.end),
								new qa(e, n)
							);
						}
						return null;
					}
					getJoined(t, e = !1) {
						let n = this.isIntersecting(t);
						if (
							(n ||
								(n = this.start.isBefore(t.start)
									? e
										? this.end.isTouching(t.start)
										: this.end.isEqual(t.start)
									: e
										? t.end.isTouching(this.start)
										: t.end.isEqual(this.start)),
							!n)
						)
							return null;
						let o = this.start,
							i = this.end;
						return (
							t.start.isBefore(o) && (o = t.start),
							t.end.isAfter(i) && (i = t.end),
							new qa(o, i)
						);
					}
					getMinimalFlatRanges() {
						const t = [],
							e = this.start.getCommonPath(this.end).length,
							n = Na._createAt(this.start);
						let o = n.parent;
						for (; n.path.length > e + 1; ) {
							const e = o.maxOffset - n.offset;
							0 !== e && t.push(new qa(n, n.getShiftedBy(e))),
								(n.path = n.path.slice(0, -1)),
								n.offset++,
								(o = o.parent);
						}
						for (; n.path.length <= this.end.path.length; ) {
							const e = this.end.path[n.path.length - 1],
								o = e - n.offset;
							0 !== o && t.push(new qa(n, n.getShiftedBy(o))),
								(n.offset = e),
								n.path.push(0);
						}
						return t;
					}
					getWalker(t = {}) {
						return (t.boundaries = this), new Oa(t);
					}
					*getItems(t = {}) {
						(t.boundaries = this), (t.ignoreElementEnd = !0);
						const e = new Oa(t);
						for (const t of e) yield t.item;
					}
					*getPositions(t = {}) {
						t.boundaries = this;
						const e = new Oa(t);
						yield e.position;
						for (const t of e) yield t.nextPosition;
					}
					getTransformedByOperation(t) {
						switch (t.type) {
							case "insert":
								return this._getTransformedByInsertOperation(t);
							case "move":
							case "remove":
							case "reinsert":
								return this._getTransformedByMoveOperation(t);
							case "split":
								return [this._getTransformedBySplitOperation(t)];
							case "merge":
								return [this._getTransformedByMergeOperation(t)];
						}
						return [new qa(this.start, this.end)];
					}
					getTransformedByOperations(t) {
						const e = [new qa(this.start, this.end)];
						for (const n of t)
							for (let t = 0; t < e.length; t++) {
								const o = e[t].getTransformedByOperation(n);
								e.splice(t, 1, ...o), (t += o.length - 1);
							}
						for (let t = 0; t < e.length; t++) {
							const n = e[t];
							for (let o = t + 1; o < e.length; o++) {
								const t = e[o];
								(n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) &&
									e.splice(o, 1);
							}
						}
						return e;
					}
					getCommonAncestor() {
						return this.start.getCommonAncestor(this.end);
					}
					getContainedElement() {
						if (this.isCollapsed) return null;
						const t = this.start.nodeAfter,
							e = this.end.nodeBefore;
						return t && t.is("element") && t === e ? t : null;
					}
					toJSON() {
						return { start: this.start.toJSON(), end: this.end.toJSON() };
					}
					clone() {
						return new this.constructor(this.start, this.end);
					}
					_getTransformedByInsertOperation(t, e = !1) {
						return this._getTransformedByInsertion(t.position, t.howMany, e);
					}
					_getTransformedByMoveOperation(t, e = !1) {
						const n = t.sourcePosition,
							o = t.howMany,
							i = t.targetPosition;
						return this._getTransformedByMove(n, i, o, e);
					}
					_getTransformedBySplitOperation(t) {
						const e = this.start._getTransformedBySplitOperation(t);
						let n = this.end._getTransformedBySplitOperation(t);
						return (
							this.end.isEqual(t.insertionPosition) &&
								(n = this.end.getShiftedBy(1)),
							e.root != n.root && (n = this.end.getShiftedBy(-1)),
							new qa(e, n)
						);
					}
					_getTransformedByMergeOperation(t) {
						if (
							this.start.isEqual(t.targetPosition) &&
							this.end.isEqual(t.deletionPosition)
						)
							return new qa(this.start);
						let e = this.start._getTransformedByMergeOperation(t),
							n = this.end._getTransformedByMergeOperation(t);
						return (
							e.root != n.root && (n = this.end.getShiftedBy(-1)),
							e.isAfter(n)
								? (t.sourcePosition.isBefore(t.targetPosition)
										? ((e = Na._createAt(n)), (e.offset = 0))
										: (t.deletionPosition.isEqual(e) ||
												(n = t.deletionPosition),
											(e = t.targetPosition)),
									new qa(e, n))
								: new qa(e, n)
						);
					}
					_getTransformedByInsertion(t, e, n = !1) {
						if (n && this.containsPosition(t))
							return [
								new qa(this.start, t),
								new qa(
									t.getShiftedBy(e),
									this.end._getTransformedByInsertion(t, e),
								),
							];
						{
							const n = new qa(this.start, this.end);
							return (
								(n.start = n.start._getTransformedByInsertion(t, e)),
								(n.end = n.end._getTransformedByInsertion(t, e)),
								[n]
							);
						}
					}
					_getTransformedByMove(t, e, n, o = !1) {
						if (this.isCollapsed) {
							const o = this.start._getTransformedByMove(t, e, n);
							return [new qa(o)];
						}
						const i = qa._createFromPositionAndShift(t, n),
							r = e._getTransformedByDeletion(t, n);
						if (
							this.containsPosition(e) &&
							!o &&
							(i.containsPosition(this.start) || i.containsPosition(this.end))
						) {
							const o = this.start._getTransformedByMove(t, e, n),
								i = this.end._getTransformedByMove(t, e, n);
							return [new qa(o, i)];
						}
						let s;
						const a = this.getDifference(i);
						let c = null;
						const l = this.getIntersection(i);
						if (
							(1 == a.length
								? (c = new qa(
										a[0].start._getTransformedByDeletion(t, n),
										a[0].end._getTransformedByDeletion(t, n),
									))
								: 2 == a.length &&
									(c = new qa(
										this.start,
										this.end._getTransformedByDeletion(t, n),
									)),
							(s = c
								? c._getTransformedByInsertion(r, n, null !== l || o)
								: []),
							l)
						) {
							const t = new qa(
								l.start._getCombined(i.start, r),
								l.end._getCombined(i.start, r),
							);
							2 == s.length ? s.splice(1, 0, t) : s.push(t);
						}
						return s;
					}
					_getTransformedByDeletion(t, e) {
						let n = this.start._getTransformedByDeletion(t, e),
							o = this.end._getTransformedByDeletion(t, e);
						return null == n && null == o
							? null
							: (null == n && (n = t), null == o && (o = t), new qa(n, o));
					}
					static _createFromPositionAndShift(t, e) {
						const n = t,
							o = t.getShiftedBy(e);
						return e > 0 ? new this(n, o) : new this(o, n);
					}
					static _createIn(t) {
						return new this(Na._createAt(t, 0), Na._createAt(t, t.maxOffset));
					}
					static _createOn(t) {
						return this._createFromPositionAndShift(
							Na._createBefore(t),
							t.offsetSize,
						);
					}
					static _createFromRanges(t) {
						if (0 === t.length)
							throw new l.a("range-create-from-ranges-empty-array", null);
						if (1 == t.length) return t[0].clone();
						const e = t[0];
						t.sort((t, e) => (t.start.isAfter(e.start) ? 1 : -1));
						const n = t.indexOf(e),
							o = new this(e.start, e.end);
						if (n > 0)
							for (let e = n - 1; t[e].end.isEqual(o.start); e++)
								o.start = Na._createAt(t[e].start);
						for (let e = n + 1; e < t.length && t[e].start.isEqual(o.end); e++)
							o.end = Na._createAt(t[e].end);
						return o;
					}
					static fromJSON(t, e) {
						return new this(Na.fromJSON(t.start, e), Na.fromJSON(t.end, e));
					}
				}
				qa.prototype.is = function (t) {
					return "range" === t || "model:range" === t;
				};
				class Ua extends g {
					constructor() {
						super(),
							(this._modelToViewMapping = new WeakMap()),
							(this._viewToModelMapping = new WeakMap()),
							(this._viewToModelLengthCallbacks = new Map()),
							(this._markerNameToElements = new Map()),
							(this._elementToMarkerNames = new Map()),
							(this._deferredBindingRemovals = new Map()),
							(this._unboundMarkerNames = new Set()),
							this.on(
								"modelToViewPosition",
								(t, e) => {
									if (e.viewPosition) return;
									const n = this._modelToViewMapping.get(
										e.modelPosition.parent,
									);
									if (!n)
										throw new l.a(
											"mapping-model-position-view-parent-not-found",
											this,
											{ modelPosition: e.modelPosition },
										);
									e.viewPosition = this.findPositionIn(
										n,
										e.modelPosition.offset,
									);
								},
								{ priority: "low" },
							),
							this.on(
								"viewToModelPosition",
								(t, e) => {
									if (e.modelPosition) return;
									const n = this.findMappedViewAncestor(e.viewPosition),
										o = this._viewToModelMapping.get(n),
										i = this._toModelOffset(
											e.viewPosition.parent,
											e.viewPosition.offset,
											n,
										);
									e.modelPosition = Na._createAt(o, i);
								},
								{ priority: "low" },
							);
					}
					bindElements(t, e) {
						this._modelToViewMapping.set(t, e),
							this._viewToModelMapping.set(e, t);
					}
					unbindViewElement(t, e = {}) {
						const n = this.toModelElement(t);
						if (this._elementToMarkerNames.has(t))
							for (const e of this._elementToMarkerNames.get(t))
								this._unboundMarkerNames.add(e);
						e.defer
							? this._deferredBindingRemovals.set(t, t.root)
							: (this._viewToModelMapping.delete(t),
								this._modelToViewMapping.get(n) == t &&
									this._modelToViewMapping.delete(n));
					}
					unbindModelElement(t) {
						const e = this.toViewElement(t);
						this._modelToViewMapping.delete(t),
							this._viewToModelMapping.get(e) == t &&
								this._viewToModelMapping.delete(e);
					}
					bindElementToMarker(t, e) {
						const n = this._markerNameToElements.get(e) || new Set();
						n.add(t);
						const o = this._elementToMarkerNames.get(t) || new Set();
						o.add(e),
							this._markerNameToElements.set(e, n),
							this._elementToMarkerNames.set(t, o);
					}
					unbindElementFromMarkerName(t, e) {
						const n = this._markerNameToElements.get(e);
						n &&
							(n.delete(t),
							0 == n.size && this._markerNameToElements.delete(e));
						const o = this._elementToMarkerNames.get(t);
						o &&
							(o.delete(e),
							0 == o.size && this._elementToMarkerNames.delete(t));
					}
					flushUnboundMarkerNames() {
						const t = Array.from(this._unboundMarkerNames);
						return this._unboundMarkerNames.clear(), t;
					}
					flushDeferredBindings() {
						for (const [t, e] of this._deferredBindingRemovals)
							t.root == e && this.unbindViewElement(t);
						this._deferredBindingRemovals = new Map();
					}
					clearBindings() {
						(this._modelToViewMapping = new WeakMap()),
							(this._viewToModelMapping = new WeakMap()),
							(this._markerNameToElements = new Map()),
							(this._elementToMarkerNames = new Map()),
							(this._unboundMarkerNames = new Set()),
							(this._deferredBindingRemovals = new Map());
					}
					toModelElement(t) {
						return this._viewToModelMapping.get(t);
					}
					toViewElement(t) {
						return this._modelToViewMapping.get(t);
					}
					toModelRange(t) {
						return new qa(
							this.toModelPosition(t.start),
							this.toModelPosition(t.end),
						);
					}
					toViewRange(t) {
						return new xi(
							this.toViewPosition(t.start),
							this.toViewPosition(t.end),
						);
					}
					toModelPosition(t) {
						const e = { viewPosition: t, mapper: this };
						return this.fire("viewToModelPosition", e), e.modelPosition;
					}
					toViewPosition(t, e = {}) {
						const n = {
							modelPosition: t,
							mapper: this,
							isPhantom: e.isPhantom,
						};
						return this.fire("modelToViewPosition", n), n.viewPosition;
					}
					markerNameToElements(t) {
						const e = this._markerNameToElements.get(t);
						if (!e) return null;
						const n = new Set();
						for (const t of e)
							if (t.is("attributeElement"))
								for (const e of t.getElementsWithSameId()) n.add(e);
							else n.add(t);
						return n;
					}
					registerViewToModelLength(t, e) {
						this._viewToModelLengthCallbacks.set(t, e);
					}
					findMappedViewAncestor(t) {
						let e = t.parent;
						for (; !this._viewToModelMapping.has(e); ) e = e.parent;
						return e;
					}
					_toModelOffset(t, e, n) {
						if (n != t) {
							return (
								this._toModelOffset(t.parent, t.index, n) +
								this._toModelOffset(t, e, t)
							);
						}
						if (t.is("$text")) return e;
						let o = 0;
						for (let n = 0; n < e; n++) o += this.getModelLength(t.getChild(n));
						return o;
					}
					getModelLength(t) {
						if (this._viewToModelLengthCallbacks.get(t.name)) {
							return this._viewToModelLengthCallbacks.get(t.name)(t);
						}
						if (this._viewToModelMapping.has(t)) return 1;
						if (t.is("$text")) return t.data.length;
						if (t.is("uiElement")) return 0;
						{
							let e = 0;
							for (const n of t.getChildren()) e += this.getModelLength(n);
							return e;
						}
					}
					findPositionIn(t, e) {
						let n,
							o = 0,
							i = 0,
							r = 0;
						if (t.is("$text")) return new yi(t, e);
						for (; i < e; )
							(n = t.getChild(r)), (o = this.getModelLength(n)), (i += o), r++;
						return i == e
							? this._moveViewPositionToTextNode(new yi(t, r))
							: this.findPositionIn(n, e - (i - o));
					}
					_moveViewPositionToTextNode(t) {
						const e = t.nodeBefore,
							n = t.nodeAfter;
						return e instanceof go
							? new yi(e, e.data.length)
							: n instanceof go
								? new yi(n, 0)
								: t;
					}
				}
				class Wa {
					constructor() {
						(this._consumable = new Map()),
							(this._textProxyRegistry = new Map());
					}
					add(t, e) {
						(e = Ka(e)),
							t instanceof za && (t = this._getSymbolForTextProxy(t)),
							this._consumable.has(t) || this._consumable.set(t, new Map()),
							this._consumable.get(t).set(e, !0);
					}
					consume(t, e) {
						return (
							(e = Ka(e)),
							t instanceof za && (t = this._getSymbolForTextProxy(t)),
							!!this.test(t, e) && (this._consumable.get(t).set(e, !1), !0)
						);
					}
					test(t, e) {
						(e = Ka(e)),
							t instanceof za && (t = this._getSymbolForTextProxy(t));
						const n = this._consumable.get(t);
						if (void 0 === n) return null;
						const o = n.get(e);
						return void 0 === o ? null : o;
					}
					revert(t, e) {
						(e = Ka(e)),
							t instanceof za && (t = this._getSymbolForTextProxy(t));
						const n = this.test(t, e);
						return !1 === n
							? (this._consumable.get(t).set(e, !0), !0)
							: !0 !== n && null;
					}
					verifyAllConsumed(t) {
						const e = [];
						for (const [n, o] of this._consumable)
							for (const [i, r] of o) {
								const o = i.split(":")[0];
								r &&
									t == o &&
									e.push({ event: i, item: n.name || n.description });
							}
						if (e.length)
							throw new l.a("conversion-model-consumable-not-consumed", null, {
								items: e,
							});
					}
					_getSymbolForTextProxy(t) {
						let e = null;
						const n = this._textProxyRegistry.get(t.startOffset);
						if (n) {
							const o = n.get(t.endOffset);
							o && (e = o.get(t.parent));
						}
						return e || (e = this._addSymbolForTextProxy(t)), e;
					}
					_addSymbolForTextProxy(t) {
						const e = t.startOffset,
							n = t.endOffset,
							o = t.parent,
							i = Symbol("$textProxy:" + t.data);
						let r, s;
						return (
							(r = this._textProxyRegistry.get(e)),
							r || ((r = new Map()), this._textProxyRegistry.set(e, r)),
							(s = r.get(n)),
							s || ((s = new Map()), r.set(n, s)),
							s.set(o, i),
							i
						);
					}
				}
				function Ka(t) {
					const e = t.split(":");
					return "insert" == e[0]
						? e[0]
						: "addMarker" == e[0] || "removeMarker" == e[0]
							? t
							: e.length > 1
								? e[0] + ":" + e[1]
								: e[0];
				}
				class Ga extends g {
					constructor(t) {
						super(),
							(this._conversionApi = { dispatcher: this, ...t }),
							(this._firedEventsMap = new WeakMap());
					}
					convertChanges(t, e, n) {
						const o = this._createConversionApi(n, t.getRefreshedItems());
						for (const e of t.getMarkersToRemove())
							this._convertMarkerRemove(e.name, e.range, o);
						const i = this._reduceChanges(t.getChanges());
						for (const t of i)
							"insert" === t.type
								? this._convertInsert(
										qa._createFromPositionAndShift(t.position, t.length),
										o,
									)
								: "reinsert" === t.type
									? this._convertReinsert(
											qa._createFromPositionAndShift(t.position, t.length),
											o,
										)
									: "remove" === t.type
										? this._convertRemove(t.position, t.length, t.name, o)
										: this._convertAttribute(
												t.range,
												t.attributeKey,
												t.attributeOldValue,
												t.attributeNewValue,
												o,
											);
						for (const t of o.mapper.flushUnboundMarkerNames()) {
							const n = e.get(t).getRange();
							this._convertMarkerRemove(t, n, o),
								this._convertMarkerAdd(t, n, o);
						}
						for (const e of t.getMarkersToAdd())
							this._convertMarkerAdd(e.name, e.range, o);
						o.mapper.flushDeferredBindings(),
							o.consumable.verifyAllConsumed("insert");
					}
					convert(t, e, n, o = {}) {
						const i = this._createConversionApi(n, void 0, o);
						this._convertInsert(t, i);
						for (const [t, n] of e) this._convertMarkerAdd(t, n, i);
						i.consumable.verifyAllConsumed("insert");
					}
					convertSelection(t, e, n) {
						const o = Array.from(e.getMarkersAtPosition(t.getFirstPosition())),
							i = this._createConversionApi(n);
						if (
							(this._addConsumablesForSelection(i.consumable, t, o),
							this.fire("selection", { selection: t }, i),
							t.isCollapsed)
						) {
							for (const e of o) {
								const n = e.getRange();
								if (!Ja(t.getFirstPosition(), e, i.mapper)) continue;
								const o = { item: t, markerName: e.name, markerRange: n };
								i.consumable.test(t, "addMarker:" + e.name) &&
									this.fire(`addMarker:${e.name}`, o, i);
							}
							for (const e of t.getAttributeKeys()) {
								const n = {
									item: t,
									range: t.getFirstRange(),
									attributeKey: e,
									attributeOldValue: null,
									attributeNewValue: t.getAttribute(e),
								};
								i.consumable.test(t, "attribute:" + n.attributeKey) &&
									this.fire(`attribute:${n.attributeKey}:$text`, n, i);
							}
						}
					}
					_convertInsert(t, e, n = {}) {
						n.doNotAddConsumables ||
							this._addConsumablesForInsert(e.consumable, Array.from(t));
						for (const n of Array.from(t.getWalker({ shallow: !0 })).map(Ya))
							this._testAndFire("insert", n, e);
					}
					_convertRemove(t, e, n, o) {
						this.fire(`remove:${n}`, { position: t, length: e }, o);
					}
					_convertAttribute(t, e, n, o, i) {
						this._addConsumablesForRange(i.consumable, t, `attribute:${e}`);
						for (const r of t) {
							const t = {
								item: r.item,
								range: qa._createFromPositionAndShift(
									r.previousPosition,
									r.length,
								),
								attributeKey: e,
								attributeOldValue: n,
								attributeNewValue: o,
							};
							this._testAndFire(`attribute:${e}`, t, i);
						}
					}
					_convertReinsert(t, e) {
						const n = Array.from(t.getWalker({ shallow: !0 }));
						this._addConsumablesForInsert(e.consumable, n);
						for (const t of n.map(Ya))
							this._testAndFire("insert", { ...t, reconversion: !0 }, e);
					}
					_convertMarkerAdd(t, e, n) {
						if ("$graveyard" == e.root.rootName) return;
						const o = `addMarker:${t}`;
						if (
							(n.consumable.add(e, o),
							this.fire(o, { markerName: t, markerRange: e }, n),
							n.consumable.consume(e, o))
						) {
							this._addConsumablesForRange(n.consumable, e, o);
							for (const i of e.getItems()) {
								if (!n.consumable.test(i, o)) continue;
								const r = {
									item: i,
									range: qa._createOn(i),
									markerName: t,
									markerRange: e,
								};
								this.fire(o, r, n);
							}
						}
					}
					_convertMarkerRemove(t, e, n) {
						"$graveyard" != e.root.rootName &&
							this.fire(
								`removeMarker:${t}`,
								{ markerName: t, markerRange: e },
								n,
							);
					}
					_reduceChanges(t) {
						const e = { changes: t };
						return this.fire("reduceChanges", e), e.changes;
					}
					_addConsumablesForInsert(t, e) {
						for (const n of e) {
							const e = n.item;
							if (null === t.test(e, "insert")) {
								t.add(e, "insert");
								for (const n of e.getAttributeKeys())
									t.add(e, "attribute:" + n);
							}
						}
						return t;
					}
					_addConsumablesForRange(t, e, n) {
						for (const o of e.getItems()) t.add(o, n);
						return t;
					}
					_addConsumablesForSelection(t, e, n) {
						t.add(e, "selection");
						for (const o of n) t.add(e, "addMarker:" + o.name);
						for (const n of e.getAttributeKeys()) t.add(e, "attribute:" + n);
						return t;
					}
					_testAndFire(t, e, n) {
						const o = (function (t, e) {
								const n = e.item.is("element") ? e.item.name : "$text";
								return `${t}:${n}`;
							})(t, e),
							i = e.item.is("$textProxy")
								? n.consumable._getSymbolForTextProxy(e.item)
								: e.item,
							r = this._firedEventsMap.get(n),
							s = r.get(i);
						if (s) {
							if (s.has(o)) return;
							s.add(o);
						} else r.set(i, new Set([o]));
						this.fire(o, e, n);
					}
					_testAndFireAddAttributes(t, e) {
						const n = { item: t, range: qa._createOn(t) };
						for (const t of n.item.getAttributeKeys())
							(n.attributeKey = t),
								(n.attributeOldValue = null),
								(n.attributeNewValue = n.item.getAttribute(t)),
								this._testAndFire(`attribute:${t}`, n, e);
					}
					_createConversionApi(t, e = new Set(), n = {}) {
						const o = {
							...this._conversionApi,
							consumable: new Wa(),
							writer: t,
							options: n,
							convertItem: (t) => this._convertInsert(qa._createOn(t), o),
							convertChildren: (t) =>
								this._convertInsert(qa._createIn(t), o, {
									doNotAddConsumables: !0,
								}),
							convertAttributes: (t) => this._testAndFireAddAttributes(t, o),
							canReuseView: (t) => !e.has(o.mapper.toModelElement(t)),
						};
						return this._firedEventsMap.set(o, new Map()), o;
					}
				}
				function Ja(t, e, n) {
					const o = e.getRange(),
						i = Array.from(t.getAncestors());
					i.shift(), i.reverse();
					return !i.some((t) => {
						if (o.containsItem(t)) {
							return !!n.toViewElement(t).getCustomProperty("addHighlight");
						}
					});
				}
				function Ya(t) {
					return {
						item: t.item,
						range: qa._createFromPositionAndShift(t.previousPosition, t.length),
					};
				}
				class Qa extends p(Ta) {
					constructor(...t) {
						super(),
							(this._lastRangeBackward = !1),
							(this._ranges = []),
							(this._attrs = new Map()),
							t.length && this.setTo(...t);
					}
					get anchor() {
						if (this._ranges.length > 0) {
							const t = this._ranges[this._ranges.length - 1];
							return this._lastRangeBackward ? t.end : t.start;
						}
						return null;
					}
					get focus() {
						if (this._ranges.length > 0) {
							const t = this._ranges[this._ranges.length - 1];
							return this._lastRangeBackward ? t.start : t.end;
						}
						return null;
					}
					get isCollapsed() {
						return 1 === this._ranges.length && this._ranges[0].isCollapsed;
					}
					get rangeCount() {
						return this._ranges.length;
					}
					get isBackward() {
						return !this.isCollapsed && this._lastRangeBackward;
					}
					isEqual(t) {
						if (this.rangeCount != t.rangeCount) return !1;
						if (0 === this.rangeCount) return !0;
						if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus))
							return !1;
						for (const e of this._ranges) {
							let n = !1;
							for (const o of t._ranges)
								if (e.isEqual(o)) {
									n = !0;
									break;
								}
							if (!n) return !1;
						}
						return !0;
					}
					*getRanges() {
						for (const t of this._ranges) yield new qa(t.start, t.end);
					}
					getFirstRange() {
						let t = null;
						for (const e of this._ranges)
							(t && !e.start.isBefore(t.start)) || (t = e);
						return t ? new qa(t.start, t.end) : null;
					}
					getLastRange() {
						let t = null;
						for (const e of this._ranges)
							(t && !e.end.isAfter(t.end)) || (t = e);
						return t ? new qa(t.start, t.end) : null;
					}
					getFirstPosition() {
						const t = this.getFirstRange();
						return t ? t.start.clone() : null;
					}
					getLastPosition() {
						const t = this.getLastRange();
						return t ? t.end.clone() : null;
					}
					setTo(...t) {
						let [e, n, o] = t;
						if (("object" == typeof n && ((o = n), (n = void 0)), null === e))
							this._setRanges([]);
						else if (e instanceof Qa)
							this._setRanges(e.getRanges(), e.isBackward);
						else if (e && "function" == typeof e.getRanges)
							this._setRanges(e.getRanges(), e.isBackward);
						else if (e instanceof qa) this._setRanges([e], !!o && !!o.backward);
						else if (e instanceof Na) this._setRanges([new qa(e)]);
						else if (e instanceof Pa) {
							const t = !!o && !!o.backward;
							let i;
							if ("in" == n) i = qa._createIn(e);
							else if ("on" == n) i = qa._createOn(e);
							else {
								if (void 0 === n)
									throw new l.a(
										"model-selection-setto-required-second-parameter",
										[this, e],
									);
								i = new qa(Na._createAt(e, n));
							}
							this._setRanges([i], t);
						} else {
							if (!Qn(e))
								throw new l.a("model-selection-setto-not-selectable", [
									this,
									e,
								]);
							this._setRanges(e, o && !!o.backward);
						}
					}
					_setRanges(t, e = !1) {
						const n = Array.from(t),
							o = n.some((e) => {
								if (!(e instanceof qa))
									throw new l.a("model-selection-set-ranges-not-range", [
										this,
										t,
									]);
								return this._ranges.every((t) => !t.isEqual(e));
							});
						(n.length !== this._ranges.length || o) &&
							(this._replaceAllRanges(n),
							(this._lastRangeBackward = !!e),
							this.fire("change:range", { directChange: !0 }));
					}
					setFocus(t, e) {
						if (null === this.anchor)
							throw new l.a("model-selection-setfocus-no-ranges", [this, t]);
						const n = Na._createAt(t, e);
						if ("same" == n.compareWith(this.focus)) return;
						const o = this.anchor;
						this._ranges.length && this._popRange(),
							"before" == n.compareWith(o)
								? (this._pushRange(new qa(n, o)),
									(this._lastRangeBackward = !0))
								: (this._pushRange(new qa(o, n)),
									(this._lastRangeBackward = !1)),
							this.fire("change:range", { directChange: !0 });
					}
					getAttribute(t) {
						return this._attrs.get(t);
					}
					getAttributes() {
						return this._attrs.entries();
					}
					getAttributeKeys() {
						return this._attrs.keys();
					}
					hasAttribute(t) {
						return this._attrs.has(t);
					}
					removeAttribute(t) {
						this.hasAttribute(t) &&
							(this._attrs.delete(t),
							this.fire("change:attribute", {
								attributeKeys: [t],
								directChange: !0,
							}));
					}
					setAttribute(t, e) {
						this.getAttribute(t) !== e &&
							(this._attrs.set(t, e),
							this.fire("change:attribute", {
								attributeKeys: [t],
								directChange: !0,
							}));
					}
					getSelectedElement() {
						return 1 !== this.rangeCount
							? null
							: this.getFirstRange().getContainedElement();
					}
					*getSelectedBlocks() {
						const t = new WeakSet();
						for (const e of this.getRanges()) {
							const n = tc(e.start, t);
							n && ec(n, e) && (yield n);
							for (const n of e.getWalker()) {
								const o = n.item;
								"elementEnd" == n.type && Za(o, t, e) && (yield o);
							}
							const o = tc(e.end, t);
							o &&
								!e.end.isTouching(Na._createAt(o, 0)) &&
								ec(o, e) &&
								(yield o);
						}
					}
					containsEntireContent(t = this.anchor.root) {
						const e = Na._createAt(t, 0),
							n = Na._createAt(t, "end");
						return (
							e.isTouching(this.getFirstPosition()) &&
							n.isTouching(this.getLastPosition())
						);
					}
					_pushRange(t) {
						this._checkRange(t), this._ranges.push(new qa(t.start, t.end));
					}
					_checkRange(t) {
						for (let e = 0; e < this._ranges.length; e++)
							if (t.isIntersecting(this._ranges[e]))
								throw new l.a("model-selection-range-intersects", [this, t], {
									addedRange: t,
									intersectingRange: this._ranges[e],
								});
					}
					_replaceAllRanges(t) {
						this._removeAllRanges();
						for (const e of t) this._pushRange(e);
					}
					_removeAllRanges() {
						for (; this._ranges.length > 0; ) this._popRange();
					}
					_popRange() {
						this._ranges.pop();
					}
				}
				function Xa(t, e) {
					return (
						!e.has(t) &&
						(e.add(t), t.root.document.model.schema.isBlock(t) && !!t.parent)
					);
				}
				function Za(t, e, n) {
					return Xa(t, e) && ec(t, n);
				}
				function tc(t, e) {
					const n = t.parent.root.document.model.schema,
						o = t.parent.getAncestors({ parentFirst: !0, includeSelf: !0 });
					let i = !1;
					const r = o.find((t) => !i && ((i = n.isLimit(t)), !i && Xa(t, e)));
					return o.forEach((t) => e.add(t)), r;
				}
				function ec(t, e) {
					const n = (function (t) {
						const e = t.root.document.model.schema;
						let n = t.parent;
						for (; n; ) {
							if (e.isBlock(n)) return n;
							n = n.parent;
						}
					})(t);
					if (!n) return !0;
					return !e.containsRange(qa._createOn(n), !0);
				}
				Qa.prototype.is = function (t) {
					return "selection" === t || "model:selection" === t;
				};
				class nc extends p(qa) {
					constructor(t, e) {
						super(t, e), oc.call(this);
					}
					detach() {
						this.stopListening();
					}
					toRange() {
						return new qa(this.start, this.end);
					}
					static fromRange(t) {
						return new nc(t.start, t.end);
					}
				}
				function oc() {
					this.listenTo(
						this.root.document.model,
						"applyOperation",
						(t, e) => {
							const n = e[0];
							n.isDocumentOperation && ic.call(this, n);
						},
						{ priority: "low" },
					);
				}
				function ic(t) {
					const e = this.getTransformedByOperation(t),
						n = qa._createFromRanges(e),
						o = !n.isEqual(this),
						i = (function (t, e) {
							switch (e.type) {
								case "insert":
									return t.containsPosition(e.position);
								case "move":
								case "remove":
								case "reinsert":
								case "merge":
									return (
										t.containsPosition(e.sourcePosition) ||
										t.start.isEqual(e.sourcePosition) ||
										t.containsPosition(e.targetPosition)
									);
								case "split":
									return (
										t.containsPosition(e.splitPosition) ||
										t.containsPosition(e.insertionPosition)
									);
							}
							return !1;
						})(this, t);
					let r = null;
					if (o) {
						"$graveyard" == n.root.rootName &&
							(r = "remove" == t.type ? t.sourcePosition : t.deletionPosition);
						const e = this.toRange();
						(this.start = n.start),
							(this.end = n.end),
							this.fire("change:range", e, { deletionPosition: r });
					} else
						i &&
							this.fire("change:content", this.toRange(), {
								deletionPosition: r,
							});
				}
				nc.prototype.is = function (t) {
					return (
						"liveRange" === t ||
						"model:liveRange" === t ||
						"range" == t ||
						"model:range" === t
					);
				};
				const rc = "selection:";
				class sc extends p(Ta) {
					constructor(t) {
						super(),
							(this._selection = new ac(t)),
							this._selection.delegate("change:range").to(this),
							this._selection.delegate("change:attribute").to(this),
							this._selection.delegate("change:marker").to(this);
					}
					get isCollapsed() {
						return this._selection.isCollapsed;
					}
					get anchor() {
						return this._selection.anchor;
					}
					get focus() {
						return this._selection.focus;
					}
					get rangeCount() {
						return this._selection.rangeCount;
					}
					get hasOwnRange() {
						return this._selection.hasOwnRange;
					}
					get isBackward() {
						return this._selection.isBackward;
					}
					get isGravityOverridden() {
						return this._selection.isGravityOverridden;
					}
					get markers() {
						return this._selection.markers;
					}
					get _ranges() {
						return this._selection._ranges;
					}
					getRanges() {
						return this._selection.getRanges();
					}
					getFirstPosition() {
						return this._selection.getFirstPosition();
					}
					getLastPosition() {
						return this._selection.getLastPosition();
					}
					getFirstRange() {
						return this._selection.getFirstRange();
					}
					getLastRange() {
						return this._selection.getLastRange();
					}
					getSelectedBlocks() {
						return this._selection.getSelectedBlocks();
					}
					getSelectedElement() {
						return this._selection.getSelectedElement();
					}
					containsEntireContent(t) {
						return this._selection.containsEntireContent(t);
					}
					destroy() {
						this._selection.destroy();
					}
					getAttributeKeys() {
						return this._selection.getAttributeKeys();
					}
					getAttributes() {
						return this._selection.getAttributes();
					}
					getAttribute(t) {
						return this._selection.getAttribute(t);
					}
					hasAttribute(t) {
						return this._selection.hasAttribute(t);
					}
					refresh() {
						this._selection.updateMarkers(),
							this._selection._updateAttributes(!1);
					}
					observeMarkers(t) {
						this._selection.observeMarkers(t);
					}
					_setFocus(t, e) {
						this._selection.setFocus(t, e);
					}
					_setTo(...t) {
						this._selection.setTo(...t);
					}
					_setAttribute(t, e) {
						this._selection.setAttribute(t, e);
					}
					_removeAttribute(t) {
						this._selection.removeAttribute(t);
					}
					_getStoredAttributes() {
						return this._selection.getStoredAttributes();
					}
					_overrideGravity() {
						return this._selection.overrideGravity();
					}
					_restoreGravity(t) {
						this._selection.restoreGravity(t);
					}
					static _getStoreAttributeKey(t) {
						return rc + t;
					}
					static _isStoreAttributeKey(t) {
						return t.startsWith(rc);
					}
				}
				sc.prototype.is = function (t) {
					return (
						"selection" === t ||
						"model:selection" == t ||
						"documentSelection" == t ||
						"model:documentSelection" == t
					);
				};
				class ac extends Qa {
					constructor(t) {
						super(),
							(this.markers = new Xn({ idProperty: "name" })),
							(this._model = t.model),
							(this._document = t),
							(this._attributePriority = new Map()),
							(this._selectionRestorePosition = null),
							(this._hasChangedRange = !1),
							(this._overriddenGravityRegister = new Set()),
							(this._observedMarkers = new Set()),
							this.listenTo(
								this._model,
								"applyOperation",
								(t, e) => {
									const n = e[0];
									n.isDocumentOperation &&
										"marker" != n.type &&
										"rename" != n.type &&
										"noop" != n.type &&
										(0 == this._ranges.length &&
											this._selectionRestorePosition &&
											this._fixGraveyardSelection(
												this._selectionRestorePosition,
											),
										(this._selectionRestorePosition = null),
										this._hasChangedRange &&
											((this._hasChangedRange = !1),
											this.fire("change:range", { directChange: !1 })));
								},
								{ priority: "lowest" },
							),
							this.on("change:range", () => {
								this._validateSelectionRanges(this.getRanges());
							}),
							this.listenTo(this._model.markers, "update", (t, e, n, o) => {
								this._updateMarker(e, o);
							}),
							this.listenTo(this._document, "change", (t, e) => {
								!(function (t, e) {
									const n = t.document.differ;
									for (const o of n.getChanges()) {
										if ("insert" != o.type) continue;
										const n = o.position.parent;
										o.length === n.maxOffset &&
											t.enqueueChange(e, (t) => {
												const e = Array.from(n.getAttributeKeys()).filter((t) =>
													t.startsWith(rc),
												);
												for (const o of e) t.removeAttribute(o, n);
											});
									}
								})(this._model, e);
							});
					}
					get isCollapsed() {
						return 0 === this._ranges.length
							? this._document._getDefaultRange().isCollapsed
							: super.isCollapsed;
					}
					get anchor() {
						return super.anchor || this._document._getDefaultRange().start;
					}
					get focus() {
						return super.focus || this._document._getDefaultRange().end;
					}
					get rangeCount() {
						return this._ranges.length ? this._ranges.length : 1;
					}
					get hasOwnRange() {
						return this._ranges.length > 0;
					}
					get isGravityOverridden() {
						return !!this._overriddenGravityRegister.size;
					}
					destroy() {
						for (let t = 0; t < this._ranges.length; t++)
							this._ranges[t].detach();
						this.stopListening();
					}
					*getRanges() {
						this._ranges.length
							? yield* super.getRanges()
							: yield this._document._getDefaultRange();
					}
					getFirstRange() {
						return super.getFirstRange() || this._document._getDefaultRange();
					}
					getLastRange() {
						return super.getLastRange() || this._document._getDefaultRange();
					}
					setTo(...t) {
						super.setTo(...t), this._updateAttributes(!0), this.updateMarkers();
					}
					setFocus(t, e) {
						super.setFocus(t, e),
							this._updateAttributes(!0),
							this.updateMarkers();
					}
					setAttribute(t, e) {
						if (this._setAttribute(t, e)) {
							const e = [t];
							this.fire("change:attribute", {
								attributeKeys: e,
								directChange: !0,
							});
						}
					}
					removeAttribute(t) {
						if (this._removeAttribute(t)) {
							const e = [t];
							this.fire("change:attribute", {
								attributeKeys: e,
								directChange: !0,
							});
						}
					}
					overrideGravity() {
						const t = s();
						return (
							this._overriddenGravityRegister.add(t),
							1 === this._overriddenGravityRegister.size &&
								this._updateAttributes(!0),
							t
						);
					}
					restoreGravity(t) {
						if (!this._overriddenGravityRegister.has(t))
							throw new l.a("document-selection-gravity-wrong-restore", this, {
								uid: t,
							});
						this._overriddenGravityRegister.delete(t),
							this.isGravityOverridden || this._updateAttributes(!0);
					}
					observeMarkers(t) {
						this._observedMarkers.add(t), this.updateMarkers();
					}
					_replaceAllRanges(t) {
						this._validateSelectionRanges(t), super._replaceAllRanges(t);
					}
					_popRange() {
						this._ranges.pop().detach();
					}
					_pushRange(t) {
						const e = this._prepareRange(t);
						e && this._ranges.push(e);
					}
					_validateSelectionRanges(t) {
						for (const e of t)
							if (!this._document._validateSelectionRange(e))
								throw new l.a("document-selection-wrong-position", this, {
									range: e,
								});
					}
					_prepareRange(t) {
						if ((this._checkRange(t), t.root == this._document.graveyard))
							return;
						const e = nc.fromRange(t);
						return (
							e.on("change:range", (t, n, o) => {
								if (
									((this._hasChangedRange = !0),
									e.root == this._document.graveyard)
								) {
									this._selectionRestorePosition = o.deletionPosition;
									const t = this._ranges.indexOf(e);
									this._ranges.splice(t, 1), e.detach();
								}
							}),
							e
						);
					}
					updateMarkers() {
						if (!this._observedMarkers.size) return;
						const t = [];
						let e = !1;
						for (const e of this._model.markers) {
							const n = e.name.split(":", 1)[0];
							if (!this._observedMarkers.has(n)) continue;
							const o = e.getRange();
							for (const n of this.getRanges())
								o.containsRange(n, !n.isCollapsed) && t.push(e);
						}
						const n = Array.from(this.markers);
						for (const n of t)
							this.markers.has(n) || (this.markers.add(n), (e = !0));
						for (const n of Array.from(this.markers))
							t.includes(n) || (this.markers.remove(n), (e = !0));
						e &&
							this.fire("change:marker", { oldMarkers: n, directChange: !1 });
					}
					_updateMarker(t, e) {
						const n = t.name.split(":", 1)[0];
						if (!this._observedMarkers.has(n)) return;
						let o = !1;
						const i = Array.from(this.markers),
							r = this.markers.has(t);
						if (e) {
							let n = !1;
							for (const t of this.getRanges())
								if (e.containsRange(t, !t.isCollapsed)) {
									n = !0;
									break;
								}
							n && !r
								? (this.markers.add(t), (o = !0))
								: !n && r && (this.markers.remove(t), (o = !0));
						} else r && (this.markers.remove(t), (o = !0));
						o &&
							this.fire("change:marker", { oldMarkers: i, directChange: !1 });
					}
					_updateAttributes(t) {
						const e = mo(this._getSurroundingAttributes()),
							n = mo(this.getAttributes());
						if (t)
							(this._attributePriority = new Map()), (this._attrs = new Map());
						else
							for (const [t, e] of this._attributePriority)
								"low" == e &&
									(this._attrs.delete(t), this._attributePriority.delete(t));
						this._setAttributesTo(e);
						const o = [];
						for (const [t, e] of this.getAttributes())
							(n.has(t) && n.get(t) === e) || o.push(t);
						for (const [t] of n) this.hasAttribute(t) || o.push(t);
						o.length > 0 &&
							this.fire("change:attribute", {
								attributeKeys: o,
								directChange: !1,
							});
					}
					_setAttribute(t, e, n = !0) {
						const o = n ? "normal" : "low";
						if ("low" == o && "normal" == this._attributePriority.get(t))
							return !1;
						return (
							super.getAttribute(t) !== e &&
							(this._attrs.set(t, e), this._attributePriority.set(t, o), !0)
						);
					}
					_removeAttribute(t, e = !0) {
						const n = e ? "normal" : "low";
						return (
							("low" != n || "normal" != this._attributePriority.get(t)) &&
							(this._attributePriority.set(t, n),
							!!super.hasAttribute(t) && (this._attrs.delete(t), !0))
						);
					}
					_setAttributesTo(t) {
						const e = new Set();
						for (const [e, n] of this.getAttributes())
							t.get(e) !== n && this._removeAttribute(e, !1);
						for (const [n, o] of t) {
							this._setAttribute(n, o, !1) && e.add(n);
						}
						return e;
					}
					*getStoredAttributes() {
						const t = this.getFirstPosition().parent;
						if (this.isCollapsed && t.isEmpty)
							for (const e of t.getAttributeKeys())
								if (e.startsWith(rc)) {
									const n = e.substr(rc.length);
									yield [n, t.getAttribute(e)];
								}
					}
					_getSurroundingAttributes() {
						const t = this.getFirstPosition(),
							e = this._model.schema;
						let n = null;
						if (this.isCollapsed) {
							const o = t.textNode ? t.textNode : t.nodeBefore,
								i = t.textNode ? t.textNode : t.nodeAfter;
							if (
								(this.isGravityOverridden || (n = cc(o)),
								n || (n = cc(i)),
								!this.isGravityOverridden && !n)
							) {
								let t = o;
								for (; t && !e.isInline(t) && !n; )
									(t = t.previousSibling), (n = cc(t));
							}
							if (!n) {
								let t = i;
								for (; t && !e.isInline(t) && !n; )
									(t = t.nextSibling), (n = cc(t));
							}
							n || (n = this.getStoredAttributes());
						} else {
							const t = this.getFirstRange();
							for (const o of t) {
								if (o.item.is("element") && e.isObject(o.item)) break;
								if ("text" == o.type) {
									n = o.item.getAttributes();
									break;
								}
							}
						}
						return n;
					}
					_fixGraveyardSelection(t) {
						const e = this._model.schema.getNearestSelectionRange(t);
						e && this._pushRange(e);
					}
				}
				function cc(t) {
					return t instanceof za || t instanceof Ia ? t.getAttributes() : null;
				}
				class lc {
					constructor(t) {
						this._dispatchers = t;
					}
					add(t) {
						for (const e of this._dispatchers) t(e);
						return this;
					}
				}
				var dc = function (t) {
					return Un(t, 5);
				};
				class uc extends lc {
					elementToElement(t) {
						return this.add(
							(function (t) {
								const e = gc(t.model),
									n = fc(t.view, "container");
								e.attributes.length && (e.children = !0);
								return (o) => {
									o.on(
										`insert:${e.name}`,
										(function (t, e = vc) {
											return (n, o, i) => {
												if (!e(o.item, i.consumable, { preflight: !0 })) return;
												const r = t(o.item, i, o);
												if (!r) return;
												e(o.item, i.consumable);
												const s = i.mapper.toViewPosition(o.range.start);
												i.mapper.bindElements(o.item, r),
													i.writer.insert(s, r),
													i.convertAttributes(o.item),
													_c(r, o.item.getChildren(), i, {
														reconversion: o.reconversion,
													});
											};
										})(n, Ac(e)),
										{ priority: t.converterPriority || "normal" },
									),
										(e.children || e.attributes.length) &&
											o.on("reduceChanges", wc(e), { priority: "low" });
								};
							})(t),
						);
					}
					elementToStructure(t) {
						return this.add(
							(function (t) {
								const e = gc(t.model),
									n = fc(t.view, "container");
								return (
									(e.children = !0),
									(o) => {
										if (o._conversionApi.schema.checkChild(e.name, "$text"))
											throw new l.a(
												"conversion-element-to-structure-disallowed-text",
												o,
												{ elementName: e.name },
											);
										var i, r;
										o.on(
											`insert:${e.name}`,
											((i = n),
											(r = Ac(e)),
											(t, e, n) => {
												if (!r(e.item, n.consumable, { preflight: !0 })) return;
												const o = new Map();
												n.writer._registerSlotFactory(
													(function (t, e, n) {
														return (o, i = "children") => {
															const r = o.createContainerElement("$slot");
															let s = null;
															if ("children" === i)
																s = Array.from(t.getChildren());
															else {
																if ("function" != typeof i)
																	throw new l.a(
																		"conversion-slot-mode-unknown",
																		n.dispatcher,
																		{ modeOrFilter: i },
																	);
																s = Array.from(t.getChildren()).filter((t) =>
																	i(t),
																);
															}
															return e.set(r, s), r;
														};
													})(e.item, o, n),
												);
												const s = i(e.item, n, e);
												if ((n.writer._clearSlotFactory(), !s)) return;
												!(function (t, e, n) {
													const o = Array.from(e.values()).flat(),
														i = new Set(o);
													if (i.size != o.length)
														throw new l.a(
															"conversion-slot-filter-overlap",
															n.dispatcher,
															{ element: t },
														);
													if (i.size != t.childCount)
														throw new l.a(
															"conversion-slot-filter-incomplete",
															n.dispatcher,
															{ element: t },
														);
												})(e.item, o, n),
													r(e.item, n.consumable);
												const a = n.mapper.toViewPosition(e.range.start);
												n.mapper.bindElements(e.item, s),
													n.writer.insert(a, s),
													n.convertAttributes(e.item),
													(function (t, e, n, o) {
														n.mapper.on("modelToViewPosition", s, {
															priority: "highest",
														});
														let i = null,
															r = null;
														for ([i, r] of e)
															_c(t, r, n, o),
																n.writer.move(
																	n.writer.createRangeIn(i),
																	n.writer.createPositionBefore(i),
																),
																n.writer.remove(i);
														function s(t, e) {
															const n = e.modelPosition.nodeAfter,
																o = r.indexOf(n);
															o < 0 ||
																(e.viewPosition = e.mapper.findPositionIn(
																	i,
																	o,
																));
														}
														n.mapper.off("modelToViewPosition", s);
													})(s, o, n, { reconversion: e.reconversion });
											}),
											{ priority: t.converterPriority || "normal" },
										),
											o.on("reduceChanges", wc(e), { priority: "low" });
									}
								);
							})(t),
						);
					}
					attributeToElement(t) {
						return this.add(
							(function (t) {
								let e = (t = dc(t)).model;
								"string" == typeof e && (e = { key: e });
								let n = `attribute:${e.key}`;
								e.name && (n += ":" + e.name);
								if (e.values)
									for (const n of e.values)
										t.view[n] = fc(t.view[n], "attribute");
								else t.view = fc(t.view, "attribute");
								const o = mc(t);
								return (e) => {
									e.on(
										n,
										(function (t) {
											return (e, n, o) => {
												if (!o.consumable.test(n.item, e.name)) return;
												const i = t(n.attributeOldValue, o, n),
													r = t(n.attributeNewValue, o, n);
												if (!i && !r) return;
												o.consumable.consume(n.item, e.name);
												const s = o.writer,
													a = s.document.selection;
												if (n.item instanceof Qa || n.item instanceof sc)
													s.wrap(a.getFirstRange(), r);
												else {
													let t = o.mapper.toViewRange(n.range);
													null !== n.attributeOldValue &&
														i &&
														(t = s.unwrap(t, i)),
														null !== n.attributeNewValue && r && s.wrap(t, r);
												}
											};
										})(o),
										{ priority: t.converterPriority || "normal" },
									);
								};
							})(t),
						);
					}
					attributeToAttribute(t) {
						return this.add(
							(function (t) {
								let e = (t = dc(t)).model;
								"string" == typeof e && (e = { key: e });
								let n = `attribute:${e.key}`;
								e.name && (n += ":" + e.name);
								if (e.values)
									for (const n of e.values) t.view[n] = kc(t.view[n]);
								else t.view = kc(t.view);
								const o = mc(t);
								return (e) => {
									var i;
									e.on(
										n,
										((i = o),
										(t, e, n) => {
											if (!n.consumable.test(e.item, t.name)) return;
											const o = i(e.attributeOldValue, n, e),
												r = i(e.attributeNewValue, n, e);
											if (!o && !r) return;
											n.consumable.consume(e.item, t.name);
											const s = n.mapper.toViewElement(e.item),
												a = n.writer;
											if (!s)
												throw new l.a(
													"conversion-attribute-to-attribute-on-text",
													n.dispatcher,
													e,
												);
											if (null !== e.attributeOldValue && o)
												if ("class" == o.key) {
													const t = to(o.value);
													for (const e of t) a.removeClass(e, s);
												} else if ("style" == o.key) {
													const t = Object.keys(o.value);
													for (const e of t) a.removeStyle(e, s);
												} else a.removeAttribute(o.key, s);
											if (null !== e.attributeNewValue && r)
												if ("class" == r.key) {
													const t = to(r.value);
													for (const e of t) a.addClass(e, s);
												} else if ("style" == r.key) {
													const t = Object.keys(r.value);
													for (const e of t) a.setStyle(e, r.value[e], s);
												} else a.setAttribute(r.key, r.value, s);
										}),
										{ priority: t.converterPriority || "normal" },
									);
								};
							})(t),
						);
					}
					markerToElement(t) {
						return this.add(
							(function (t) {
								const e = fc(t.view, "ui");
								return (n) => {
									var o;
									n.on(
										`addMarker:${t.model}`,
										((o = e),
										(t, e, n) => {
											e.isOpening = !0;
											const i = o(e, n);
											e.isOpening = !1;
											const r = o(e, n);
											if (!i || !r) return;
											const s = e.markerRange;
											if (s.isCollapsed && !n.consumable.consume(s, t.name))
												return;
											for (const e of s)
												if (!n.consumable.consume(e.item, t.name)) return;
											const a = n.mapper,
												c = n.writer;
											c.insert(a.toViewPosition(s.start), i),
												n.mapper.bindElementToMarker(i, e.markerName),
												s.isCollapsed ||
													(c.insert(a.toViewPosition(s.end), r),
													n.mapper.bindElementToMarker(r, e.markerName)),
												t.stop();
										}),
										{ priority: t.converterPriority || "normal" },
									),
										n.on(
											`removeMarker:${t.model}`,
											(t, e, n) => {
												const o = n.mapper.markerNameToElements(e.markerName);
												if (o) {
													for (const t of o)
														n.mapper.unbindElementFromMarkerName(
															t,
															e.markerName,
														),
															n.writer.clear(n.writer.createRangeOn(t), t);
													n.writer.clearClonedElementsGroup(e.markerName),
														t.stop();
												}
											},
											{ priority: t.converterPriority || "normal" },
										);
								};
							})(t),
						);
					}
					markerToHighlight(t) {
						return this.add(
							(function (t) {
								return (e) => {
									var n;
									e.on(
										`addMarker:${t.model}`,
										((n = t.view),
										(t, e, o) => {
											if (!e.item) return;
											if (
												!(
													e.item instanceof Qa ||
													e.item instanceof sc ||
													e.item.is("$textProxy")
												)
											)
												return;
											const i = bc(n, e, o);
											if (!i) return;
											if (!o.consumable.consume(e.item, t.name)) return;
											const r = o.writer,
												s = hc(r, i),
												a = r.document.selection;
											if (e.item instanceof Qa || e.item instanceof sc)
												r.wrap(a.getFirstRange(), s);
											else {
												const t = o.mapper.toViewRange(e.range),
													n = r.wrap(t, s);
												for (const t of n.getItems())
													if (t.is("attributeElement") && t.isSimilar(s)) {
														o.mapper.bindElementToMarker(t, e.markerName);
														break;
													}
											}
										}),
										{ priority: t.converterPriority || "normal" },
									),
										e.on(
											`addMarker:${t.model}`,
											(function (t) {
												return (e, n, o) => {
													if (!n.item) return;
													if (!(n.item instanceof Ra)) return;
													const i = bc(t, n, o);
													if (!i) return;
													if (!o.consumable.test(n.item, e.name)) return;
													const r = o.mapper.toViewElement(n.item);
													if (r && r.getCustomProperty("addHighlight")) {
														o.consumable.consume(n.item, e.name);
														for (const t of qa._createIn(n.item))
															o.consumable.consume(t.item, e.name);
														r.getCustomProperty("addHighlight")(r, i, o.writer),
															o.mapper.bindElementToMarker(r, n.markerName);
													}
												};
											})(t.view),
											{ priority: t.converterPriority || "normal" },
										),
										e.on(
											`removeMarker:${t.model}`,
											(function (t) {
												return (e, n, o) => {
													if (n.markerRange.isCollapsed) return;
													const i = bc(t, n, o);
													if (!i) return;
													const r = hc(o.writer, i),
														s = o.mapper.markerNameToElements(n.markerName);
													if (s) {
														for (const t of s)
															if (
																(o.mapper.unbindElementFromMarkerName(
																	t,
																	n.markerName,
																),
																t.is("attributeElement"))
															)
																o.writer.unwrap(o.writer.createRangeOn(t), r);
															else {
																t.getCustomProperty("removeHighlight")(
																	t,
																	i.id,
																	o.writer,
																);
															}
														o.writer.clearClonedElementsGroup(n.markerName),
															e.stop();
													}
												};
											})(t.view),
											{ priority: t.converterPriority || "normal" },
										);
								};
							})(t),
						);
					}
					markerToData(t) {
						return this.add(
							(function (t) {
								const e = (t = dc(t)).model;
								let n = t.view;
								n ||
									(n = (n) => ({
										group: e,
										name: n.substr(t.model.length + 1),
									}));
								return (o) => {
									var i;
									o.on(
										`addMarker:${e}`,
										((i = n),
										(t, e, n) => {
											const o = i(e.markerName, n);
											if (!o) return;
											const r = e.markerRange;
											n.consumable.consume(r, t.name) &&
												(pc(r, !1, n, e, o), pc(r, !0, n, e, o), t.stop());
										}),
										{ priority: t.converterPriority || "normal" },
									),
										o.on(
											`removeMarker:${e}`,
											(function (t) {
												return (e, n, o) => {
													const i = t(n.markerName, o);
													if (!i) return;
													const r = o.mapper.markerNameToElements(n.markerName);
													if (r) {
														for (const t of r)
															o.mapper.unbindElementFromMarkerName(
																t,
																n.markerName,
															),
																t.is("containerElement")
																	? (s(`data-${i.group}-start-before`, t),
																		s(`data-${i.group}-start-after`, t),
																		s(`data-${i.group}-end-before`, t),
																		s(`data-${i.group}-end-after`, t))
																	: o.writer.clear(
																			o.writer.createRangeOn(t),
																			t,
																		);
														o.writer.clearClonedElementsGroup(n.markerName),
															e.stop();
													}
													function s(t, e) {
														if (e.hasAttribute(t)) {
															const n = new Set(e.getAttribute(t).split(","));
															n.delete(i.name),
																0 == n.size
																	? o.writer.removeAttribute(t, e)
																	: o.writer.setAttribute(
																			t,
																			Array.from(n).join(","),
																			e,
																		);
														}
													}
												};
											})(n),
											{ priority: t.converterPriority || "normal" },
										);
								};
							})(t),
						);
					}
				}
				function hc(t, e) {
					const n = t.createAttributeElement("span", e.attributes);
					return (
						e.classes && n._addClass(e.classes),
						"number" == typeof e.priority && (n._priority = e.priority),
						(n._id = e.id),
						n
					);
				}
				function pc(t, e, n, o, i) {
					const r = e ? t.start : t.end,
						s = r.nodeAfter && r.nodeAfter.is("element") ? r.nodeAfter : null,
						a =
							r.nodeBefore && r.nodeBefore.is("element") ? r.nodeBefore : null;
					if (s || a) {
						let t, r;
						(e && s) || (!e && !a) ? ((t = s), (r = !0)) : ((t = a), (r = !1));
						const c = n.mapper.toViewElement(t);
						if (c)
							return void (function (t, e, n, o, i, r) {
								const s = `data-${r.group}-${e ? "start" : "end"}-${n ? "before" : "after"}`,
									a = t.hasAttribute(s) ? t.getAttribute(s).split(",") : [];
								a.unshift(r.name),
									o.writer.setAttribute(s, a.join(","), t),
									o.mapper.bindElementToMarker(t, i.markerName);
							})(c, e, r, n, o, i);
					}
					!(function (t, e, n, o, i) {
						const r = `${i.group}-${e ? "start" : "end"}`,
							s = i.name ? { name: i.name } : null,
							a = n.writer.createUIElement(r, s);
						n.writer.insert(t, a),
							n.mapper.bindElementToMarker(a, o.markerName);
					})(n.mapper.toViewPosition(r), e, n, o, i);
				}
				function gc(t) {
					return (
						"string" == typeof t && (t = { name: t }),
						t.attributes
							? Array.isArray(t.attributes) || (t.attributes = [t.attributes])
							: (t.attributes = []),
						(t.children = !!t.children),
						t
					);
				}
				function fc(t, e) {
					return "function" == typeof t
						? t
						: (n, o) =>
								(function (t, e, n) {
									"string" == typeof t && (t = { name: t });
									let o;
									const i = e.writer,
										r = Object.assign({}, t.attributes);
									if ("container" == n) o = i.createContainerElement(t.name, r);
									else if ("attribute" == n) {
										const e = { priority: t.priority || Ni.DEFAULT_PRIORITY };
										o = i.createAttributeElement(t.name, r, e);
									} else o = i.createUIElement(t.name, r);
									if (t.styles) {
										const e = Object.keys(t.styles);
										for (const n of e) i.setStyle(n, t.styles[n], o);
									}
									if (t.classes) {
										const e = t.classes;
										if ("string" == typeof e) i.addClass(e, o);
										else for (const t of e) i.addClass(t, o);
									}
									return o;
								})(t, o, e);
				}
				function mc(t) {
					return t.model.values
						? (e, n, o) => {
								const i = t.view[e];
								return i ? i(e, n, o) : null;
							}
						: t.view;
				}
				function kc(t) {
					return "string" == typeof t
						? (e) => ({ key: t, value: e })
						: "object" == typeof t
							? t.value
								? () => t
								: (e) => ({ key: t.key, value: e })
							: t;
				}
				function bc(t, e, n) {
					const o = "function" == typeof t ? t(e, n) : t;
					return o
						? (o.priority || (o.priority = 10),
							o.id || (o.id = e.markerName),
							o)
						: null;
				}
				function wc(t) {
					const e = (function (t) {
						return (e, n) => {
							if (!e.is("element", t.name)) return !1;
							if ("attribute" == n.type) {
								if (t.attributes.includes(n.attributeKey)) return !0;
							} else if (t.children) return !0;
							return !1;
						};
					})(t);
					return (t, n) => {
						const o = [];
						n.reconvertedElements || (n.reconvertedElements = new Set());
						for (const t of n.changes) {
							const i =
								"attribute" == t.type
									? t.range.start.nodeAfter
									: t.position.parent;
							if (i && e(i, t)) {
								if (!n.reconvertedElements.has(i)) {
									n.reconvertedElements.add(i);
									const t = Na._createBefore(i);
									o.push(
										{ type: "remove", name: i.name, position: t, length: 1 },
										{ type: "reinsert", name: i.name, position: t, length: 1 },
									);
								}
							} else o.push(t);
						}
						n.changes = o;
					};
				}
				function Ac(t) {
					return (e, n, o = {}) => {
						const i = ["insert"];
						for (const n of t.attributes)
							e.hasAttribute(n) && i.push(`attribute:${n}`);
						return (
							!!i.every((t) => n.test(e, t)) &&
							(o.preflight || i.forEach((t) => n.consume(e, t)), !0)
						);
					};
				}
				function _c(t, e, n, o) {
					for (const i of e) Cc(t.root, i, n, o) || n.convertItem(i);
				}
				function Cc(t, e, n, o) {
					const { writer: i, mapper: r } = n;
					if (!o.reconversion) return !1;
					const s = r.toViewElement(e);
					return (
						!(!s || s.root == t) &&
						!!n.canReuseView(s) &&
						(i.move(i.createRangeOn(s), r.toViewPosition(Na._createBefore(e))),
						!0)
					);
				}
				function vc(t, e, { preflight: n } = {}) {
					return n ? e.test(t, "insert") : e.consume(t, "insert");
				}
				function yc(t) {
					const { schema: e, document: n } = t.model;
					for (const o of n.getRootNames()) {
						const i = n.getRoot(o);
						if (
							i.isEmpty &&
							!e.checkChild(i, "$text") &&
							e.checkChild(i, "paragraph")
						)
							return t.insertElement("paragraph", i), !0;
					}
					return !1;
				}
				function xc(t, e, n) {
					const o = n.createContext(t);
					return (
						!!n.checkChild(o, "paragraph") &&
						!!n.checkChild(o.push("paragraph"), e)
					);
				}
				function Dc(t, e) {
					const n = e.createElement("paragraph");
					return e.insert(n, t), e.createPositionAt(n, 0);
				}
				class Ec extends lc {
					elementToElement(t) {
						return this.add(Sc(t));
					}
					elementToAttribute(t) {
						return this.add(
							(function (t) {
								Pc((t = dc(t)));
								const e = Fc(t, !1),
									n = Bc(t.view),
									o = n ? `element:${n}` : "element";
								return (n) => {
									n.on(o, e, { priority: t.converterPriority || "low" });
								};
							})(t),
						);
					}
					attributeToAttribute(t) {
						return this.add(
							(function (t) {
								t = dc(t);
								let e = null;
								("string" == typeof t.view || t.view.key) &&
									(e = (function (t) {
										"string" == typeof t.view && (t.view = { key: t.view });
										const e = t.view.key;
										let n;
										if ("class" == e || "style" == e) {
											n = {
												["class" == e ? "classes" : "styles"]: t.view.value,
											};
										} else {
											n = {
												attributes: {
													[e]:
														void 0 === t.view.value ? /[\s\S]*/ : t.view.value,
												},
											};
										}
										t.view.name && (n.name = t.view.name);
										return (t.view = n), e;
									})(t));
								Pc(t, e);
								const n = Fc(t, !0);
								return (e) => {
									e.on("element", n, {
										priority: t.converterPriority || "low",
									});
								};
							})(t),
						);
					}
					elementToMarker(t) {
						return this.add(
							(function (t) {
								const e = (function (t) {
									return (e, n) => {
										const o = "string" == typeof t ? t : t(e, n);
										return n.writer.createElement("$marker", {
											"data-name": o,
										});
									};
								})(t.model);
								return Sc({ ...t, model: e });
							})(t),
						);
					}
					dataToMarker(t) {
						return this.add(
							(function (t) {
								(t = dc(t)).model ||
									(t.model = (e) => (e ? t.view + ":" + e : t.view));
								const e = { view: t.view, model: t.model },
									n = Tc(Ic(e, "start")),
									o = Tc(Ic(e, "end"));
								return (i) => {
									i.on(`element:${t.view}-start`, n, {
										priority: t.converterPriority || "normal",
									}),
										i.on(`element:${t.view}-end`, o, {
											priority: t.converterPriority || "normal",
										});
									const r = a.get("low"),
										s = a.get("highest"),
										c = a.get(t.converterPriority) / s;
									i.on(
										"element",
										(function (t) {
											return (e, n, o) => {
												const i = `data-${t.view}`;
												function r(e, i) {
													for (const r of i) {
														const i = t.model(r, o),
															s = o.writer.createElement("$marker", {
																"data-name": i,
															});
														o.writer.insert(s, e),
															n.modelCursor.isEqual(e)
																? (n.modelCursor =
																		n.modelCursor.getShiftedBy(1))
																: (n.modelCursor =
																		n.modelCursor._getTransformedByInsertion(
																			e,
																			1,
																		)),
															(n.modelRange =
																n.modelRange._getTransformedByInsertion(
																	e,
																	1,
																)[0]);
													}
												}
												(o.consumable.test(n.viewItem, {
													attributes: i + "-end-after",
												}) ||
													o.consumable.test(n.viewItem, {
														attributes: i + "-start-after",
													}) ||
													o.consumable.test(n.viewItem, {
														attributes: i + "-end-before",
													}) ||
													o.consumable.test(n.viewItem, {
														attributes: i + "-start-before",
													})) &&
													(n.modelRange ||
														Object.assign(
															n,
															o.convertChildren(n.viewItem, n.modelCursor),
														),
													o.consumable.consume(n.viewItem, {
														attributes: i + "-end-after",
													}) &&
														r(
															n.modelRange.end,
															n.viewItem
																.getAttribute(i + "-end-after")
																.split(","),
														),
													o.consumable.consume(n.viewItem, {
														attributes: i + "-start-after",
													}) &&
														r(
															n.modelRange.end,
															n.viewItem
																.getAttribute(i + "-start-after")
																.split(","),
														),
													o.consumable.consume(n.viewItem, {
														attributes: i + "-end-before",
													}) &&
														r(
															n.modelRange.start,
															n.viewItem
																.getAttribute(i + "-end-before")
																.split(","),
														),
													o.consumable.consume(n.viewItem, {
														attributes: i + "-start-before",
													}) &&
														r(
															n.modelRange.start,
															n.viewItem
																.getAttribute(i + "-start-before")
																.split(","),
														));
											};
										})(e),
										{ priority: r + c },
									);
								};
							})(t),
						);
					}
				}
				function Sc(t) {
					const e = Tc((t = dc(t))),
						n = Bc(t.view),
						o = n ? `element:${n}` : "element";
					return (n) => {
						n.on(o, e, { priority: t.converterPriority || "normal" });
					};
				}
				function Bc(t) {
					return "string" == typeof t
						? t
						: "object" == typeof t && "string" == typeof t.name
							? t.name
							: null;
				}
				function Tc(t) {
					const e = new ko(t.view);
					return (n, o, i) => {
						const r = e.match(o.viewItem);
						if (!r) return;
						const s = r.match;
						if (((s.name = !0), !i.consumable.test(o.viewItem, s))) return;
						const a = (function (t, e, n) {
							return t instanceof Function
								? t(e, n)
								: n.writer.createElement(t);
						})(t.model, o.viewItem, i);
						a &&
							i.safeInsert(a, o.modelCursor) &&
							(i.consumable.consume(o.viewItem, s),
							i.convertChildren(o.viewItem, a),
							i.updateConversionResult(a, o));
					};
				}
				function Pc(t, e = null) {
					const n = null === e || ((t) => t.getAttribute(e)),
						o = "object" != typeof t.model ? t.model : t.model.key,
						i =
							"object" != typeof t.model || void 0 === t.model.value
								? n
								: t.model.value;
					t.model = { key: o, value: i };
				}
				function Fc(t, e) {
					const n = new ko(t.view);
					return (o, i, r) => {
						if (!i.modelRange && e) return;
						const s = n.match(i.viewItem);
						if (!s) return;
						if (
							(!(function (t, e) {
								const n = "function" == typeof t ? t(e) : t;
								if ("object" == typeof n && !Bc(n)) return !1;
								return !n.classes && !n.attributes && !n.styles;
							})(t.view, i.viewItem)
								? delete s.match.name
								: (s.match.name = !0),
							!r.consumable.test(i.viewItem, s.match))
						)
							return;
						const a = t.model.key,
							c =
								"function" == typeof t.model.value
									? t.model.value(i.viewItem, r)
									: t.model.value;
						if (null === c) return;
						i.modelRange ||
							Object.assign(i, r.convertChildren(i.viewItem, i.modelCursor));
						const l = (function (t, e, n, o) {
							let i = !1;
							for (const r of Array.from(t.getItems({ shallow: n })))
								o.schema.checkAttribute(r, e.key) &&
									((i = !0),
									r.hasAttribute(e.key) ||
										o.writer.setAttribute(e.key, e.value, r));
							return i;
						})(i.modelRange, { key: a, value: c }, e, r);
						l &&
							(r.consumable.test(i.viewItem, { name: !0 }) &&
								(s.match.name = !0),
							r.consumable.consume(i.viewItem, s.match));
					};
				}
				function Ic(t, e) {
					return {
						view: `${t.view}-${e}`,
						model: (e, n) => {
							const o = e.getAttribute("name"),
								i = t.model(o, n);
							return n.writer.createElement("$marker", { "data-name": i });
						},
					};
				}
				class zc extends B {
					constructor(t, e) {
						super(),
							(this.model = t),
							(this.view = new Ba(e)),
							(this.mapper = new Ua()),
							(this.downcastDispatcher = new Ga({
								mapper: this.mapper,
								schema: t.schema,
							}));
						const n = this.model.document,
							o = n.selection,
							i = this.model.markers;
						this.listenTo(
							this.model,
							"_beforeChanges",
							() => {
								this.view._disableRendering(!0);
							},
							{ priority: "highest" },
						),
							this.listenTo(
								this.model,
								"_afterChanges",
								() => {
									this.view._disableRendering(!1);
								},
								{ priority: "lowest" },
							),
							this.listenTo(
								n,
								"change",
								() => {
									this.view.change((t) => {
										this.downcastDispatcher.convertChanges(n.differ, i, t),
											this.downcastDispatcher.convertSelection(o, i, t);
									});
								},
								{ priority: "low" },
							),
							this.listenTo(
								this.view.document,
								"selectionChange",
								(function (t, e) {
									return (n, o) => {
										const i = o.newSelection,
											r = [];
										for (const t of i.getRanges()) r.push(e.toModelRange(t));
										const s = t.createSelection(r, { backward: i.isBackward });
										s.isEqual(t.document.selection) ||
											t.change((t) => {
												t.setSelection(s);
											});
									};
								})(this.model, this.mapper),
							),
							this.downcastDispatcher.on(
								"insert:$text",
								(t, e, n) => {
									if (!n.consumable.consume(e.item, t.name)) return;
									const o = n.writer,
										i = n.mapper.toViewPosition(e.range.start),
										r = o.createText(e.item.data);
									o.insert(i, r);
								},
								{ priority: "lowest" },
							),
							this.downcastDispatcher.on(
								"insert",
								(t, e, n) => {
									n.convertAttributes(e.item),
										e.reconversion ||
											!e.item.is("element") ||
											e.item.isEmpty ||
											n.convertChildren(e.item);
								},
								{ priority: "lowest" },
							),
							this.downcastDispatcher.on(
								"remove",
								(t, e, n) => {
									const o = n.mapper.toViewPosition(e.position),
										i = e.position.getShiftedBy(e.length),
										r = n.mapper.toViewPosition(i, { isPhantom: !0 }),
										s = n.writer.createRange(o, r),
										a = n.writer.remove(s.getTrimmed());
									for (const t of n.writer.createRangeIn(a).getItems())
										n.mapper.unbindViewElement(t, { defer: !0 });
								},
								{ priority: "low" },
							),
							this.downcastDispatcher.on(
								"selection",
								(t, e, n) => {
									const o = n.writer,
										i = o.document.selection;
									for (const t of i.getRanges())
										t.isCollapsed &&
											t.end.parent.isAttached() &&
											n.writer.mergeAttributes(t.start);
									o.setSelection(null);
								},
								{ priority: "high" },
							),
							this.downcastDispatcher.on(
								"selection",
								(t, e, n) => {
									const o = e.selection;
									if (o.isCollapsed) return;
									if (!n.consumable.consume(o, "selection")) return;
									const i = [];
									for (const t of o.getRanges())
										i.push(n.mapper.toViewRange(t));
									n.writer.setSelection(i, { backward: o.isBackward });
								},
								{ priority: "low" },
							),
							this.downcastDispatcher.on(
								"selection",
								(t, e, n) => {
									const o = e.selection;
									if (!o.isCollapsed) return;
									if (!n.consumable.consume(o, "selection")) return;
									const i = n.writer,
										r = o.getFirstPosition(),
										s = n.mapper.toViewPosition(r),
										a = i.breakAttributes(s);
									i.setSelection(a);
								},
								{ priority: "low" },
							),
							this.view.document.roots
								.bindTo(this.model.document.roots)
								.using((t) => {
									if ("$graveyard" == t.rootName) return null;
									const e = new Ci(this.view.document, t.name);
									return (
										(e.rootName = t.rootName), this.mapper.bindElements(t, e), e
									);
								});
					}
					destroy() {
						this.view.destroy(), this.stopListening();
					}
					reconvertMarker(t) {
						const e = "string" == typeof t ? t : t.name,
							n = this.model.markers.get(e);
						if (!n)
							throw new l.a(
								"editingcontroller-reconvertmarker-marker-not-exist",
								this,
								{ markerName: e },
							);
						this.model.change(() => {
							this.model.markers._refresh(n);
						});
					}
					reconvertItem(t) {
						this.model.change(() => {
							this.model.document.differ._refreshItem(t);
						});
					}
				}
				class Rc {
					constructor() {
						this._commands = new Map();
					}
					add(t, e) {
						this._commands.set(t, e);
					}
					get(t) {
						return this._commands.get(t);
					}
					execute(t, ...e) {
						const n = this.get(t);
						if (!n)
							throw new l.a("commandcollection-command-not-found", this, {
								commandName: t,
							});
						return n.execute(...e);
					}
					*names() {
						yield* this._commands.keys();
					}
					*commands() {
						yield* this._commands.values();
					}
					[Symbol.iterator]() {
						return this._commands[Symbol.iterator]();
					}
					destroy() {
						for (const t of this.commands()) t.destroy();
					}
				}
				class Oc {
					constructor() {
						this._consumables = new Map();
					}
					add(t, e) {
						let n;
						t.is("$text") || t.is("documentFragment")
							? this._consumables.set(t, !0)
							: (this._consumables.has(t)
									? (n = this._consumables.get(t))
									: ((n = new Nc(t)), this._consumables.set(t, n)),
								n.add(e));
					}
					test(t, e) {
						const n = this._consumables.get(t);
						return void 0 === n
							? null
							: t.is("$text") || t.is("documentFragment")
								? n
								: n.test(e);
					}
					consume(t, e) {
						return (
							!!this.test(t, e) &&
							(t.is("$text") || t.is("documentFragment")
								? this._consumables.set(t, !1)
								: this._consumables.get(t).consume(e),
							!0)
						);
					}
					revert(t, e) {
						const n = this._consumables.get(t);
						void 0 !== n &&
							(t.is("$text") || t.is("documentFragment")
								? this._consumables.set(t, !0)
								: n.revert(e));
					}
					static consumablesFromElement(t) {
						const e = {
								element: t,
								name: !0,
								attributes: [],
								classes: [],
								styles: [],
							},
							n = t.getAttributeKeys();
						for (const t of n)
							"style" != t && "class" != t && e.attributes.push(t);
						const o = t.getClassNames();
						for (const t of o) e.classes.push(t);
						const i = t.getStyleNames();
						for (const t of i) e.styles.push(t);
						return e;
					}
					static createFrom(t, e) {
						if ((e || (e = new Oc()), t.is("$text"))) return e.add(t), e;
						t.is("element") && e.add(t, Oc.consumablesFromElement(t)),
							t.is("documentFragment") && e.add(t);
						for (const n of t.getChildren()) e = Oc.createFrom(n, e);
						return e;
					}
				}
				const Mc = ["attributes", "classes", "styles"];
				class Nc {
					constructor(t) {
						(this.element = t),
							(this._canConsumeName = null),
							(this._consumables = {
								attributes: new Map(),
								styles: new Map(),
								classes: new Map(),
							});
					}
					add(t) {
						t.name && (this._canConsumeName = !0);
						for (const e of Mc) e in t && this._add(e, t[e]);
					}
					test(t) {
						if (t.name && !this._canConsumeName) return this._canConsumeName;
						for (const e of Mc)
							if (e in t) {
								const n = this._test(e, t[e]);
								if (!0 !== n) return n;
							}
						return !0;
					}
					consume(t) {
						t.name && (this._canConsumeName = !1);
						for (const e of Mc) e in t && this._consume(e, t[e]);
					}
					revert(t) {
						t.name && (this._canConsumeName = !0);
						for (const e of Mc) e in t && this._revert(e, t[e]);
					}
					_add(t, e) {
						const n = ke(e) ? e : [e],
							o = this._consumables[t];
						for (const e of n) {
							if ("attributes" === t && ("class" === e || "style" === e))
								throw new l.a("viewconsumable-invalid-attribute", this);
							if ((o.set(e, !0), "styles" === t))
								for (const t of this.element.document.stylesProcessor.getRelatedStyles(
									e,
								))
									o.set(t, !0);
						}
					}
					_test(t, e) {
						const n = ke(e) ? e : [e],
							o = this._consumables[t];
						for (const e of n)
							if ("attributes" !== t || ("class" !== e && "style" !== e)) {
								const t = o.get(e);
								if (void 0 === t) return null;
								if (!t) return !1;
							} else {
								const t = "class" == e ? "classes" : "styles",
									n = this._test(t, [...this._consumables[t].keys()]);
								if (!0 !== n) return n;
							}
						return !0;
					}
					_consume(t, e) {
						const n = ke(e) ? e : [e],
							o = this._consumables[t];
						for (const e of n)
							if ("attributes" !== t || ("class" !== e && "style" !== e)) {
								if ((o.set(e, !1), "styles" == t))
									for (const t of this.element.document.stylesProcessor.getRelatedStyles(
										e,
									))
										o.set(t, !1);
							} else {
								const t = "class" == e ? "classes" : "styles";
								this._consume(t, [...this._consumables[t].keys()]);
							}
					}
					_revert(t, e) {
						const n = ke(e) ? e : [e],
							o = this._consumables[t];
						for (const e of n)
							if ("attributes" !== t || ("class" !== e && "style" !== e)) {
								!1 === o.get(e) && o.set(e, !0);
							} else {
								const t = "class" == e ? "classes" : "styles";
								this._revert(t, [...this._consumables[t].keys()]);
							}
					}
				}
				class Vc extends B {
					constructor() {
						super(),
							(this._sourceDefinitions = {}),
							(this._attributeProperties = {}),
							this.decorate("checkChild"),
							this.decorate("checkAttribute"),
							this.on(
								"checkAttribute",
								(t, e) => {
									e[0] = new Lc(e[0]);
								},
								{ priority: "highest" },
							),
							this.on(
								"checkChild",
								(t, e) => {
									(e[0] = new Lc(e[0])), (e[1] = this.getDefinition(e[1]));
								},
								{ priority: "highest" },
							);
					}
					register(t, e) {
						if (this._sourceDefinitions[t])
							throw new l.a("schema-cannot-register-item-twice", this, {
								itemName: t,
							});
						(this._sourceDefinitions[t] = [Object.assign({}, e)]),
							this._clearCache();
					}
					extend(t, e) {
						if (!this._sourceDefinitions[t])
							throw new l.a("schema-cannot-extend-missing-item", this, {
								itemName: t,
							});
						this._sourceDefinitions[t].push(Object.assign({}, e)),
							this._clearCache();
					}
					getDefinitions() {
						return (
							this._compiledDefinitions || this._compile(),
							this._compiledDefinitions
						);
					}
					getDefinition(t) {
						let e;
						return (
							(e =
								"string" == typeof t
									? t
									: "is" in t && (t.is("$text") || t.is("$textProxy"))
										? "$text"
										: t.name),
							this.getDefinitions()[e]
						);
					}
					isRegistered(t) {
						return !!this.getDefinition(t);
					}
					isBlock(t) {
						const e = this.getDefinition(t);
						return !(!e || !e.isBlock);
					}
					isLimit(t) {
						const e = this.getDefinition(t);
						return !!e && !(!e.isLimit && !e.isObject);
					}
					isObject(t) {
						const e = this.getDefinition(t);
						return (
							!!e &&
							!!(e.isObject || (e.isLimit && e.isSelectable && e.isContent))
						);
					}
					isInline(t) {
						const e = this.getDefinition(t);
						return !(!e || !e.isInline);
					}
					isSelectable(t) {
						const e = this.getDefinition(t);
						return !!e && !(!e.isSelectable && !e.isObject);
					}
					isContent(t) {
						const e = this.getDefinition(t);
						return !!e && !(!e.isContent && !e.isObject);
					}
					checkChild(t, e) {
						return !!e && this._checkContextMatch(e, t);
					}
					checkAttribute(t, e) {
						const n = this.getDefinition(t.last);
						return !!n && n.allowAttributes.includes(e);
					}
					checkMerge(t, e) {
						if (t instanceof Na) {
							const e = t.nodeBefore,
								n = t.nodeAfter;
							if (!(e instanceof Ra))
								throw new l.a("schema-check-merge-no-element-before", this);
							if (!(n instanceof Ra))
								throw new l.a("schema-check-merge-no-element-after", this);
							return this.checkMerge(e, n);
						}
						for (const n of e.getChildren())
							if (!this.checkChild(t, n)) return !1;
						return !0;
					}
					addChildCheck(t) {
						this.on(
							"checkChild",
							(e, [n, o]) => {
								if (!o) return;
								const i = t(n, o);
								"boolean" == typeof i && (e.stop(), (e.return = i));
							},
							{ priority: "high" },
						);
					}
					addAttributeCheck(t) {
						this.on(
							"checkAttribute",
							(e, [n, o]) => {
								const i = t(n, o);
								"boolean" == typeof i && (e.stop(), (e.return = i));
							},
							{ priority: "high" },
						);
					}
					setAttributeProperties(t, e) {
						this._attributeProperties[t] = Object.assign(
							this.getAttributeProperties(t),
							e,
						);
					}
					getAttributeProperties(t) {
						return this._attributeProperties[t] || {};
					}
					getLimitElement(t) {
						let e;
						if (t instanceof Na) e = t.parent;
						else {
							e = (t instanceof qa ? [t] : Array.from(t.getRanges())).reduce(
								(t, e) => {
									const n = e.getCommonAncestor();
									return t ? t.getCommonAncestor(n, { includeSelf: !0 }) : n;
								},
								null,
							);
						}
						for (; !this.isLimit(e) && e.parent; ) e = e.parent;
						return e;
					}
					checkAttributeInSelection(t, e) {
						if (t.isCollapsed) {
							const n = [
								...t.getFirstPosition().getAncestors(),
								new Ia("", t.getAttributes()),
							];
							return this.checkAttribute(n, e);
						}
						{
							const n = t.getRanges();
							for (const t of n)
								for (const n of t)
									if (this.checkAttribute(n.item, e)) return !0;
						}
						return !1;
					}
					*getValidRanges(t, e) {
						t = (function* (t) {
							for (const e of t) yield* e.getMinimalFlatRanges();
						})(t);
						for (const n of t) yield* this._getValidRangesForRange(n, e);
					}
					getNearestSelectionRange(t, e = "both") {
						if (this.checkChild(t, "$text")) return new qa(t);
						let n, o;
						const i =
							t
								.getAncestors()
								.reverse()
								.find((t) => this.isLimit(t)) || t.root;
						("both" != e && "backward" != e) ||
							(n = new Oa({
								boundaries: qa._createIn(i),
								startPosition: t,
								direction: "backward",
							})),
							("both" != e && "forward" != e) ||
								(o = new Oa({ boundaries: qa._createIn(i), startPosition: t }));
						for (const t of (function* (t, e) {
							let n = !1;
							for (; !n; ) {
								if (((n = !0), t)) {
									const e = t.next();
									e.done || ((n = !1), yield { walker: t, value: e.value });
								}
								if (e) {
									const t = e.next();
									t.done || ((n = !1), yield { walker: e, value: t.value });
								}
							}
						})(n, o)) {
							const e = t.walker == n ? "elementEnd" : "elementStart",
								o = t.value;
							if (o.type == e && this.isObject(o.item))
								return qa._createOn(o.item);
							if (this.checkChild(o.nextPosition, "$text"))
								return new qa(o.nextPosition);
						}
						return null;
					}
					findAllowedParent(t, e) {
						let n = t.parent;
						for (; n; ) {
							if (this.checkChild(n, e)) return n;
							if (this.isLimit(n)) return null;
							n = n.parent;
						}
						return null;
					}
					setAllowedAttributes(t, e, n) {
						const o = n.model;
						for (const [i, r] of Object.entries(e))
							o.schema.checkAttribute(t, i) && n.setAttribute(i, r, t);
					}
					removeDisallowedAttributes(t, e) {
						for (const n of t)
							if (n.is("$text")) Zc(this, n, e);
							else {
								const t = qa._createIn(n).getPositions();
								for (const n of t) {
									Zc(this, n.nodeBefore || n.parent, e);
								}
							}
					}
					getAttributesWithProperty(t, e, n) {
						const o = {};
						for (const [i, r] of t.getAttributes()) {
							const t = this.getAttributeProperties(i);
							void 0 !== t[e] && ((void 0 !== n && n !== t[e]) || (o[i] = r));
						}
						return o;
					}
					createContext(t) {
						return new Lc(t);
					}
					_clearCache() {
						this._compiledDefinitions = null;
					}
					_compile() {
						const t = {},
							e = this._sourceDefinitions,
							n = Object.keys(e);
						for (const o of n) t[o] = jc(e[o], o);
						for (const e of n) Hc(t, e);
						for (const e of n) $c(t, e);
						for (const e of n) qc(t, e);
						for (const e of n) Uc(t, e), Wc(t, e);
						for (const e of n) Kc(t, e), Gc(t, e), Jc(t, e);
						this._compiledDefinitions = t;
					}
					_checkContextMatch(t, e, n = e.length - 1) {
						const o = e.getItem(n);
						if (t.allowIn.includes(o.name)) {
							if (0 == n) return !0;
							{
								const t = this.getDefinition(o);
								return this._checkContextMatch(t, e, n - 1);
							}
						}
						return !1;
					}
					*_getValidRangesForRange(t, e) {
						let n = t.start,
							o = t.start;
						for (const i of t.getItems({ shallow: !0 }))
							i.is("element") &&
								(yield* this._getValidRangesForRange(qa._createIn(i), e)),
								this.checkAttribute(i, e) ||
									(n.isEqual(o) || (yield new qa(n, o)),
									(n = Na._createAfter(i))),
								(o = Na._createAfter(i));
						n.isEqual(o) || (yield new qa(n, o));
					}
				}
				class Lc {
					constructor(t) {
						if (t instanceof Lc) return t;
						let e;
						(e =
							"string" == typeof t
								? [t]
								: Array.isArray(t)
									? t
									: t.getAncestors({ includeSelf: !0 })),
							(this._items = e.map(Xc));
					}
					get length() {
						return this._items.length;
					}
					get last() {
						return this._items[this._items.length - 1];
					}
					[Symbol.iterator]() {
						return this._items[Symbol.iterator]();
					}
					push(t) {
						const e = new Lc([t]);
						return (e._items = [...this._items, ...e._items]), e;
					}
					getItem(t) {
						return this._items[t];
					}
					*getNames() {
						yield* this._items.map((t) => t.name);
					}
					endsWith(t) {
						return Array.from(this.getNames()).join(" ").endsWith(t);
					}
					startsWith(t) {
						return Array.from(this.getNames()).join(" ").startsWith(t);
					}
				}
				function jc(t, e) {
					const n = {
						name: e,
						allowIn: [],
						allowContentOf: [],
						allowWhere: [],
						allowAttributes: [],
						allowAttributesOf: [],
						allowChildren: [],
						inheritTypesFrom: [],
					};
					return (
						(function (t, e) {
							for (const n of t) {
								const t = Object.keys(n).filter((t) => t.startsWith("is"));
								for (const o of t) e[o] = !!n[o];
							}
						})(t, n),
						Yc(t, n, "allowIn"),
						Yc(t, n, "allowContentOf"),
						Yc(t, n, "allowWhere"),
						Yc(t, n, "allowAttributes"),
						Yc(t, n, "allowAttributesOf"),
						Yc(t, n, "allowChildren"),
						Yc(t, n, "inheritTypesFrom"),
						(function (t, e) {
							for (const n of t) {
								const t = n.inheritAllFrom;
								t &&
									(e.allowContentOf.push(t),
									e.allowWhere.push(t),
									e.allowAttributesOf.push(t),
									e.inheritTypesFrom.push(t));
							}
						})(t, n),
						n
					);
				}
				function Hc(t, e) {
					const n = t[e];
					for (const o of n.allowChildren) {
						const n = t[o];
						n && n.allowIn.push(e);
					}
					n.allowChildren.length = 0;
				}
				function $c(t, e) {
					for (const n of t[e].allowContentOf)
						if (t[n]) {
							Qc(t, n).forEach((t) => {
								t.allowIn.push(e);
							});
						}
					delete t[e].allowContentOf;
				}
				function qc(t, e) {
					for (const n of t[e].allowWhere) {
						const o = t[n];
						if (o) {
							const n = o.allowIn;
							t[e].allowIn.push(...n);
						}
					}
					delete t[e].allowWhere;
				}
				function Uc(t, e) {
					for (const n of t[e].allowAttributesOf) {
						const o = t[n];
						if (o) {
							const n = o.allowAttributes;
							t[e].allowAttributes.push(...n);
						}
					}
					delete t[e].allowAttributesOf;
				}
				function Wc(t, e) {
					const n = t[e];
					for (const e of n.inheritTypesFrom) {
						const o = t[e];
						if (o) {
							const t = Object.keys(o).filter((t) => t.startsWith("is"));
							for (const e of t) e in n || (n[e] = o[e]);
						}
					}
					delete n.inheritTypesFrom;
				}
				function Kc(t, e) {
					const n = t[e],
						o = n.allowIn.filter((e) => t[e]);
					n.allowIn = Array.from(new Set(o));
				}
				function Gc(t, e) {
					const n = t[e];
					for (const o of n.allowIn) {
						t[o].allowChildren.push(e);
					}
				}
				function Jc(t, e) {
					const n = t[e];
					n.allowAttributes = Array.from(new Set(n.allowAttributes));
				}
				function Yc(t, e, n) {
					for (const o of t) {
						const t = o[n];
						"string" == typeof t
							? e[n].push(t)
							: Array.isArray(t) && e[n].push(...t);
					}
				}
				function Qc(t, e) {
					const n = t[e];
					return ((o = t), Object.keys(o).map((t) => o[t])).filter((t) =>
						t.allowIn.includes(n.name),
					);
					var o;
				}
				function Xc(t) {
					return "string" == typeof t || t.is("documentFragment")
						? {
								name: "string" == typeof t ? t : "$documentFragment",
								*getAttributeKeys() {},
								getAttribute() {},
							}
						: {
								name: t.is("element") ? t.name : "$text",
								*getAttributeKeys() {
									yield* t.getAttributeKeys();
								},
								getAttribute: (e) => t.getAttribute(e),
							};
				}
				function Zc(t, e, n) {
					for (const o of e.getAttributeKeys())
						t.checkAttribute(e, o) || n.removeAttribute(o, e);
				}
				class tl extends g {
					constructor(t) {
						super(),
							(this._splitParts = new Map()),
							(this._cursorParents = new Map()),
							(this._modelCursor = null),
							(this._emptyElementsToKeep = new Set()),
							(this.conversionApi = {
								...t,
								consumable: null,
								writer: null,
								store: null,
								convertItem: (t, e) => this._convertItem(t, e),
								convertChildren: (t, e) => this._convertChildren(t, e),
								safeInsert: (t, e) => this._safeInsert(t, e),
								updateConversionResult: (t, e) =>
									this._updateConversionResult(t, e),
								splitToAllowedParent: (t, e) =>
									this._splitToAllowedParent(t, e),
								getSplitParts: (t) => this._getSplitParts(t),
								keepEmptyElement: (t) => this._keepEmptyElement(t),
							});
					}
					convert(t, e, n = ["$root"]) {
						this.fire("viewCleanup", t),
							(this._modelCursor = (function (t, e) {
								let n;
								for (const o of new Lc(t)) {
									const t = {};
									for (const e of o.getAttributeKeys())
										t[e] = o.getAttribute(e);
									const i = e.createElement(o.name, t);
									n && e.insert(i, n), (n = Na._createAt(i, 0));
								}
								return n;
							})(n, e)),
							(this.conversionApi.writer = e),
							(this.conversionApi.consumable = Oc.createFrom(t)),
							(this.conversionApi.store = {});
						const { modelRange: o } = this._convertItem(t, this._modelCursor),
							i = e.createDocumentFragment();
						if (o) {
							this._removeEmptyElements();
							for (const t of Array.from(
								this._modelCursor.parent.getChildren(),
							))
								e.append(t, i);
							i.markers = (function (t, e) {
								const n = new Set(),
									o = new Map(),
									i = qa._createIn(t).getItems();
								for (const t of i) t.is("element", "$marker") && n.add(t);
								for (const t of n) {
									const n = t.getAttribute("data-name"),
										i = e.createPositionBefore(t);
									o.has(n)
										? (o.get(n).end = i.clone())
										: o.set(n, new qa(i.clone())),
										e.remove(t);
								}
								return o;
							})(i, e);
						}
						return (
							(this._modelCursor = null),
							this._splitParts.clear(),
							this._cursorParents.clear(),
							this._emptyElementsToKeep.clear(),
							(this.conversionApi.writer = null),
							(this.conversionApi.store = null),
							i
						);
					}
					_convertItem(t, e) {
						const n = { viewItem: t, modelCursor: e, modelRange: null };
						if (
							(t.is("element")
								? this.fire(`element:${t.name}`, n, this.conversionApi)
								: t.is("$text")
									? this.fire("text", n, this.conversionApi)
									: this.fire("documentFragment", n, this.conversionApi),
							n.modelRange && !(n.modelRange instanceof qa))
						)
							throw new l.a(
								"view-conversion-dispatcher-incorrect-result",
								this,
							);
						return { modelRange: n.modelRange, modelCursor: n.modelCursor };
					}
					_convertChildren(t, e) {
						let n = e.is("position") ? e : Na._createAt(e, 0);
						const o = new qa(n);
						for (const e of Array.from(t.getChildren())) {
							const t = this._convertItem(e, n);
							t.modelRange instanceof qa &&
								((o.end = t.modelRange.end), (n = t.modelCursor));
						}
						return { modelRange: o, modelCursor: n };
					}
					_safeInsert(t, e) {
						const n = this._splitToAllowedParent(t, e);
						return !!n && (this.conversionApi.writer.insert(t, n.position), !0);
					}
					_updateConversionResult(t, e) {
						const n = this._getSplitParts(t),
							o = this.conversionApi.writer;
						e.modelRange ||
							(e.modelRange = o.createRange(
								o.createPositionBefore(t),
								o.createPositionAfter(n[n.length - 1]),
							));
						const i = this._cursorParents.get(t);
						e.modelCursor = i ? o.createPositionAt(i, 0) : e.modelRange.end;
					}
					_splitToAllowedParent(t, e) {
						const { schema: n, writer: o } = this.conversionApi;
						let i = n.findAllowedParent(e, t);
						if (i) {
							if (i === e.parent) return { position: e };
							this._modelCursor.parent.getAncestors().includes(i) && (i = null);
						}
						if (!i) return xc(e, t, n) ? { position: Dc(e, o) } : null;
						const r = this.conversionApi.writer.split(e, i),
							s = [];
						for (const t of r.range.getWalker())
							if ("elementEnd" == t.type) s.push(t.item);
							else {
								const e = s.pop(),
									n = t.item;
								this._registerSplitPair(e, n);
							}
						const a = r.range.end.parent;
						return (
							this._cursorParents.set(t, a),
							{ position: r.position, cursorParent: a }
						);
					}
					_registerSplitPair(t, e) {
						this._splitParts.has(t) || this._splitParts.set(t, [t]);
						const n = this._splitParts.get(t);
						this._splitParts.set(e, n), n.push(e);
					}
					_getSplitParts(t) {
						let e;
						return (
							(e = this._splitParts.has(t) ? this._splitParts.get(t) : [t]), e
						);
					}
					_keepEmptyElement(t) {
						this._emptyElementsToKeep.add(t);
					}
					_removeEmptyElements() {
						let t = !1;
						for (const e of this._splitParts.keys())
							e.isEmpty &&
								!this._emptyElementsToKeep.has(e) &&
								(this.conversionApi.writer.remove(e),
								this._splitParts.delete(e),
								(t = !0));
						t && this._removeEmptyElements();
					}
				}
				class el {
					getHtml(t) {
						const e = document.implementation
							.createHTMLDocument("")
							.createElement("div");
						return e.appendChild(t), e.innerHTML;
					}
				}
				class nl {
					constructor(t) {
						(this.domParser = new DOMParser()),
							(this.domConverter = new Xr(t, { renderingMode: "data" })),
							(this.htmlWriter = new el());
					}
					toData(t) {
						const e = this.domConverter.viewToDom(t);
						return this.htmlWriter.getHtml(e);
					}
					toView(t) {
						const e = this._toDom(t);
						return this.domConverter.domToView(e);
					}
					registerRawContentMatcher(t) {
						this.domConverter.registerRawContentMatcher(t);
					}
					useFillerType(t) {
						this.domConverter.blockFillerMode =
							"marked" == t ? "markedNbsp" : "nbsp";
					}
					_toDom(t) {
						t.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i) ||
							(t = `<body>${t}</body>`);
						const e = this.domParser.parseFromString(t, "text/html"),
							n = e.createDocumentFragment(),
							o = e.body.childNodes;
						for (; o.length > 0; ) n.appendChild(o[0]);
						return n;
					}
				}
				class ol extends g {
					constructor(t, e) {
						super(),
							(this.model = t),
							(this.mapper = new Ua()),
							(this.downcastDispatcher = new Ga({
								mapper: this.mapper,
								schema: t.schema,
							})),
							this.downcastDispatcher.on(
								"insert:$text",
								(t, e, n) => {
									if (!n.consumable.consume(e.item, t.name)) return;
									const o = n.writer,
										i = n.mapper.toViewPosition(e.range.start),
										r = o.createText(e.item.data);
									o.insert(i, r);
								},
								{ priority: "lowest" },
							),
							this.downcastDispatcher.on(
								"insert",
								(t, e, n) => {
									n.convertAttributes(e.item),
										e.reconversion ||
											!e.item.is("element") ||
											e.item.isEmpty ||
											n.convertChildren(e.item);
								},
								{ priority: "lowest" },
							),
							(this.upcastDispatcher = new tl({ schema: t.schema })),
							(this.viewDocument = new Mi(e)),
							(this.stylesProcessor = e),
							(this.htmlProcessor = new nl(this.viewDocument)),
							(this.processor = this.htmlProcessor),
							(this._viewWriter = new ar(this.viewDocument)),
							this.upcastDispatcher.on(
								"text",
								(t, e, { schema: n, consumable: o, writer: i }) => {
									let r = e.modelCursor;
									if (!o.test(e.viewItem)) return;
									if (!n.checkChild(r, "$text")) {
										if (!xc(r, "$text", n)) return;
										if (0 == e.viewItem.data.trim().length) return;
										r = Dc(r, i);
									}
									o.consume(e.viewItem);
									const s = i.createText(e.viewItem.data);
									i.insert(s, r),
										(e.modelRange = i.createRange(
											r,
											r.getShiftedBy(s.offsetSize),
										)),
										(e.modelCursor = e.modelRange.end);
								},
								{ priority: "lowest" },
							),
							this.upcastDispatcher.on(
								"element",
								(t, e, n) => {
									if (
										!e.modelRange &&
										n.consumable.consume(e.viewItem, { name: !0 })
									) {
										const { modelRange: t, modelCursor: o } = n.convertChildren(
											e.viewItem,
											e.modelCursor,
										);
										(e.modelRange = t), (e.modelCursor = o);
									}
								},
								{ priority: "lowest" },
							),
							this.upcastDispatcher.on(
								"documentFragment",
								(t, e, n) => {
									if (
										!e.modelRange &&
										n.consumable.consume(e.viewItem, { name: !0 })
									) {
										const { modelRange: t, modelCursor: o } = n.convertChildren(
											e.viewItem,
											e.modelCursor,
										);
										(e.modelRange = t), (e.modelCursor = o);
									}
								},
								{ priority: "lowest" },
							),
							B.prototype.decorate.call(this, "init"),
							B.prototype.decorate.call(this, "set"),
							B.prototype.decorate.call(this, "get"),
							this.on(
								"init",
								() => {
									this.fire("ready");
								},
								{ priority: "lowest" },
							),
							this.on(
								"ready",
								() => {
									this.model.enqueueChange({ isUndoable: !1 }, yc);
								},
								{ priority: "lowest" },
							);
					}
					get(t = {}) {
						const { rootName: e = "main", trim: n = "empty" } = t;
						if (!this._checkIfRootsExists([e]))
							throw new l.a("datacontroller-get-non-existent-root", this);
						const o = this.model.document.getRoot(e);
						return "empty" !== n ||
							this.model.hasContent(o, { ignoreWhitespaces: !0 })
							? this.stringify(o, t)
							: "";
					}
					stringify(t, e = {}) {
						const n = this.toView(t, e);
						return this.processor.toData(n);
					}
					toView(t, e = {}) {
						const n = this.viewDocument,
							o = this._viewWriter;
						this.mapper.clearBindings();
						const i = qa._createIn(t),
							r = new sr(n);
						this.mapper.bindElements(t, r);
						const s = t.is("documentFragment")
							? t.markers
							: (function (t) {
									const e = [],
										n = t.root.document;
									if (!n) return new Map();
									const o = qa._createIn(t);
									for (const t of n.model.markers) {
										const n = t.getRange(),
											i = n.isCollapsed,
											r = n.start.isEqual(o.start) || n.end.isEqual(o.end);
										if (i && r) e.push([t.name, n]);
										else {
											const i = o.getIntersection(n);
											i && e.push([t.name, i]);
										}
									}
									return (
										e.sort(([t, e], [n, o]) => {
											if ("after" !== e.end.compareWith(o.start)) return 1;
											if ("before" !== e.start.compareWith(o.end)) return -1;
											switch (e.start.compareWith(o.start)) {
												case "before":
													return 1;
												case "after":
													return -1;
												default:
													switch (e.end.compareWith(o.end)) {
														case "before":
															return 1;
														case "after":
															return -1;
														default:
															return n.localeCompare(t);
													}
											}
										}),
										new Map(e)
									);
								})(t);
						return this.downcastDispatcher.convert(i, s, o, e), r;
					}
					init(t) {
						if (this.model.document.version)
							throw new l.a("datacontroller-init-document-not-empty", this);
						let e = {};
						if (
							("string" == typeof t ? (e.main = t) : (e = t),
							!this._checkIfRootsExists(Object.keys(e)))
						)
							throw new l.a("datacontroller-init-non-existent-root", this);
						return (
							this.model.enqueueChange({ isUndoable: !1 }, (t) => {
								for (const n of Object.keys(e)) {
									const o = this.model.document.getRoot(n);
									t.insert(this.parse(e[n], o), o, 0);
								}
							}),
							Promise.resolve()
						);
					}
					set(t, e = {}) {
						let n = {};
						if (
							("string" == typeof t ? (n.main = t) : (n = t),
							!this._checkIfRootsExists(Object.keys(n)))
						)
							throw new l.a("datacontroller-set-non-existent-root", this);
						this.model.enqueueChange(e.batchType || {}, (t) => {
							t.setSelection(null),
								t.removeSelectionAttribute(
									this.model.document.selection.getAttributeKeys(),
								);
							for (const e of Object.keys(n)) {
								const o = this.model.document.getRoot(e);
								t.remove(t.createRangeIn(o)),
									t.insert(this.parse(n[e], o), o, 0);
							}
						});
					}
					parse(t, e = "$root") {
						const n = this.processor.toView(t);
						return this.toModel(n, e);
					}
					toModel(t, e = "$root") {
						return this.model.change((n) =>
							this.upcastDispatcher.convert(t, n, e),
						);
					}
					addStyleProcessorRules(t) {
						t(this.stylesProcessor);
					}
					registerRawContentMatcher(t) {
						this.processor &&
							this.processor !== this.htmlProcessor &&
							this.processor.registerRawContentMatcher(t),
							this.htmlProcessor.registerRawContentMatcher(t);
					}
					destroy() {
						this.stopListening();
					}
					_checkIfRootsExists(t) {
						for (const e of t)
							if (!this.model.document.getRootNames().includes(e)) return !1;
						return !0;
					}
				}
				class il {
					constructor(t, e) {
						(this._helpers = new Map()),
							(this._downcast = to(t)),
							this._createConversionHelpers({
								name: "downcast",
								dispatchers: this._downcast,
								isDowncast: !0,
							}),
							(this._upcast = to(e)),
							this._createConversionHelpers({
								name: "upcast",
								dispatchers: this._upcast,
								isDowncast: !1,
							});
					}
					addAlias(t, e) {
						const n = this._downcast.includes(e);
						if (!this._upcast.includes(e) && !n)
							throw new l.a(
								"conversion-add-alias-dispatcher-not-registered",
								this,
							);
						this._createConversionHelpers({
							name: t,
							dispatchers: [e],
							isDowncast: n,
						});
					}
					for(t) {
						if (!this._helpers.has(t))
							throw new l.a("conversion-for-unknown-group", this);
						return this._helpers.get(t);
					}
					elementToElement(t) {
						this.for("downcast").elementToElement(t);
						for (const { model: e, view: n } of rl(t))
							this.for("upcast").elementToElement({
								model: e,
								view: n,
								converterPriority: t.converterPriority,
							});
					}
					attributeToElement(t) {
						this.for("downcast").attributeToElement(t);
						for (const { model: e, view: n } of rl(t))
							this.for("upcast").elementToAttribute({
								view: n,
								model: e,
								converterPriority: t.converterPriority,
							});
					}
					attributeToAttribute(t) {
						this.for("downcast").attributeToAttribute(t);
						for (const { model: e, view: n } of rl(t))
							this.for("upcast").attributeToAttribute({ view: n, model: e });
					}
					_createConversionHelpers({ name: t, dispatchers: e, isDowncast: n }) {
						if (this._helpers.has(t))
							throw new l.a("conversion-group-exists", this);
						const o = n ? new uc(e) : new Ec(e);
						this._helpers.set(t, o);
					}
				}
				function* rl(t) {
					if (t.model.values)
						for (const e of t.model.values) {
							const n = { key: t.model.key, value: e },
								o = t.view[e],
								i = t.upcastAlso ? t.upcastAlso[e] : void 0;
							yield* sl(n, o, i);
						}
					else yield* sl(t.model, t.view, t.upcastAlso);
				}
				function* sl(t, e, n) {
					if ((yield { model: t, view: e }, n))
						for (const e of to(n)) yield { model: t, view: e };
				}
				class al {
					constructor(t = {}) {
						"string" == typeof t &&
							((t = "transparent" === t ? { isUndoable: !1 } : {}),
							Object(l.b)("batch-constructor-deprecated-string-type"));
						const {
							isUndoable: e = !0,
							isLocal: n = !0,
							isUndo: o = !1,
							isTyping: i = !1,
						} = t;
						(this.operations = []),
							(this.isUndoable = e),
							(this.isLocal = n),
							(this.isUndo = o),
							(this.isTyping = i);
					}
					get type() {
						return Object(l.b)("batch-type-deprecated"), "default";
					}
					get baseVersion() {
						for (const t of this.operations)
							if (null !== t.baseVersion) return t.baseVersion;
						return null;
					}
					addOperation(t) {
						return (t.batch = this), this.operations.push(t), t;
					}
				}
				class cl {
					constructor(t) {
						(this._markerCollection = t),
							(this._changesInElement = new Map()),
							(this._elementSnapshots = new Map()),
							(this._changedMarkers = new Map()),
							(this._changeCount = 0),
							(this._cachedChanges = null),
							(this._cachedChangesWithGraveyard = null),
							(this._refreshedItems = new Set());
					}
					get isEmpty() {
						return (
							0 == this._changesInElement.size && 0 == this._changedMarkers.size
						);
					}
					bufferOperation(t) {
						const e = t;
						switch (e.type) {
							case "insert":
								if (this._isInInsertedElement(e.position.parent)) return;
								this._markInsert(
									e.position.parent,
									e.position.offset,
									e.nodes.maxOffset,
								);
								break;
							case "addAttribute":
							case "removeAttribute":
							case "changeAttribute":
								for (const t of e.range.getItems({ shallow: !0 }))
									this._isInInsertedElement(t.parent) || this._markAttribute(t);
								break;
							case "remove":
							case "move":
							case "reinsert": {
								if (
									e.sourcePosition.isEqual(e.targetPosition) ||
									e.sourcePosition
										.getShiftedBy(e.howMany)
										.isEqual(e.targetPosition)
								)
									return;
								const t = this._isInInsertedElement(e.sourcePosition.parent),
									n = this._isInInsertedElement(e.targetPosition.parent);
								t ||
									this._markRemove(
										e.sourcePosition.parent,
										e.sourcePosition.offset,
										e.howMany,
									),
									n ||
										this._markInsert(
											e.targetPosition.parent,
											e.getMovedRangeStart().offset,
											e.howMany,
										);
								break;
							}
							case "rename": {
								if (this._isInInsertedElement(e.position.parent)) return;
								this._markRemove(e.position.parent, e.position.offset, 1),
									this._markInsert(e.position.parent, e.position.offset, 1);
								const t = qa._createFromPositionAndShift(e.position, 1);
								for (const e of this._markerCollection.getMarkersIntersectingRange(
									t,
								)) {
									const t = e.getData();
									this.bufferMarkerChange(e.name, t, t);
								}
								break;
							}
							case "split": {
								const t = e.splitPosition.parent;
								this._isInInsertedElement(t) ||
									this._markRemove(t, e.splitPosition.offset, e.howMany),
									this._isInInsertedElement(e.insertionPosition.parent) ||
										this._markInsert(
											e.insertionPosition.parent,
											e.insertionPosition.offset,
											1,
										),
									e.graveyardPosition &&
										this._markRemove(
											e.graveyardPosition.parent,
											e.graveyardPosition.offset,
											1,
										);
								break;
							}
							case "merge": {
								const t = e.sourcePosition.parent;
								this._isInInsertedElement(t.parent) ||
									this._markRemove(t.parent, t.startOffset, 1);
								const n = e.graveyardPosition.parent;
								this._markInsert(n, e.graveyardPosition.offset, 1);
								const o = e.targetPosition.parent;
								this._isInInsertedElement(o) ||
									this._markInsert(o, e.targetPosition.offset, t.maxOffset);
								break;
							}
						}
						this._cachedChanges = null;
					}
					bufferMarkerChange(t, e, n) {
						const o = this._changedMarkers.get(t);
						o
							? ((o.newMarkerData = n),
								null == o.oldMarkerData.range &&
									null == n.range &&
									this._changedMarkers.delete(t))
							: this._changedMarkers.set(t, {
									newMarkerData: n,
									oldMarkerData: e,
								});
					}
					getMarkersToRemove() {
						const t = [];
						for (const [e, n] of this._changedMarkers)
							null != n.oldMarkerData.range &&
								t.push({ name: e, range: n.oldMarkerData.range });
						return t;
					}
					getMarkersToAdd() {
						const t = [];
						for (const [e, n] of this._changedMarkers)
							null != n.newMarkerData.range &&
								t.push({ name: e, range: n.newMarkerData.range });
						return t;
					}
					getChangedMarkers() {
						return Array.from(this._changedMarkers).map(([t, e]) => ({
							name: t,
							data: {
								oldRange: e.oldMarkerData.range,
								newRange: e.newMarkerData.range,
							},
						}));
					}
					hasDataChanges() {
						if (this._changesInElement.size > 0) return !0;
						for (const {
							newMarkerData: t,
							oldMarkerData: e,
						} of this._changedMarkers.values()) {
							if (t.affectsData !== e.affectsData) return !0;
							if (t.affectsData) {
								const n = t.range && !e.range,
									o = !t.range && e.range,
									i = t.range && e.range && !t.range.isEqual(e.range);
								if (n || o || i) return !0;
							}
						}
						return !1;
					}
					getChanges(t = {}) {
						if (this._cachedChanges)
							return t.includeChangesInGraveyard
								? this._cachedChangesWithGraveyard.slice()
								: this._cachedChanges.slice();
						let e = [];
						for (const t of this._changesInElement.keys()) {
							const n = this._changesInElement
									.get(t)
									.sort((t, e) =>
										t.offset === e.offset
											? t.type != e.type
												? "remove" == t.type
													? -1
													: 1
												: 0
											: t.offset < e.offset
												? -1
												: 1,
									),
								o = this._elementSnapshots.get(t),
								i = ll(t.getChildren()),
								r = dl(o.length, n);
							let s = 0,
								a = 0;
							for (const n of r)
								if ("i" === n) e.push(this._getInsertDiff(t, s, i[s])), s++;
								else if ("r" === n)
									e.push(this._getRemoveDiff(t, s, o[a])), a++;
								else if ("a" === n) {
									const n = i[s].attributes,
										r = o[a].attributes;
									let c;
									if ("$text" == i[s].name)
										c = new qa(Na._createAt(t, s), Na._createAt(t, s + 1));
									else {
										const e = t.offsetToIndex(s);
										c = new qa(
											Na._createAt(t, s),
											Na._createAt(t.getChild(e), 0),
										);
									}
									e.push(...this._getAttributesDiff(c, r, n)), s++, a++;
								} else s++, a++;
						}
						e.sort((t, e) =>
							t.position.root != e.position.root
								? t.position.root.rootName < e.position.root.rootName
									? -1
									: 1
								: t.position.isEqual(e.position)
									? t.changeCount - e.changeCount
									: t.position.isBefore(e.position)
										? -1
										: 1,
						);
						for (let t = 1, n = 0; t < e.length; t++) {
							const o = e[n],
								i = e[t],
								r =
									"remove" == o.type &&
									"remove" == i.type &&
									"$text" == o.name &&
									"$text" == i.name &&
									o.position.isEqual(i.position),
								s =
									"insert" == o.type &&
									"insert" == i.type &&
									"$text" == o.name &&
									"$text" == i.name &&
									o.position.parent == i.position.parent &&
									o.position.offset + o.length == i.position.offset,
								a =
									"attribute" == o.type &&
									"attribute" == i.type &&
									o.position.parent == i.position.parent &&
									o.range.isFlat &&
									i.range.isFlat &&
									o.position.offset + o.length == i.position.offset &&
									o.attributeKey == i.attributeKey &&
									o.attributeOldValue == i.attributeOldValue &&
									o.attributeNewValue == i.attributeNewValue;
							r || s || a
								? (o.length++,
									a && (o.range.end = o.range.end.getShiftedBy(1)),
									(e[t] = null))
								: (n = t);
						}
						e = e.filter((t) => t);
						for (const t of e)
							delete t.changeCount,
								"attribute" == t.type && (delete t.position, delete t.length);
						return (
							(this._changeCount = 0),
							(this._cachedChangesWithGraveyard = e),
							(this._cachedChanges = e.filter(ul)),
							t.includeChangesInGraveyard
								? this._cachedChangesWithGraveyard.slice()
								: this._cachedChanges.slice()
						);
					}
					getRefreshedItems() {
						return new Set(this._refreshedItems);
					}
					reset() {
						this._changesInElement.clear(),
							this._elementSnapshots.clear(),
							this._changedMarkers.clear(),
							(this._refreshedItems = new Set()),
							(this._cachedChanges = null);
					}
					_refreshItem(t) {
						if (this._isInInsertedElement(t.parent)) return;
						this._markRemove(t.parent, t.startOffset, t.offsetSize),
							this._markInsert(t.parent, t.startOffset, t.offsetSize),
							this._refreshedItems.add(t);
						const e = qa._createOn(t);
						for (const t of this._markerCollection.getMarkersIntersectingRange(
							e,
						)) {
							const e = t.getData();
							this.bufferMarkerChange(t.name, e, e);
						}
						this._cachedChanges = null;
					}
					_markInsert(t, e, n) {
						const o = {
							type: "insert",
							offset: e,
							howMany: n,
							count: this._changeCount++,
						};
						this._markChange(t, o);
					}
					_markRemove(t, e, n) {
						const o = {
							type: "remove",
							offset: e,
							howMany: n,
							count: this._changeCount++,
						};
						this._markChange(t, o), this._removeAllNestedChanges(t, e, n);
					}
					_markAttribute(t) {
						const e = {
							type: "attribute",
							offset: t.startOffset,
							howMany: t.offsetSize,
							count: this._changeCount++,
						};
						this._markChange(t.parent, e);
					}
					_markChange(t, e) {
						this._makeSnapshot(t);
						const n = this._getChangesForElement(t);
						this._handleChange(e, n), n.push(e);
						for (let t = 0; t < n.length; t++)
							n[t].howMany < 1 && (n.splice(t, 1), t--);
					}
					_getChangesForElement(t) {
						let e;
						return (
							this._changesInElement.has(t)
								? (e = this._changesInElement.get(t))
								: ((e = []), this._changesInElement.set(t, e)),
							e
						);
					}
					_makeSnapshot(t) {
						this._elementSnapshots.has(t) ||
							this._elementSnapshots.set(t, ll(t.getChildren()));
					}
					_handleChange(t, e) {
						t.nodesToHandle = t.howMany;
						for (const n of e) {
							const o = t.offset + t.howMany,
								i = n.offset + n.howMany;
							if (
								"insert" == t.type &&
								("insert" == n.type &&
									(t.offset <= n.offset
										? (n.offset += t.howMany)
										: t.offset < i &&
											((n.howMany += t.nodesToHandle), (t.nodesToHandle = 0))),
								"remove" == n.type &&
									t.offset < n.offset &&
									(n.offset += t.howMany),
								"attribute" == n.type)
							)
								if (t.offset <= n.offset) n.offset += t.howMany;
								else if (t.offset < i) {
									const i = n.howMany;
									(n.howMany = t.offset - n.offset),
										e.unshift({
											type: "attribute",
											offset: o,
											howMany: i - n.howMany,
											count: this._changeCount++,
										});
								}
							if ("remove" == t.type) {
								if ("insert" == n.type)
									if (o <= n.offset) n.offset -= t.howMany;
									else if (o <= i)
										if (t.offset < n.offset) {
											const e = o - n.offset;
											(n.offset = t.offset),
												(n.howMany -= e),
												(t.nodesToHandle -= e);
										} else
											(n.howMany -= t.nodesToHandle), (t.nodesToHandle = 0);
									else if (t.offset <= n.offset)
										(t.nodesToHandle -= n.howMany), (n.howMany = 0);
									else if (t.offset < i) {
										const e = i - t.offset;
										(n.howMany -= e), (t.nodesToHandle -= e);
									}
								if (
									("remove" == n.type &&
										(o <= n.offset
											? (n.offset -= t.howMany)
											: t.offset < n.offset &&
												((t.nodesToHandle += n.howMany), (n.howMany = 0))),
									"attribute" == n.type)
								)
									if (o <= n.offset) n.offset -= t.howMany;
									else if (t.offset < n.offset) {
										const e = o - n.offset;
										(n.offset = t.offset), (n.howMany -= e);
									} else if (t.offset < i)
										if (o <= i) {
											const o = n.howMany;
											n.howMany = t.offset - n.offset;
											const i = o - n.howMany - t.nodesToHandle;
											e.unshift({
												type: "attribute",
												offset: t.offset,
												howMany: i,
												count: this._changeCount++,
											});
										} else n.howMany -= i - t.offset;
							}
							if ("attribute" == t.type) {
								if ("insert" == n.type)
									if (t.offset < n.offset && o > n.offset) {
										if (o > i) {
											const t = {
												type: "attribute",
												offset: i,
												howMany: o - i,
												count: this._changeCount++,
											};
											this._handleChange(t, e), e.push(t);
										}
										(t.nodesToHandle = n.offset - t.offset),
											(t.howMany = t.nodesToHandle);
									} else
										t.offset >= n.offset &&
											t.offset < i &&
											(o > i
												? ((t.nodesToHandle = o - i), (t.offset = i))
												: (t.nodesToHandle = 0));
								if ("remove" == n.type && t.offset < n.offset && o > n.offset) {
									const i = {
										type: "attribute",
										offset: n.offset,
										howMany: o - n.offset,
										count: this._changeCount++,
									};
									this._handleChange(i, e),
										e.push(i),
										(t.nodesToHandle = n.offset - t.offset),
										(t.howMany = t.nodesToHandle);
								}
								"attribute" == n.type &&
									(t.offset >= n.offset && o <= i
										? ((t.nodesToHandle = 0), (t.howMany = 0), (t.offset = 0))
										: t.offset <= n.offset && o >= i && (n.howMany = 0));
							}
						}
						(t.howMany = t.nodesToHandle), delete t.nodesToHandle;
					}
					_getInsertDiff(t, e, n) {
						return {
							type: "insert",
							position: Na._createAt(t, e),
							name: n.name,
							attributes: new Map(n.attributes),
							length: 1,
							changeCount: this._changeCount++,
						};
					}
					_getRemoveDiff(t, e, n) {
						return {
							type: "remove",
							position: Na._createAt(t, e),
							name: n.name,
							attributes: new Map(n.attributes),
							length: 1,
							changeCount: this._changeCount++,
						};
					}
					_getAttributesDiff(t, e, n) {
						const o = [];
						n = new Map(n);
						for (const [i, r] of e) {
							const e = n.has(i) ? n.get(i) : null;
							e !== r &&
								o.push({
									type: "attribute",
									position: t.start,
									range: t.clone(),
									length: 1,
									attributeKey: i,
									attributeOldValue: r,
									attributeNewValue: e,
									changeCount: this._changeCount++,
								}),
								n.delete(i);
						}
						for (const [e, i] of n)
							o.push({
								type: "attribute",
								position: t.start,
								range: t.clone(),
								length: 1,
								attributeKey: e,
								attributeOldValue: null,
								attributeNewValue: i,
								changeCount: this._changeCount++,
							});
						return o;
					}
					_isInInsertedElement(t) {
						const e = t.parent;
						if (!e) return !1;
						const n = this._changesInElement.get(e),
							o = t.startOffset;
						if (n)
							for (const t of n)
								if (
									"insert" == t.type &&
									o >= t.offset &&
									o < t.offset + t.howMany
								)
									return !0;
						return this._isInInsertedElement(e);
					}
					_removeAllNestedChanges(t, e, n) {
						const o = new qa(Na._createAt(t, e), Na._createAt(t, e + n));
						for (const t of o.getItems({ shallow: !0 }))
							t.is("element") &&
								(this._elementSnapshots.delete(t),
								this._changesInElement.delete(t),
								this._removeAllNestedChanges(t, 0, t.maxOffset));
					}
				}
				function ll(t) {
					const e = [];
					for (const n of t)
						if (n.is("$text"))
							for (let t = 0; t < n.data.length; t++)
								e.push({
									name: "$text",
									attributes: new Map(n.getAttributes()),
								});
						else
							e.push({ name: n.name, attributes: new Map(n.getAttributes()) });
					return e;
				}
				function dl(t, e) {
					const n = [];
					let o = 0,
						i = 0;
					for (const t of e) {
						if (t.offset > o) {
							for (let e = 0; e < t.offset - o; e++) n.push("e");
							i += t.offset - o;
						}
						if ("insert" == t.type) {
							for (let e = 0; e < t.howMany; e++) n.push("i");
							o = t.offset + t.howMany;
						} else if ("remove" == t.type) {
							for (let e = 0; e < t.howMany; e++) n.push("r");
							(o = t.offset), (i += t.howMany);
						} else
							n.push(..."a".repeat(t.howMany).split("")),
								(o = t.offset + t.howMany),
								(i += t.howMany);
					}
					if (i < t) for (let e = 0; e < t - i - o; e++) n.push("e");
					return n;
				}
				function ul(t) {
					const e = "position" in t && "$graveyard" == t.position.root.rootName,
						n = "range" in t && "$graveyard" == t.range.root.rootName;
					return !e && !n;
				}
				class hl {
					constructor() {
						(this._operations = []),
							(this._undoPairs = new Map()),
							(this._undoneOperations = new Set()),
							(this._baseVersionToOperationIndex = new Map()),
							(this._version = 0),
							(this._gaps = new Map());
					}
					get version() {
						return this._version;
					}
					set version(t) {
						this._operations.length &&
							t > this._version + 1 &&
							this._gaps.set(this._version, t),
							(this._version = t);
					}
					get lastOperation() {
						return this._operations[this._operations.length - 1];
					}
					addOperation(t) {
						if (t.baseVersion !== this.version)
							throw new l.a(
								"model-document-history-addoperation-incorrect-version",
								this,
								{ operation: t, historyVersion: this.version },
							);
						this._operations.push(t),
							this._version++,
							this._baseVersionToOperationIndex.set(
								t.baseVersion,
								this._operations.length - 1,
							);
					}
					getOperations(t, e = this.version) {
						if (!this._operations.length) return [];
						const n = this._operations[0];
						void 0 === t && (t = n.baseVersion);
						let o = e - 1;
						for (const [e, n] of this._gaps)
							t > e && t < n && (t = n), o > e && o < n && (o = e - 1);
						if (o < n.baseVersion || t > this.lastOperation.baseVersion)
							return [];
						let i = this._baseVersionToOperationIndex.get(t);
						void 0 === i && (i = 0);
						let r = this._baseVersionToOperationIndex.get(o);
						return (
							void 0 === r && (r = this._operations.length - 1),
							this._operations.slice(i, r + 1)
						);
					}
					getOperation(t) {
						const e = this._baseVersionToOperationIndex.get(t);
						if (void 0 !== e) return this._operations[e];
					}
					setOperationAsUndone(t, e) {
						this._undoPairs.set(e, t), this._undoneOperations.add(t);
					}
					isUndoingOperation(t) {
						return this._undoPairs.has(t);
					}
					isUndoneOperation(t) {
						return this._undoneOperations.has(t);
					}
					getUndoneOperation(t) {
						return this._undoPairs.get(t);
					}
					reset() {
						(this._version = 0),
							(this._undoPairs = new Map()),
							(this._operations = []),
							(this._undoneOperations = new Set()),
							(this._gaps = new Map()),
							(this._baseVersionToOperationIndex = new Map());
					}
				}
				class pl extends Ra {
					constructor(t, e, n = "main") {
						super(e), (this._document = t), (this.rootName = n);
					}
					get document() {
						return this._document;
					}
					toJSON() {
						return this.rootName;
					}
				}
				function gl(t, e) {
					return (
						!!(n = t.charAt(e - 1)) &&
						1 == n.length &&
						/[\ud800-\udbff]/.test(n) &&
						(function (t) {
							return !!t && 1 == t.length && /[\udc00-\udfff]/.test(t);
						})(t.charAt(e))
					);
					var n;
				}
				function fl(t, e) {
					return (
						!!(n = t.charAt(e)) &&
						1 == n.length &&
						/[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(
							n,
						)
					);
					var n;
				}
				pl.prototype.is = function (t, e) {
					return e
						? e === this.name &&
								("rootElement" === t ||
									"model:rootElement" === t ||
									"element" === t ||
									"model:element" === t)
						: "rootElement" === t ||
								"model:rootElement" === t ||
								"element" === t ||
								"model:element" === t ||
								"node" === t ||
								"model:node" === t;
				};
				const ml = (function () {
					const t = /\p{Regional_Indicator}{2}/u.source,
						e =
							"(?:" +
							[
								/\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u,
								/\p{Emoji}\u{FE0F}?\u{20E3}/u,
								/\p{Emoji}\u{FE0F}/u,
								/(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u,
							]
								.map((t) => t.source)
								.join("|") +
							")";
					return new RegExp(`${t}|${e}(?:‍${e})*`, "ug");
				})();
				function kl(t, e) {
					const n = String(t).matchAll(ml);
					return Array.from(n).some(
						(t) => t.index < e && e < t.index + t[0].length,
					);
				}
				const bl = "$graveyard";
				class wl extends g {
					constructor(t) {
						super(),
							(this.model = t),
							(this.history = new hl()),
							(this.selection = new sc(this)),
							(this.roots = new Xn({ idProperty: "rootName" })),
							(this.differ = new cl(t.markers)),
							(this._postFixers = new Set()),
							(this._hasSelectionChangedFromTheLastChangeBlock = !1),
							this.createRoot("$root", bl),
							this.listenTo(
								t,
								"applyOperation",
								(t, e) => {
									const n = e[0];
									n.isDocumentOperation && this.differ.bufferOperation(n);
								},
								{ priority: "high" },
							),
							this.listenTo(
								t,
								"applyOperation",
								(t, e) => {
									const n = e[0];
									n.isDocumentOperation && this.history.addOperation(n);
								},
								{ priority: "low" },
							),
							this.listenTo(this.selection, "change", () => {
								this._hasSelectionChangedFromTheLastChangeBlock = !0;
							}),
							this.listenTo(t.markers, "update", (t, e, n, o, i) => {
								const r = { ...e.getData(), range: o };
								this.differ.bufferMarkerChange(e.name, i, r),
									null === n &&
										e.on("change", (t, n) => {
											const o = e.getData();
											this.differ.bufferMarkerChange(
												e.name,
												{ ...o, range: n },
												o,
											);
										});
							});
					}
					get version() {
						return this.history.version;
					}
					set version(t) {
						this.history.version = t;
					}
					get graveyard() {
						return this.getRoot(bl);
					}
					createRoot(t = "$root", e = "main") {
						if (this.roots.get(e))
							throw new l.a("model-document-createroot-name-exists", this, {
								name: e,
							});
						const n = new pl(this, t, e);
						return this.roots.add(n), n;
					}
					destroy() {
						this.selection.destroy(), this.stopListening();
					}
					getRoot(t = "main") {
						return this.roots.get(t);
					}
					getRootNames() {
						return Array.from(this.roots, (t) => t.rootName).filter(
							(t) => t != bl,
						);
					}
					registerPostFixer(t) {
						this._postFixers.add(t);
					}
					toJSON() {
						const t = ho(this);
						return (
							(t.selection = "[engine.model.DocumentSelection]"),
							(t.model = "[engine.model.Model]"),
							t
						);
					}
					_handleChangeBlock(t) {
						this._hasDocumentChangedFromTheLastChangeBlock() &&
							(this._callPostFixers(t),
							this.selection.refresh(),
							this.differ.hasDataChanges()
								? this.fire("change:data", t.batch)
								: this.fire("change", t.batch),
							this.selection.refresh(),
							this.differ.reset()),
							(this._hasSelectionChangedFromTheLastChangeBlock = !1);
					}
					_hasDocumentChangedFromTheLastChangeBlock() {
						return (
							!this.differ.isEmpty ||
							this._hasSelectionChangedFromTheLastChangeBlock
						);
					}
					_getDefaultRoot() {
						for (const t of this.roots) if (t !== this.graveyard) return t;
						return this.graveyard;
					}
					_getDefaultRange() {
						const t = this._getDefaultRoot(),
							e = this.model,
							n = e.schema,
							o = e.createPositionFromPath(t, [0]);
						return n.getNearestSelectionRange(o) || e.createRange(o);
					}
					_validateSelectionRange(t) {
						return Al(t.start) && Al(t.end);
					}
					_callPostFixers(t) {
						let e = !1;
						do {
							for (const n of this._postFixers)
								if ((this.selection.refresh(), (e = n(t)), e)) break;
						} while (e);
					}
				}
				function Al(t) {
					const e = t.textNode;
					if (e) {
						const n = e.data,
							o = t.offset - e.startOffset;
						return !gl(n, o) && !fl(n, o);
					}
					return !0;
				}
				class _l extends g {
					constructor() {
						super(), (this._markers = new Map());
					}
					[Symbol.iterator]() {
						return this._markers.values();
					}
					has(t) {
						const e = t instanceof Cl ? t.name : t;
						return this._markers.has(e);
					}
					get(t) {
						return this._markers.get(t) || null;
					}
					_set(t, e, n = !1, o = !1) {
						const i = t instanceof Cl ? t.name : t;
						if (i.includes(","))
							throw new l.a("markercollection-incorrect-marker-name", this);
						const r = this._markers.get(i);
						if (r) {
							const t = r.getData(),
								s = r.getRange();
							let a = !1;
							return (
								s.isEqual(e) || (r._attachLiveRange(nc.fromRange(e)), (a = !0)),
								n != r.managedUsingOperations &&
									((r._managedUsingOperations = n), (a = !0)),
								"boolean" == typeof o &&
									o != r.affectsData &&
									((r._affectsData = o), (a = !0)),
								a && this.fire(`update:${i}`, r, s, e, t),
								r
							);
						}
						const s = nc.fromRange(e),
							a = new Cl(i, s, n, o);
						return (
							this._markers.set(i, a),
							this.fire(`update:${i}`, a, null, e, {
								...a.getData(),
								range: null,
							}),
							a
						);
					}
					_remove(t) {
						const e = t instanceof Cl ? t.name : t,
							n = this._markers.get(e);
						return (
							!!n &&
							(this._markers.delete(e),
							this.fire(`update:${e}`, n, n.getRange(), null, n.getData()),
							this._destroyMarker(n),
							!0)
						);
					}
					_refresh(t) {
						const e = t instanceof Cl ? t.name : t,
							n = this._markers.get(e);
						if (!n)
							throw new l.a("markercollection-refresh-marker-not-exists", this);
						const o = n.getRange();
						this.fire(`update:${e}`, n, o, o, n.getData());
					}
					*getMarkersAtPosition(t) {
						for (const e of this) e.getRange().containsPosition(t) && (yield e);
					}
					*getMarkersIntersectingRange(t) {
						for (const e of this)
							null !== e.getRange().getIntersection(t) && (yield e);
					}
					destroy() {
						for (const t of this._markers.values()) this._destroyMarker(t);
						(this._markers = null), this.stopListening();
					}
					*getMarkersGroup(t) {
						for (const e of this._markers.values())
							e.name.startsWith(t + ":") && (yield e);
					}
					_destroyMarker(t) {
						t.stopListening(), t._detachLiveRange();
					}
				}
				class Cl extends p(Ta) {
					constructor(t, e, n, o) {
						super(),
							(this.name = t),
							(this._liveRange = this._attachLiveRange(e)),
							(this._managedUsingOperations = n),
							(this._affectsData = o);
					}
					get managedUsingOperations() {
						if (!this._liveRange) throw new l.a("marker-destroyed", this);
						return this._managedUsingOperations;
					}
					get affectsData() {
						if (!this._liveRange) throw new l.a("marker-destroyed", this);
						return this._affectsData;
					}
					getData() {
						return {
							range: this.getRange(),
							affectsData: this.affectsData,
							managedUsingOperations: this.managedUsingOperations,
						};
					}
					getStart() {
						if (!this._liveRange) throw new l.a("marker-destroyed", this);
						return this._liveRange.start.clone();
					}
					getEnd() {
						if (!this._liveRange) throw new l.a("marker-destroyed", this);
						return this._liveRange.end.clone();
					}
					getRange() {
						if (!this._liveRange) throw new l.a("marker-destroyed", this);
						return this._liveRange.toRange();
					}
					_attachLiveRange(t) {
						return (
							this._liveRange && this._detachLiveRange(),
							t.delegate("change:range").to(this),
							t.delegate("change:content").to(this),
							(this._liveRange = t),
							t
						);
					}
					_detachLiveRange() {
						this._liveRange.stopDelegating("change:range", this),
							this._liveRange.stopDelegating("change:content", this),
							this._liveRange.detach(),
							(this._liveRange = null);
					}
				}
				Cl.prototype.is = function (t) {
					return "marker" === t || "model:marker" === t;
				};
				class vl {
					constructor(t) {
						(this.baseVersion = t),
							(this.isDocumentOperation = null !== this.baseVersion),
							(this.batch = null);
					}
					_validate() {}
					toJSON() {
						const t = Object.assign({}, this);
						return (
							(t.__className = this.constructor.className),
							delete t.batch,
							delete t.isDocumentOperation,
							t
						);
					}
					static get className() {
						return "Operation";
					}
					static fromJSON(t, e) {
						return new this(t.baseVersion);
					}
				}
				function yl(t, e) {
					const n = El(e),
						o = n.reduce((t, e) => t + e.offsetSize, 0),
						i = t.parent;
					Bl(t);
					const r = t.index;
					return (
						i._insertChild(r, n),
						Sl(i, r + n.length),
						Sl(i, r),
						new qa(t, t.getShiftedBy(o))
					);
				}
				function xl(t) {
					if (!t.isFlat)
						throw new l.a("operation-utils-remove-range-not-flat", this);
					const e = t.start.parent;
					Bl(t.start), Bl(t.end);
					const n = e._removeChildren(
						t.start.index,
						t.end.index - t.start.index,
					);
					return Sl(e, t.start.index), n;
				}
				function Dl(t, e) {
					if (!t.isFlat)
						throw new l.a("operation-utils-move-range-not-flat", this);
					const n = xl(t);
					return yl(
						(e = e._getTransformedByDeletion(
							t.start,
							t.end.offset - t.start.offset,
						)),
						n,
					);
				}
				function El(t) {
					const e = [];
					!(function t(n) {
						if ("string" == typeof n) e.push(new Ia(n));
						else if (n instanceof za) e.push(new Ia(n.data, n.getAttributes()));
						else if (n instanceof Pa) e.push(n);
						else if (Qn(n)) for (const e of n) t(e);
					})(t);
					for (let t = 1; t < e.length; t++) {
						const n = e[t],
							o = e[t - 1];
						n instanceof Ia &&
							o instanceof Ia &&
							Tl(n, o) &&
							(e.splice(t - 1, 2, new Ia(o.data + n.data, o.getAttributes())),
							t--);
					}
					return e;
				}
				function Sl(t, e) {
					const n = t.getChild(e - 1),
						o = t.getChild(e);
					if (n && o && n.is("$text") && o.is("$text") && Tl(n, o)) {
						const i = new Ia(n.data + o.data, n.getAttributes());
						t._removeChildren(e - 1, 2), t._insertChild(e - 1, i);
					}
				}
				function Bl(t) {
					const e = t.textNode,
						n = t.parent;
					if (e) {
						const o = t.offset - e.startOffset,
							i = e.index;
						n._removeChildren(i, 1);
						const r = new Ia(e.data.substr(0, o), e.getAttributes()),
							s = new Ia(e.data.substr(o), e.getAttributes());
						n._insertChild(i, [r, s]);
					}
				}
				function Tl(t, e) {
					const n = t.getAttributes(),
						o = e.getAttributes();
					for (const t of n) {
						if (t[1] !== e.getAttribute(t[0])) return !1;
						o.next();
					}
					return o.next().done;
				}
				var Pl = function (t, e) {
					return Us(t, e);
				};
				class Fl extends vl {
					constructor(t, e, n, o, i) {
						super(i),
							(this.range = t.clone()),
							(this.key = e),
							(this.oldValue = void 0 === n ? null : n),
							(this.newValue = void 0 === o ? null : o);
					}
					get type() {
						return null === this.oldValue
							? "addAttribute"
							: null === this.newValue
								? "removeAttribute"
								: "changeAttribute";
					}
					clone() {
						return new Fl(
							this.range,
							this.key,
							this.oldValue,
							this.newValue,
							this.baseVersion,
						);
					}
					getReversed() {
						return new Fl(
							this.range,
							this.key,
							this.newValue,
							this.oldValue,
							this.baseVersion + 1,
						);
					}
					toJSON() {
						const t = super.toJSON();
						return (t.range = this.range.toJSON()), t;
					}
					_validate() {
						if (!this.range.isFlat)
							throw new l.a("attribute-operation-range-not-flat", this);
						for (const t of this.range.getItems({ shallow: !0 })) {
							if (
								null !== this.oldValue &&
								!Pl(t.getAttribute(this.key), this.oldValue)
							)
								throw new l.a("attribute-operation-wrong-old-value", this, {
									item: t,
									key: this.key,
									value: this.oldValue,
								});
							if (
								null === this.oldValue &&
								null !== this.newValue &&
								t.hasAttribute(this.key)
							)
								throw new l.a("attribute-operation-attribute-exists", this, {
									node: t,
									key: this.key,
								});
						}
					}
					_execute() {
						Pl(this.oldValue, this.newValue) ||
							(function (t, e, n) {
								Bl(t.start), Bl(t.end);
								for (const o of t.getItems({ shallow: !0 })) {
									const t = o.is("$textProxy") ? o.textNode : o;
									null !== n ? t._setAttribute(e, n) : t._removeAttribute(e),
										Sl(t.parent, t.index);
								}
								Sl(t.end.parent, t.end.index);
							})(this.range, this.key, this.newValue);
					}
					static get className() {
						return "AttributeOperation";
					}
					static fromJSON(t, e) {
						return new Fl(
							qa.fromJSON(t.range, e),
							t.key,
							t.oldValue,
							t.newValue,
							t.baseVersion,
						);
					}
				}
				class Il extends vl {
					constructor(t, e, n, o) {
						super(o),
							(this.sourcePosition = t.clone()),
							(this.sourcePosition.stickiness = "toNext"),
							(this.howMany = e),
							(this.targetPosition = n.clone()),
							(this.targetPosition.stickiness = "toNone");
					}
					get type() {
						return "$graveyard" == this.targetPosition.root.rootName
							? "remove"
							: "$graveyard" == this.sourcePosition.root.rootName
								? "reinsert"
								: "move";
					}
					clone() {
						return new Il(
							this.sourcePosition,
							this.howMany,
							this.targetPosition,
							this.baseVersion,
						);
					}
					getMovedRangeStart() {
						return this.targetPosition._getTransformedByDeletion(
							this.sourcePosition,
							this.howMany,
						);
					}
					getReversed() {
						const t = this.sourcePosition._getTransformedByInsertion(
							this.targetPosition,
							this.howMany,
						);
						return new Il(
							this.getMovedRangeStart(),
							this.howMany,
							t,
							this.baseVersion + 1,
						);
					}
					_validate() {
						const t = this.sourcePosition.parent,
							e = this.targetPosition.parent,
							n = this.sourcePosition.offset,
							o = this.targetPosition.offset;
						if (n + this.howMany > t.maxOffset)
							throw new l.a("move-operation-nodes-do-not-exist", this);
						if (t === e && n < o && o < n + this.howMany)
							throw new l.a("move-operation-range-into-itself", this);
						if (
							this.sourcePosition.root == this.targetPosition.root &&
							"prefix" ==
								uo(
									this.sourcePosition.getParentPath(),
									this.targetPosition.getParentPath(),
								)
						) {
							const t = this.sourcePosition.path.length - 1;
							if (
								this.targetPosition.path[t] >= n &&
								this.targetPosition.path[t] < n + this.howMany
							)
								throw new l.a("move-operation-node-into-itself", this);
						}
					}
					_execute() {
						Dl(
							qa._createFromPositionAndShift(this.sourcePosition, this.howMany),
							this.targetPosition,
						);
					}
					toJSON() {
						const t = super.toJSON();
						return (
							(t.sourcePosition = this.sourcePosition.toJSON()),
							(t.targetPosition = this.targetPosition.toJSON()),
							t
						);
					}
					static get className() {
						return "MoveOperation";
					}
					static fromJSON(t, e) {
						const n = Na.fromJSON(t.sourcePosition, e),
							o = Na.fromJSON(t.targetPosition, e);
						return new this(n, t.howMany, o, t.baseVersion);
					}
				}
				class zl extends vl {
					constructor(t, e, n) {
						super(n),
							(this.position = t.clone()),
							(this.position.stickiness = "toNone"),
							(this.nodes = new Fa(El(e))),
							(this.shouldReceiveAttributes = !1);
					}
					get type() {
						return "insert";
					}
					get howMany() {
						return this.nodes.maxOffset;
					}
					clone() {
						const t = new Fa([...this.nodes].map((t) => t._clone(!0))),
							e = new zl(this.position, t, this.baseVersion);
						return (
							(e.shouldReceiveAttributes = this.shouldReceiveAttributes), e
						);
					}
					getReversed() {
						const t = this.position.root.document.graveyard,
							e = new Na(t, [0]);
						return new Il(
							this.position,
							this.nodes.maxOffset,
							e,
							this.baseVersion + 1,
						);
					}
					_validate() {
						const t = this.position.parent;
						if (!t || t.maxOffset < this.position.offset)
							throw new l.a("insert-operation-position-invalid", this);
					}
					_execute() {
						const t = this.nodes;
						(this.nodes = new Fa([...t].map((t) => t._clone(!0)))),
							yl(this.position, t);
					}
					toJSON() {
						const t = super.toJSON();
						return (
							(t.position = this.position.toJSON()),
							(t.nodes = this.nodes.toJSON()),
							t
						);
					}
					static get className() {
						return "InsertOperation";
					}
					static fromJSON(t, e) {
						const n = [];
						for (const e of t.nodes)
							e.name ? n.push(Ra.fromJSON(e)) : n.push(Ia.fromJSON(e));
						const o = new zl(Na.fromJSON(t.position, e), n, t.baseVersion);
						return (o.shouldReceiveAttributes = t.shouldReceiveAttributes), o;
					}
				}
				class Rl extends vl {
					constructor(t, e, n, o, i, r) {
						super(r),
							(this.name = t),
							(this.oldRange = e ? e.clone() : null),
							(this.newRange = n ? n.clone() : null),
							(this.affectsData = i),
							(this._markers = o);
					}
					get type() {
						return "marker";
					}
					clone() {
						return new Rl(
							this.name,
							this.oldRange,
							this.newRange,
							this._markers,
							this.affectsData,
							this.baseVersion,
						);
					}
					getReversed() {
						return new Rl(
							this.name,
							this.newRange,
							this.oldRange,
							this._markers,
							this.affectsData,
							this.baseVersion + 1,
						);
					}
					_execute() {
						this.newRange
							? this._markers._set(
									this.name,
									this.newRange,
									!0,
									this.affectsData,
								)
							: this._markers._remove(this.name);
					}
					toJSON() {
						const t = super.toJSON();
						return (
							this.oldRange && (t.oldRange = this.oldRange.toJSON()),
							this.newRange && (t.newRange = this.newRange.toJSON()),
							delete t._markers,
							t
						);
					}
					static get className() {
						return "MarkerOperation";
					}
					static fromJSON(t, e) {
						return new Rl(
							t.name,
							t.oldRange ? qa.fromJSON(t.oldRange, e) : null,
							t.newRange ? qa.fromJSON(t.newRange, e) : null,
							e.model.markers,
							t.affectsData,
							t.baseVersion,
						);
					}
				}
				class Ol extends vl {
					get type() {
						return "noop";
					}
					clone() {
						return new Ol(this.baseVersion);
					}
					getReversed() {
						return new Ol(this.baseVersion + 1);
					}
					_execute() {}
					static get className() {
						return "NoOperation";
					}
				}
				class Ml extends vl {
					constructor(t, e, n, o) {
						super(o),
							(this.position = t),
							(this.position.stickiness = "toNext"),
							(this.oldName = e),
							(this.newName = n);
					}
					get type() {
						return "rename";
					}
					clone() {
						return new Ml(
							this.position.clone(),
							this.oldName,
							this.newName,
							this.baseVersion,
						);
					}
					getReversed() {
						return new Ml(
							this.position.clone(),
							this.newName,
							this.oldName,
							this.baseVersion + 1,
						);
					}
					_validate() {
						const t = this.position.nodeAfter;
						if (!(t instanceof Ra))
							throw new l.a("rename-operation-wrong-position", this);
						if (t.name !== this.oldName)
							throw new l.a("rename-operation-wrong-name", this);
					}
					_execute() {
						this.position.nodeAfter.name = this.newName;
					}
					toJSON() {
						const t = super.toJSON();
						return (t.position = this.position.toJSON()), t;
					}
					static get className() {
						return "RenameOperation";
					}
					static fromJSON(t, e) {
						return new Ml(
							Na.fromJSON(t.position, e),
							t.oldName,
							t.newName,
							t.baseVersion,
						);
					}
				}
				class Nl extends vl {
					constructor(t, e, n, o, i) {
						super(i),
							(this.root = t),
							(this.key = e),
							(this.oldValue = n),
							(this.newValue = o);
					}
					get type() {
						return null === this.oldValue
							? "addRootAttribute"
							: null === this.newValue
								? "removeRootAttribute"
								: "changeRootAttribute";
					}
					clone() {
						return new Nl(
							this.root,
							this.key,
							this.oldValue,
							this.newValue,
							this.baseVersion,
						);
					}
					getReversed() {
						return new Nl(
							this.root,
							this.key,
							this.newValue,
							this.oldValue,
							this.baseVersion + 1,
						);
					}
					_validate() {
						if (this.root != this.root.root || this.root.is("documentFragment"))
							throw new l.a("rootattribute-operation-not-a-root", this, {
								root: this.root,
								key: this.key,
							});
						if (
							null !== this.oldValue &&
							this.root.getAttribute(this.key) !== this.oldValue
						)
							throw new l.a("rootattribute-operation-wrong-old-value", this, {
								root: this.root,
								key: this.key,
							});
						if (
							null === this.oldValue &&
							null !== this.newValue &&
							this.root.hasAttribute(this.key)
						)
							throw new l.a("rootattribute-operation-attribute-exists", this, {
								root: this.root,
								key: this.key,
							});
					}
					_execute() {
						null !== this.newValue
							? this.root._setAttribute(this.key, this.newValue)
							: this.root._removeAttribute(this.key);
					}
					toJSON() {
						const t = super.toJSON();
						return (t.root = this.root.toJSON()), t;
					}
					static get className() {
						return "RootAttributeOperation";
					}
					static fromJSON(t, e) {
						if (!e.getRoot(t.root))
							throw new l.a("rootattribute-operation-fromjson-no-root", this, {
								rootName: t.root,
							});
						return new Nl(
							e.getRoot(t.root),
							t.key,
							t.oldValue,
							t.newValue,
							t.baseVersion,
						);
					}
				}
				class Vl extends vl {
					constructor(t, e, n, o, i) {
						super(i),
							(this.sourcePosition = t.clone()),
							(this.sourcePosition.stickiness = "toPrevious"),
							(this.howMany = e),
							(this.targetPosition = n.clone()),
							(this.targetPosition.stickiness = "toNext"),
							(this.graveyardPosition = o.clone());
					}
					get type() {
						return "merge";
					}
					get deletionPosition() {
						return new Na(
							this.sourcePosition.root,
							this.sourcePosition.path.slice(0, -1),
						);
					}
					get movedRange() {
						const t = this.sourcePosition.getShiftedBy(
							Number.POSITIVE_INFINITY,
						);
						return new qa(this.sourcePosition, t);
					}
					clone() {
						return new Vl(
							this.sourcePosition,
							this.howMany,
							this.targetPosition,
							this.graveyardPosition,
							this.baseVersion,
						);
					}
					getReversed() {
						const t = this.targetPosition._getTransformedByMergeOperation(this),
							e = this.sourcePosition.path.slice(0, -1),
							n = new Na(
								this.sourcePosition.root,
								e,
							)._getTransformedByMergeOperation(this);
						return new Ll(
							t,
							this.howMany,
							n,
							this.graveyardPosition,
							this.baseVersion + 1,
						);
					}
					_validate() {
						const t = this.sourcePosition.parent,
							e = this.targetPosition.parent;
						if (!t.parent)
							throw new l.a("merge-operation-source-position-invalid", this);
						if (!e.parent)
							throw new l.a("merge-operation-target-position-invalid", this);
						if (this.howMany != t.maxOffset)
							throw new l.a("merge-operation-how-many-invalid", this);
					}
					_execute() {
						const t = this.sourcePosition.parent;
						Dl(qa._createIn(t), this.targetPosition),
							Dl(qa._createOn(t), this.graveyardPosition);
					}
					toJSON() {
						const t = super.toJSON();
						return (
							(t.sourcePosition = t.sourcePosition.toJSON()),
							(t.targetPosition = t.targetPosition.toJSON()),
							(t.graveyardPosition = t.graveyardPosition.toJSON()),
							t
						);
					}
					static get className() {
						return "MergeOperation";
					}
					static fromJSON(t, e) {
						const n = Na.fromJSON(t.sourcePosition, e),
							o = Na.fromJSON(t.targetPosition, e),
							i = Na.fromJSON(t.graveyardPosition, e);
						return new this(n, t.howMany, o, i, t.baseVersion);
					}
				}
				class Ll extends vl {
					constructor(t, e, n, o, i) {
						super(i),
							(this.splitPosition = t.clone()),
							(this.splitPosition.stickiness = "toNext"),
							(this.howMany = e),
							(this.insertionPosition = n),
							(this.graveyardPosition = o ? o.clone() : null),
							this.graveyardPosition &&
								(this.graveyardPosition.stickiness = "toNext");
					}
					get type() {
						return "split";
					}
					get moveTargetPosition() {
						const t = this.insertionPosition.path.slice();
						return t.push(0), new Na(this.insertionPosition.root, t);
					}
					get movedRange() {
						const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
						return new qa(this.splitPosition, t);
					}
					clone() {
						return new Ll(
							this.splitPosition,
							this.howMany,
							this.insertionPosition,
							this.graveyardPosition,
							this.baseVersion,
						);
					}
					getReversed() {
						const t = this.splitPosition.root.document.graveyard,
							e = new Na(t, [0]);
						return new Vl(
							this.moveTargetPosition,
							this.howMany,
							this.splitPosition,
							e,
							this.baseVersion + 1,
						);
					}
					_validate() {
						const t = this.splitPosition.parent,
							e = this.splitPosition.offset;
						if (!t || t.maxOffset < e)
							throw new l.a("split-operation-position-invalid", this);
						if (!t.parent) throw new l.a("split-operation-split-in-root", this);
						if (this.howMany != t.maxOffset - this.splitPosition.offset)
							throw new l.a("split-operation-how-many-invalid", this);
						if (this.graveyardPosition && !this.graveyardPosition.nodeAfter)
							throw new l.a("split-operation-graveyard-position-invalid", this);
					}
					_execute() {
						const t = this.splitPosition.parent;
						if (this.graveyardPosition)
							Dl(
								qa._createFromPositionAndShift(this.graveyardPosition, 1),
								this.insertionPosition,
							);
						else {
							const e = t._clone();
							yl(this.insertionPosition, e);
						}
						Dl(
							new qa(
								Na._createAt(t, this.splitPosition.offset),
								Na._createAt(t, t.maxOffset),
							),
							this.moveTargetPosition,
						);
					}
					toJSON() {
						const t = super.toJSON();
						return (
							(t.splitPosition = this.splitPosition.toJSON()),
							(t.insertionPosition = this.insertionPosition.toJSON()),
							this.graveyardPosition &&
								(t.graveyardPosition = this.graveyardPosition.toJSON()),
							t
						);
					}
					static get className() {
						return "SplitOperation";
					}
					static getInsertionPosition(t) {
						const e = t.path.slice(0, -1);
						return e[e.length - 1]++, new Na(t.root, e, "toPrevious");
					}
					static fromJSON(t, e) {
						const n = Na.fromJSON(t.splitPosition, e),
							o = Na.fromJSON(t.insertionPosition, e),
							i = t.graveyardPosition
								? Na.fromJSON(t.graveyardPosition, e)
								: null;
						return new this(n, t.howMany, o, i, t.baseVersion);
					}
				}
				const jl = {};
				(jl[Fl.className] = Fl),
					(jl[zl.className] = zl),
					(jl[Rl.className] = Rl),
					(jl[Il.className] = Il),
					(jl[Ol.className] = Ol),
					(jl[vl.className] = vl),
					(jl[Ml.className] = Ml),
					(jl[Nl.className] = Nl),
					(jl[Ll.className] = Ll),
					(jl[Vl.className] = Vl);
				class Hl {
					static fromJSON(t, e) {
						return jl[t.__className].fromJSON(t, e);
					}
				}
				class $l extends vl {
					constructor(t, e) {
						super(null), (this.sourcePosition = t.clone()), (this.howMany = e);
					}
					get type() {
						return "detach";
					}
					toJSON() {
						const t = super.toJSON();
						return (t.sourcePosition = this.sourcePosition.toJSON()), t;
					}
					_validate() {
						if (this.sourcePosition.root.document)
							throw new l.a("detach-operation-on-document-node", this);
					}
					_execute() {
						xl(
							qa._createFromPositionAndShift(this.sourcePosition, this.howMany),
						);
					}
					static get className() {
						return "DetachOperation";
					}
				}
				class ql extends Ta {
					constructor(t) {
						super(),
							(this.markers = new Map()),
							(this._children = new Fa()),
							t && this._insertChild(0, t);
					}
					[Symbol.iterator]() {
						return this.getChildren();
					}
					get childCount() {
						return this._children.length;
					}
					get maxOffset() {
						return this._children.maxOffset;
					}
					get isEmpty() {
						return 0 === this.childCount;
					}
					get nextSibling() {
						return null;
					}
					get previousSibling() {
						return null;
					}
					get root() {
						return this;
					}
					get parent() {
						return null;
					}
					get document() {
						return null;
					}
					getAncestors() {
						return [];
					}
					getChild(t) {
						return this._children.getNode(t);
					}
					getChildren() {
						return this._children[Symbol.iterator]();
					}
					getChildIndex(t) {
						return this._children.getNodeIndex(t);
					}
					getChildStartOffset(t) {
						return this._children.getNodeStartOffset(t);
					}
					getPath() {
						return [];
					}
					getNodeByPath(t) {
						let e = this;
						for (const n of t) e = e.getChild(e.offsetToIndex(n));
						return e;
					}
					offsetToIndex(t) {
						return this._children.offsetToIndex(t);
					}
					toJSON() {
						const t = [];
						for (const e of this._children) t.push(e.toJSON());
						return t;
					}
					static fromJSON(t) {
						const e = [];
						for (const n of t)
							n.name ? e.push(Ra.fromJSON(n)) : e.push(Ia.fromJSON(n));
						return new ql(e);
					}
					_appendChild(t) {
						this._insertChild(this.childCount, t);
					}
					_insertChild(t, e) {
						const n = (function (t) {
							if ("string" == typeof t) return [new Ia(t)];
							Qn(t) || (t = [t]);
							return Array.from(t).map((t) =>
								"string" == typeof t
									? new Ia(t)
									: t instanceof za
										? new Ia(t.data, t.getAttributes())
										: t,
							);
						})(e);
						for (const t of n)
							null !== t.parent && t._remove(), (t.parent = this);
						this._children._insertNodes(t, n);
					}
					_removeChildren(t, e = 1) {
						const n = this._children._removeNodes(t, e);
						for (const t of n) t.parent = null;
						return n;
					}
				}
				ql.prototype.is = function (t) {
					return "documentFragment" === t || "model:documentFragment" === t;
				};
				class Ul {
					constructor(t, e) {
						(this.model = t), (this.batch = e);
					}
					createText(t, e) {
						return new Ia(t, e);
					}
					createElement(t, e) {
						return new Ra(t, e);
					}
					createDocumentFragment() {
						return new ql();
					}
					cloneElement(t, e = !0) {
						return t._clone(e);
					}
					insert(t, e, n = 0) {
						if (
							(this._assertWriterUsedCorrectly(),
							t instanceof Ia && "" == t.data)
						)
							return;
						const o = Na._createAt(e, n);
						if (t.parent) {
							if (Yl(t.root, o.root)) return void this.move(qa._createOn(t), o);
							if (t.root.document)
								throw new l.a("model-writer-insert-forbidden-move", this);
							this.remove(t);
						}
						const i = o.root.document ? o.root.document.version : null,
							r = new zl(o, t, i);
						if (
							(t instanceof Ia && (r.shouldReceiveAttributes = !0),
							this.batch.addOperation(r),
							this.model.applyOperation(r),
							t instanceof ql)
						)
							for (const [e, n] of t.markers) {
								const t = Na._createAt(n.root, 0),
									i = {
										range: new qa(
											n.start._getCombined(t, o),
											n.end._getCombined(t, o),
										),
										usingOperation: !0,
										affectsData: !0,
									};
								this.model.markers.has(e)
									? this.updateMarker(e, i)
									: this.addMarker(e, i);
							}
					}
					insertText(t, e, n, o) {
						e instanceof ql || e instanceof Ra || e instanceof Na
							? this.insert(this.createText(t), e, n)
							: this.insert(this.createText(t, e), n, o);
					}
					insertElement(t, e, n, o) {
						e instanceof ql || e instanceof Ra || e instanceof Na
							? this.insert(this.createElement(t), e, n)
							: this.insert(this.createElement(t, e), n, o);
					}
					append(t, e) {
						this.insert(t, e, "end");
					}
					appendText(t, e, n) {
						e instanceof ql || e instanceof Ra
							? this.insert(this.createText(t), e, "end")
							: this.insert(this.createText(t, e), n, "end");
					}
					appendElement(t, e, n) {
						e instanceof ql || e instanceof Ra
							? this.insert(this.createElement(t), e, "end")
							: this.insert(this.createElement(t, e), n, "end");
					}
					setAttribute(t, e, n) {
						if ((this._assertWriterUsedCorrectly(), n instanceof qa)) {
							const o = n.getMinimalFlatRanges();
							for (const n of o) Wl(this, t, e, n);
						} else Kl(this, t, e, n);
					}
					setAttributes(t, e) {
						for (const [n, o] of mo(t)) this.setAttribute(n, o, e);
					}
					removeAttribute(t, e) {
						if ((this._assertWriterUsedCorrectly(), e instanceof qa)) {
							const n = e.getMinimalFlatRanges();
							for (const e of n) Wl(this, t, null, e);
						} else Kl(this, t, null, e);
					}
					clearAttributes(t) {
						this._assertWriterUsedCorrectly();
						const e = (t) => {
							for (const e of t.getAttributeKeys()) this.removeAttribute(e, t);
						};
						if (t instanceof qa) for (const n of t.getItems()) e(n);
						else e(t);
					}
					move(t, e, n) {
						if ((this._assertWriterUsedCorrectly(), !(t instanceof qa)))
							throw new l.a("writer-move-invalid-range", this);
						if (!t.isFlat) throw new l.a("writer-move-range-not-flat", this);
						const o = Na._createAt(e, n);
						if (o.isEqual(t.start)) return;
						if (
							(this._addOperationForAffectedMarkers("move", t),
							!Yl(t.root, o.root))
						)
							throw new l.a("writer-move-different-document", this);
						const i = t.root.document ? t.root.document.version : null,
							r = new Il(t.start, t.end.offset - t.start.offset, o, i);
						this.batch.addOperation(r), this.model.applyOperation(r);
					}
					remove(t) {
						this._assertWriterUsedCorrectly();
						const e = (t instanceof qa ? t : qa._createOn(t))
							.getMinimalFlatRanges()
							.reverse();
						for (const t of e)
							this._addOperationForAffectedMarkers("move", t),
								Jl(
									t.start,
									t.end.offset - t.start.offset,
									this.batch,
									this.model,
								);
					}
					merge(t) {
						this._assertWriterUsedCorrectly();
						const e = t.nodeBefore,
							n = t.nodeAfter;
						if (
							(this._addOperationForAffectedMarkers("merge", t),
							!(e instanceof Ra))
						)
							throw new l.a("writer-merge-no-element-before", this);
						if (!(n instanceof Ra))
							throw new l.a("writer-merge-no-element-after", this);
						t.root.document ? this._merge(t) : this._mergeDetached(t);
					}
					createPositionFromPath(t, e, n) {
						return this.model.createPositionFromPath(t, e, n);
					}
					createPositionAt(t, e) {
						return this.model.createPositionAt(t, e);
					}
					createPositionAfter(t) {
						return this.model.createPositionAfter(t);
					}
					createPositionBefore(t) {
						return this.model.createPositionBefore(t);
					}
					createRange(t, e) {
						return this.model.createRange(t, e);
					}
					createRangeIn(t) {
						return this.model.createRangeIn(t);
					}
					createRangeOn(t) {
						return this.model.createRangeOn(t);
					}
					createSelection(...t) {
						return this.model.createSelection(...t);
					}
					_mergeDetached(t) {
						const e = t.nodeBefore,
							n = t.nodeAfter;
						this.move(qa._createIn(n), Na._createAt(e, "end")), this.remove(n);
					}
					_merge(t) {
						const e = Na._createAt(t.nodeBefore, "end"),
							n = Na._createAt(t.nodeAfter, 0),
							o = t.root.document.graveyard,
							i = new Na(o, [0]),
							r = t.root.document.version,
							s = new Vl(n, t.nodeAfter.maxOffset, e, i, r);
						this.batch.addOperation(s), this.model.applyOperation(s);
					}
					rename(t, e) {
						if ((this._assertWriterUsedCorrectly(), !(t instanceof Ra)))
							throw new l.a("writer-rename-not-element-instance", this);
						const n = t.root.document ? t.root.document.version : null,
							o = new Ml(Na._createBefore(t), t.name, e, n);
						this.batch.addOperation(o), this.model.applyOperation(o);
					}
					split(t, e) {
						this._assertWriterUsedCorrectly();
						let n,
							o,
							i = t.parent;
						if (!i.parent)
							throw new l.a("writer-split-element-no-parent", this);
						if (
							(e || (e = i.parent),
							!t.parent.getAncestors({ includeSelf: !0 }).includes(e))
						)
							throw new l.a("writer-split-invalid-limit-element", this);
						do {
							const e = i.root.document ? i.root.document.version : null,
								r = i.maxOffset - t.offset,
								s = Ll.getInsertionPosition(t),
								a = new Ll(t, r, s, null, e);
							this.batch.addOperation(a),
								this.model.applyOperation(a),
								n || o || ((n = i), (o = t.parent.nextSibling)),
								(i = (t = this.createPositionAfter(t.parent)).parent);
						} while (i !== e);
						return {
							position: t,
							range: new qa(Na._createAt(n, "end"), Na._createAt(o, 0)),
						};
					}
					wrap(t, e) {
						if ((this._assertWriterUsedCorrectly(), !t.isFlat))
							throw new l.a("writer-wrap-range-not-flat", this);
						const n = e instanceof Ra ? e : new Ra(e);
						if (n.childCount > 0)
							throw new l.a("writer-wrap-element-not-empty", this);
						if (null !== n.parent)
							throw new l.a("writer-wrap-element-attached", this);
						this.insert(n, t.start);
						const o = new qa(t.start.getShiftedBy(1), t.end.getShiftedBy(1));
						this.move(o, Na._createAt(n, 0));
					}
					unwrap(t) {
						if ((this._assertWriterUsedCorrectly(), null === t.parent))
							throw new l.a("writer-unwrap-element-no-parent", this);
						this.move(qa._createIn(t), this.createPositionAfter(t)),
							this.remove(t);
					}
					addMarker(t, e) {
						if (
							(this._assertWriterUsedCorrectly(),
							!e || "boolean" != typeof e.usingOperation)
						)
							throw new l.a("writer-addmarker-no-usingoperation", this);
						const n = e.usingOperation,
							o = e.range,
							i = void 0 !== e.affectsData && e.affectsData;
						if (this.model.markers.has(t))
							throw new l.a("writer-addmarker-marker-exists", this);
						if (!o) throw new l.a("writer-addmarker-no-range", this);
						return n
							? (Gl(this, t, null, o, i), this.model.markers.get(t))
							: this.model.markers._set(t, o, n, i);
					}
					updateMarker(t, e) {
						this._assertWriterUsedCorrectly();
						const n = "string" == typeof t ? t : t.name,
							o = this.model.markers.get(n);
						if (!o)
							throw new l.a("writer-updatemarker-marker-not-exists", this);
						if (!e)
							return (
								Object(l.b)(
									"writer-updatemarker-reconvert-using-editingcontroller",
									{ markerName: n },
								),
								void this.model.markers._refresh(o)
							);
						const i = "boolean" == typeof e.usingOperation,
							r = "boolean" == typeof e.affectsData,
							s = r ? e.affectsData : o.affectsData;
						if (!i && !e.range && !r)
							throw new l.a("writer-updatemarker-wrong-options", this);
						const a = o.getRange(),
							c = e.range ? e.range : a;
						i && e.usingOperation !== o.managedUsingOperations
							? e.usingOperation
								? Gl(this, n, null, c, s)
								: (Gl(this, n, a, null, s),
									this.model.markers._set(n, c, void 0, s))
							: o.managedUsingOperations
								? Gl(this, n, a, c, s)
								: this.model.markers._set(n, c, void 0, s);
					}
					removeMarker(t) {
						this._assertWriterUsedCorrectly();
						const e = "string" == typeof t ? t : t.name;
						if (!this.model.markers.has(e))
							throw new l.a("writer-removemarker-no-marker", this);
						const n = this.model.markers.get(e);
						if (!n.managedUsingOperations)
							return void this.model.markers._remove(e);
						Gl(this, e, n.getRange(), null, n.affectsData);
					}
					setSelection(...t) {
						this._assertWriterUsedCorrectly(),
							this.model.document.selection._setTo(...t);
					}
					setSelectionFocus(t, e) {
						this._assertWriterUsedCorrectly(),
							this.model.document.selection._setFocus(t, e);
					}
					setSelectionAttribute(t, e) {
						if ((this._assertWriterUsedCorrectly(), "string" == typeof t))
							this._setSelectionAttribute(t, e);
						else for (const [e, n] of mo(t)) this._setSelectionAttribute(e, n);
					}
					removeSelectionAttribute(t) {
						if ((this._assertWriterUsedCorrectly(), "string" == typeof t))
							this._removeSelectionAttribute(t);
						else for (const e of t) this._removeSelectionAttribute(e);
					}
					overrideSelectionGravity() {
						return this.model.document.selection._overrideGravity();
					}
					restoreSelectionGravity(t) {
						this.model.document.selection._restoreGravity(t);
					}
					_setSelectionAttribute(t, e) {
						const n = this.model.document.selection;
						if (n.isCollapsed && n.anchor.parent.isEmpty) {
							const o = sc._getStoreAttributeKey(t);
							this.setAttribute(o, e, n.anchor.parent);
						}
						n._setAttribute(t, e);
					}
					_removeSelectionAttribute(t) {
						const e = this.model.document.selection;
						if (e.isCollapsed && e.anchor.parent.isEmpty) {
							const n = sc._getStoreAttributeKey(t);
							this.removeAttribute(n, e.anchor.parent);
						}
						e._removeAttribute(t);
					}
					_assertWriterUsedCorrectly() {
						if (this.model._currentWriter !== this)
							throw new l.a("writer-incorrect-use", this);
					}
					_addOperationForAffectedMarkers(t, e) {
						for (const n of this.model.markers) {
							if (!n.managedUsingOperations) continue;
							const o = n.getRange();
							let i = !1;
							if ("move" === t) {
								const t = e;
								i =
									t.containsPosition(o.start) ||
									t.start.isEqual(o.start) ||
									t.containsPosition(o.end) ||
									t.end.isEqual(o.end);
							} else {
								const t = e,
									n = t.nodeBefore,
									r = t.nodeAfter,
									s = o.start.parent == n && o.start.isAtEnd,
									a = o.end.parent == r && 0 == o.end.offset,
									c = o.end.nodeAfter == r,
									l = o.start.nodeAfter == r;
								i = s || a || c || l;
							}
							i && this.updateMarker(n.name, { range: o });
						}
					}
				}
				function Wl(t, e, n, o) {
					const i = t.model,
						r = i.document;
					let s,
						a,
						c,
						l = o.start;
					for (const t of o.getWalker({ shallow: !0 }))
						(c = t.item.getAttribute(e)),
							s && a != c && (a != n && d(), (l = s)),
							(s = t.nextPosition),
							(a = c);
					function d() {
						const o = new qa(l, s),
							c = o.root.document ? r.version : null,
							d = new Fl(o, e, a, n, c);
						t.batch.addOperation(d), i.applyOperation(d);
					}
					s instanceof Na && s != l && a != n && d();
				}
				function Kl(t, e, n, o) {
					const i = t.model,
						r = i.document,
						s = o.getAttribute(e);
					let a, c;
					if (s != n) {
						if (o.root === o) {
							const t = o.document ? r.version : null;
							c = new Nl(o, e, s, n, t);
						} else {
							a = new qa(Na._createBefore(o), t.createPositionAfter(o));
							const i = a.root.document ? r.version : null;
							c = new Fl(a, e, s, n, i);
						}
						t.batch.addOperation(c), i.applyOperation(c);
					}
				}
				function Gl(t, e, n, o, i) {
					const r = t.model,
						s = r.document,
						a = new Rl(e, n, o, r.markers, !!i, s.version);
					t.batch.addOperation(a), r.applyOperation(a);
				}
				function Jl(t, e, n, o) {
					let i;
					if (t.root.document) {
						const n = o.document,
							r = new Na(n.graveyard, [0]);
						i = new Il(t, e, r, n.version);
					} else i = new $l(t, e);
					n.addOperation(i), o.applyOperation(i);
				}
				function Yl(t, e) {
					return t === e || (t instanceof pl && e instanceof pl);
				}
				function Ql(t) {
					t.document.registerPostFixer((e) =>
						(function (t, e) {
							const n = e.document.selection,
								o = e.schema,
								i = [];
							let r = !1;
							for (const t of n.getRanges()) {
								const e = Xl(t, o);
								e && !e.isEqual(t) ? (i.push(e), (r = !0)) : i.push(t);
							}
							r &&
								t.setSelection(
									(function (t) {
										const e = [...t],
											n = new Set();
										let o = 1;
										for (; o < e.length; ) {
											const t = e[o],
												i = e.slice(0, o);
											for (const [r, s] of i.entries())
												if (!n.has(r))
													if (t.isEqual(s)) n.add(r);
													else if (t.isIntersecting(s)) {
														n.add(r), n.add(o);
														const i = t.getJoined(s);
														e.push(i);
													}
											o++;
										}
										return e.filter((t, e) => !n.has(e));
									})(i),
									{ backward: n.isBackward },
								);
							return !1;
						})(e, t),
					);
				}
				function Xl(t, e) {
					return t.isCollapsed
						? (function (t, e) {
								const n = t.start,
									o = e.getNearestSelectionRange(n);
								if (!o) {
									const t = n
										.getAncestors()
										.reverse()
										.find((t) => e.isObject(t));
									return t ? qa._createOn(t) : null;
								}
								if (!o.isCollapsed) return o;
								const i = o.start;
								if (n.isEqual(i)) return null;
								return new qa(i);
							})(t, e)
						: (function (t, e) {
								const { start: n, end: o } = t,
									i = e.checkChild(n, "$text"),
									r = e.checkChild(o, "$text"),
									s = e.getLimitElement(n),
									a = e.getLimitElement(o);
								if (s === a) {
									if (i && r) return null;
									if (
										(function (t, e, n) {
											const o =
													(t.nodeAfter && !n.isLimit(t.nodeAfter)) ||
													n.checkChild(t, "$text"),
												i =
													(e.nodeBefore && !n.isLimit(e.nodeBefore)) ||
													n.checkChild(e, "$text");
											return o || i;
										})(n, o, e)
									) {
										const t =
												n.nodeAfter && e.isSelectable(n.nodeAfter)
													? null
													: e.getNearestSelectionRange(n, "forward"),
											i =
												o.nodeBefore && e.isSelectable(o.nodeBefore)
													? null
													: e.getNearestSelectionRange(o, "backward"),
											r = t ? t.start : n,
											s = i ? i.end : o;
										return new qa(r, s);
									}
								}
								const c = s && !s.is("rootElement"),
									l = a && !a.is("rootElement");
								if (c || l) {
									const t =
											n.nodeAfter &&
											o.nodeBefore &&
											n.nodeAfter.parent === o.nodeBefore.parent,
										i = c && (!t || !td(n.nodeAfter, e)),
										r = l && (!t || !td(o.nodeBefore, e));
									let d = n,
										u = o;
									return (
										i && (d = Na._createBefore(Zl(s, e))),
										r && (u = Na._createAfter(Zl(a, e))),
										new qa(d, u)
									);
								}
								return null;
							})(t, e);
				}
				function Zl(t, e) {
					let n = t,
						o = n;
					for (; e.isLimit(o) && o.parent; ) (n = o), (o = o.parent);
					return n;
				}
				function td(t, e) {
					return t && e.isSelectable(t);
				}
				class ed extends p(Na) {
					constructor(t, e, n = "toNone") {
						if ((super(t, e, n), !this.root.is("rootElement")))
							throw new l.a("model-liveposition-root-not-rootelement", t);
						nd.call(this);
					}
					detach() {
						this.stopListening();
					}
					toPosition() {
						return new Na(this.root, this.path.slice(), this.stickiness);
					}
					static fromPosition(t, e) {
						return new this(t.root, t.path.slice(), e || t.stickiness);
					}
				}
				function nd() {
					this.listenTo(
						this.root.document.model,
						"applyOperation",
						(t, e) => {
							const n = e[0];
							n.isDocumentOperation && od.call(this, n);
						},
						{ priority: "low" },
					);
				}
				function od(t) {
					const e = this.getTransformedByOperation(t);
					if (!this.isEqual(e)) {
						const t = this.toPosition();
						(this.path = e.path), (this.root = e.root), this.fire("change", t);
					}
				}
				function id(t, e, n = {}) {
					if (e.isCollapsed) return;
					const o = e.getFirstRange();
					if ("$graveyard" == o.root.rootName) return;
					const i = t.schema;
					t.change((t) => {
						if (
							!n.doNotResetEntireContent &&
							(function (t, e) {
								const n = t.getLimitElement(e);
								if (!e.containsEntireContent(n)) return !1;
								const o = e.getFirstRange();
								if (o.start.parent == o.end.parent) return !1;
								return t.checkChild(n, "paragraph");
							})(i, e)
						)
							return void (function (t, e) {
								const n = t.model.schema.getLimitElement(e);
								t.remove(t.createRangeIn(n)),
									cd(t, t.createPositionAt(n, 0), e);
							})(t, e);
						const r = {};
						if (!n.doNotAutoparagraph) {
							const t = e.getSelectedElement();
							t &&
								Object.assign(
									r,
									i.getAttributesWithProperty(t, "copyOnReplace", !0),
								);
						}
						const [s, a] = (function (t) {
							const e = t.root.document.model,
								n = t.start;
							let o = t.end;
							if (e.hasContent(t, { ignoreMarkers: !0 })) {
								const n = (function (t) {
									const e = t.parent,
										n = e.root.document.model.schema,
										o = e.getAncestors({ parentFirst: !0, includeSelf: !0 });
									for (const t of o) {
										if (n.isLimit(t)) return null;
										if (n.isBlock(t)) return t;
									}
								})(o);
								if (n && o.isTouching(e.createPositionAt(n, 0))) {
									const n = e.createSelection(t);
									e.modifySelection(n, { direction: "backward" });
									const i = n.getLastPosition(),
										r = e.createRange(i, o);
									e.hasContent(r, { ignoreMarkers: !0 }) || (o = i);
								}
							}
							return [
								ed.fromPosition(n, "toPrevious"),
								ed.fromPosition(o, "toNext"),
							];
						})(o);
						s.isTouching(a) || t.remove(t.createRange(s, a)),
							n.leaveUnmerged ||
								(!(function (t, e, n) {
									const o = t.model;
									if (!ad(t.model.schema, e, n)) return;
									const [i, r] = (function (t, e) {
										const n = t.getAncestors(),
											o = e.getAncestors();
										let i = 0;
										for (; n[i] && n[i] == o[i]; ) i++;
										return [n[i], o[i]];
									})(e, n);
									if (!i || !r) return;
									!o.hasContent(i, { ignoreMarkers: !0 }) &&
									o.hasContent(r, { ignoreMarkers: !0 })
										? sd(t, e, n, i.parent)
										: rd(t, e, n, i.parent);
								})(t, s, a),
								i.removeDisallowedAttributes(s.parent.getChildren(), t)),
							ld(t, e, s),
							!n.doNotAutoparagraph &&
								(function (t, e) {
									const n = t.checkChild(e, "$text"),
										o = t.checkChild(e, "paragraph");
									return !n && o;
								})(i, s) &&
								cd(t, s, e, r),
							s.detach(),
							a.detach();
					});
				}
				function rd(t, e, n, o) {
					const i = e.parent,
						r = n.parent;
					if (i != o && r != o) {
						for (
							e = t.createPositionAfter(i),
								(n = t.createPositionBefore(r)).isEqual(e) || t.insert(r, e),
								t.merge(e);
							n.parent.isEmpty;
						) {
							const e = n.parent;
							(n = t.createPositionBefore(e)), t.remove(e);
						}
						ad(t.model.schema, e, n) && rd(t, e, n, o);
					}
				}
				function sd(t, e, n, o) {
					const i = e.parent,
						r = n.parent;
					if (i != o && r != o) {
						for (
							e = t.createPositionAfter(i),
								(n = t.createPositionBefore(r)).isEqual(e) || t.insert(i, n);
							e.parent.isEmpty;
						) {
							const n = e.parent;
							(e = t.createPositionBefore(n)), t.remove(n);
						}
						(n = t.createPositionBefore(r)),
							(function (t, e) {
								const n = e.nodeBefore,
									o = e.nodeAfter;
								n.name != o.name && t.rename(n, o.name);
								t.clearAttributes(n),
									t.setAttributes(Object.fromEntries(o.getAttributes()), n),
									t.merge(e);
							})(t, n),
							ad(t.model.schema, e, n) && sd(t, e, n, o);
					}
				}
				function ad(t, e, n) {
					const o = e.parent,
						i = n.parent;
					return (
						o != i &&
						!t.isLimit(o) && !t.isLimit(i) &&
						(function (t, e, n) {
							const o = new qa(t, e);
							for (const t of o.getWalker()) if (n.isLimit(t.item)) return !1;
							return !0;
						})(e, n, t)
					);
				}
				function cd(t, e, n, o = {}) {
					const i = t.createElement("paragraph");
					t.model.schema.setAllowedAttributes(i, o, t),
						t.insert(i, e),
						ld(t, n, t.createPositionAt(i, 0));
				}
				function ld(t, e, n) {
					e instanceof sc ? t.setSelection(n) : e.setTo(n);
				}
				function dd(t, e) {
					const n = [];
					Array.from(t.getItems({ direction: "backward" }))
						.map((t) => e.createRangeOn(t))
						.filter(
							(e) =>
								(e.start.isAfter(t.start) || e.start.isEqual(t.start)) &&
								(e.end.isBefore(t.end) || e.end.isEqual(t.end)),
						)
						.forEach((t) => {
							n.push(t.start.parent), e.remove(t);
						}),
						n.forEach((t) => {
							let n = t;
							for (; n.parent && n.isEmpty; ) {
								const t = e.createRangeOn(n);
								(n = n.parent), e.remove(t);
							}
						});
				}
				ed.prototype.is = function (t) {
					return (
						"livePosition" === t ||
						"model:livePosition" === t ||
						"position" == t ||
						"model:position" === t
					);
				};
				var ud = n(16),
					hd = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(ud.a, hd), ud.a.locals;
				const pd = new WeakMap();
				function gd(t) {
					const {
							view: e,
							element: n,
							text: o,
							isDirectHost: i = !0,
							keepOnFocus: r = !1,
						} = t,
						s = e.document;
					pd.has(s) ||
						(pd.set(s, new Map()),
						s.registerPostFixer((t) => md(s, t)),
						s.on(
							"change:isComposing",
							() => {
								e.change((t) => md(s, t));
							},
							{ priority: "high" },
						)),
						pd
							.get(s)
							.set(n, {
								text: o,
								isDirectHost: i,
								keepOnFocus: r,
								hostElement: i ? n : null,
							}),
						e.change((t) => md(s, t));
				}
				function fd(t, e) {
					return (
						!!e.hasClass("ck-placeholder") &&
						(t.removeClass("ck-placeholder", e), !0)
					);
				}
				function md(t, e) {
					const n = pd.get(t),
						o = [];
					let i = !1;
					for (const [t, r] of n)
						r.isDirectHost && (o.push(t), kd(e, t, r) && (i = !0));
					for (const [t, r] of n) {
						if (r.isDirectHost) continue;
						const n = bd(t);
						n &&
							(o.includes(n) || ((r.hostElement = n), kd(e, t, r) && (i = !0)));
					}
					return i;
				}
				function kd(t, e, n) {
					const { text: o, isDirectHost: i, hostElement: r } = n;
					let s = !1;
					r.getAttribute("data-placeholder") !== o &&
						(t.setAttribute("data-placeholder", o, r), (s = !0));
					return (
						(i || 1 == e.childCount) &&
						(function (t, e) {
							if (!t.isAttached()) return !1;
							const n = Array.from(t.getChildren()).some(
								(t) => !t.is("uiElement"),
							);
							if (n) return !1;
							const o = t.document,
								i = o.selection.anchor;
							return !(
								(o.isComposing && i && i.parent === t) ||
								(!e && o.isFocused && (!i || i.parent === t))
							);
						})(r, n.keepOnFocus)
							? (function (t, e) {
									return (
										!e.hasClass("ck-placeholder") &&
										(t.addClass("ck-placeholder", e), !0)
									);
								})(t, r) && (s = !0)
							: fd(t, r) && (s = !0),
						s
					);
				}
				function bd(t) {
					if (t.childCount) {
						const e = t.getChild(0);
						if (
							e.is("element") &&
							!e.is("uiElement") &&
							!e.is("attributeElement")
						)
							return e;
					}
					return null;
				}
				const wd = new Map();
				function Ad(t, e, n) {
					let o = wd.get(t);
					o || ((o = new Map()), wd.set(t, o)), o.set(e, n);
				}
				function _d(t) {
					return [t];
				}
				function Cd(t, e, n = {}) {
					const o = (function (t, e) {
						const n = wd.get(t);
						return n && n.has(e) ? n.get(e) : _d;
					})(t.constructor, e.constructor);
					try {
						return o((t = t.clone()), e, n);
					} catch (t) {
						throw t;
					}
				}
				function vd(t, e, n) {
					(t = t.slice()), (e = e.slice());
					const o = new yd(n.document, n.useRelations, n.forceWeakRemove);
					o.setOriginalOperations(t), o.setOriginalOperations(e);
					const i = o.originalOperations;
					if (0 == t.length || 0 == e.length)
						return { operationsA: t, operationsB: e, originalOperations: i };
					const r = new WeakMap();
					for (const e of t) r.set(e, 0);
					const s = {
						nextBaseVersionA: t[t.length - 1].baseVersion + 1,
						nextBaseVersionB: e[e.length - 1].baseVersion + 1,
						originalOperationsACount: t.length,
						originalOperationsBCount: e.length,
					};
					let a = 0;
					for (; a < t.length; ) {
						const n = t[a],
							i = r.get(n);
						if (i == e.length) {
							a++;
							continue;
						}
						const s = e[i],
							c = Cd(n, s, o.getContext(n, s, !0)),
							l = Cd(s, n, o.getContext(s, n, !1));
						o.updateRelation(n, s),
							o.setOriginalOperations(c, n),
							o.setOriginalOperations(l, s);
						for (const t of c) r.set(t, i + l.length);
						t.splice(a, 1, ...c), e.splice(i, 1, ...l);
					}
					if (n.padWithNoOps) {
						const n = t.length - s.originalOperationsACount,
							o = e.length - s.originalOperationsBCount;
						Dd(t, o - n), Dd(e, n - o);
					}
					return (
						xd(t, s.nextBaseVersionB),
						xd(e, s.nextBaseVersionA),
						{ operationsA: t, operationsB: e, originalOperations: i }
					);
				}
				class yd {
					constructor(t, e, n = !1) {
						(this.originalOperations = new Map()),
							(this._history = t.history),
							(this._useRelations = e),
							(this._forceWeakRemove = !!n),
							(this._relations = new Map());
					}
					setOriginalOperations(t, e = null) {
						const n = e ? this.originalOperations.get(e) : null;
						for (const e of t) this.originalOperations.set(e, n || e);
					}
					updateRelation(t, e) {
						if (t instanceof Il)
							e instanceof Vl
								? t.targetPosition.isEqual(e.sourcePosition) ||
									e.movedRange.containsPosition(t.targetPosition)
									? this._setRelation(t, e, "insertAtSource")
									: t.targetPosition.isEqual(e.deletionPosition)
										? this._setRelation(t, e, "insertBetween")
										: t.targetPosition.isAfter(e.sourcePosition) &&
											this._setRelation(t, e, "moveTargetAfter")
								: e instanceof Il &&
									(t.targetPosition.isEqual(e.sourcePosition) ||
									t.targetPosition.isBefore(e.sourcePosition)
										? this._setRelation(t, e, "insertBefore")
										: this._setRelation(t, e, "insertAfter"));
						else if (t instanceof Ll) {
							if (e instanceof Vl)
								t.splitPosition.isBefore(e.sourcePosition) &&
									this._setRelation(t, e, "splitBefore");
							else if (e instanceof Il)
								if (
									t.splitPosition.isEqual(e.sourcePosition) ||
									t.splitPosition.isBefore(e.sourcePosition)
								)
									this._setRelation(t, e, "splitBefore");
								else {
									const n = qa._createFromPositionAndShift(
										e.sourcePosition,
										e.howMany,
									);
									if (
										t.splitPosition.hasSameParentAs(e.sourcePosition) &&
										n.containsPosition(t.splitPosition)
									) {
										const o = n.end.offset - t.splitPosition.offset,
											i = t.splitPosition.offset - n.start.offset;
										this._setRelation(t, e, { howMany: o, offset: i });
									}
								}
						} else if (t instanceof Vl)
							e instanceof Vl
								? (t.targetPosition.isEqual(e.sourcePosition) ||
										this._setRelation(t, e, "mergeTargetNotMoved"),
									t.sourcePosition.isEqual(e.targetPosition) &&
										this._setRelation(t, e, "mergeSourceNotMoved"),
									t.sourcePosition.isEqual(e.sourcePosition) &&
										this._setRelation(t, e, "mergeSameElement"))
								: e instanceof Ll &&
									t.sourcePosition.isEqual(e.splitPosition) &&
									this._setRelation(t, e, "splitAtSource");
						else if (t instanceof Rl) {
							const n = t.newRange;
							if (!n) return;
							if (e instanceof Il) {
								const o = qa._createFromPositionAndShift(
										e.sourcePosition,
										e.howMany,
									),
									i = o.containsPosition(n.start) || o.start.isEqual(n.start),
									r = o.containsPosition(n.end) || o.end.isEqual(n.end);
								(!i && !r) ||
									o.containsRange(n) ||
									this._setRelation(t, e, {
										side: i ? "left" : "right",
										path: i ? n.start.path.slice() : n.end.path.slice(),
									});
							} else if (e instanceof Vl) {
								const o = n.start.isEqual(e.targetPosition),
									i = n.start.isEqual(e.deletionPosition),
									r = n.end.isEqual(e.deletionPosition),
									s = n.end.isEqual(e.sourcePosition);
								(o || i || r || s) &&
									this._setRelation(t, e, {
										wasInLeftElement: o,
										wasStartBeforeMergedElement: i,
										wasEndBeforeMergedElement: r,
										wasInRightElement: s,
									});
							}
						}
					}
					getContext(t, e, n) {
						return {
							aIsStrong: n,
							aWasUndone: this._wasUndone(t),
							bWasUndone: this._wasUndone(e),
							abRelation: this._useRelations ? this._getRelation(t, e) : null,
							baRelation: this._useRelations ? this._getRelation(e, t) : null,
							forceWeakRemove: this._forceWeakRemove,
						};
					}
					_wasUndone(t) {
						const e = this.originalOperations.get(t);
						return e.wasUndone || this._history.isUndoneOperation(e);
					}
					_getRelation(t, e) {
						const n = this.originalOperations.get(e),
							o = this._history.getUndoneOperation(n);
						if (!o) return null;
						const i = this.originalOperations.get(t),
							r = this._relations.get(i);
						return (r && r.get(o)) || null;
					}
					_setRelation(t, e, n) {
						const o = this.originalOperations.get(t),
							i = this.originalOperations.get(e);
						let r = this._relations.get(o);
						r || ((r = new Map()), this._relations.set(o, r)), r.set(i, n);
					}
				}
				function xd(t, e) {
					for (const n of t) n.baseVersion = e++;
				}
				function Dd(t, e) {
					for (let n = 0; n < e; n++) t.push(new Ol(0));
				}
				function Ed(t, e, n) {
					const o = t.nodes.getNode(0).getAttribute(e);
					if (o == n) return null;
					const i = new qa(t.position, t.position.getShiftedBy(t.howMany));
					return new Fl(i, e, o, n, 0);
				}
				function Sd(t, e) {
					return (
						null ===
						t.targetPosition._getTransformedByDeletion(
							e.sourcePosition,
							e.howMany,
						)
					);
				}
				function Bd(t, e) {
					const n = [];
					for (let o = 0; o < t.length; o++) {
						const i = t[o],
							r = new Il(i.start, i.end.offset - i.start.offset, e, 0);
						n.push(r);
						for (let e = o + 1; e < t.length; e++)
							t[e] = t[e]._getTransformedByMove(
								r.sourcePosition,
								r.targetPosition,
								r.howMany,
							)[0];
						e = e._getTransformedByMove(
							r.sourcePosition,
							r.targetPosition,
							r.howMany,
						);
					}
					return n;
				}
				Ad(Fl, Fl, (t, e, n) => {
					if (t.key === e.key && t.range.start.hasSameParentAs(e.range.start)) {
						const o = t.range
								.getDifference(e.range)
								.map((e) => new Fl(e, t.key, t.oldValue, t.newValue, 0)),
							i = t.range.getIntersection(e.range);
						return (
							i &&
								n.aIsStrong &&
								o.push(new Fl(i, e.key, e.newValue, t.newValue, 0)),
							0 == o.length ? [new Ol(0)] : o
						);
					}
					return [t];
				}),
					Ad(Fl, zl, (t, e) => {
						if (
							t.range.start.hasSameParentAs(e.position) &&
							t.range.containsPosition(e.position)
						) {
							const n = t.range
								._getTransformedByInsertion(
									e.position,
									e.howMany,
									!e.shouldReceiveAttributes,
								)
								.map(
									(e) =>
										new Fl(e, t.key, t.oldValue, t.newValue, t.baseVersion),
								);
							if (e.shouldReceiveAttributes) {
								const o = Ed(e, t.key, t.oldValue);
								o && n.unshift(o);
							}
							return n;
						}
						return (
							(t.range = t.range._getTransformedByInsertion(
								e.position,
								e.howMany,
								!1,
							)[0]),
							[t]
						);
					}),
					Ad(Fl, Vl, (t, e) => {
						const n = [];
						t.range.start.hasSameParentAs(e.deletionPosition) &&
							(t.range.containsPosition(e.deletionPosition) ||
								t.range.start.isEqual(e.deletionPosition)) &&
							n.push(qa._createFromPositionAndShift(e.graveyardPosition, 1));
						const o = t.range._getTransformedByMergeOperation(e);
						return (
							o.isCollapsed || n.push(o),
							n.map(
								(e) => new Fl(e, t.key, t.oldValue, t.newValue, t.baseVersion),
							)
						);
					}),
					Ad(Fl, Il, (t, e) =>
						(function (t, e) {
							const n = qa._createFromPositionAndShift(
								e.sourcePosition,
								e.howMany,
							);
							let o = null,
								i = [];
							n.containsRange(t, !0)
								? (o = t)
								: t.start.hasSameParentAs(n.start)
									? ((i = t.getDifference(n)), (o = t.getIntersection(n)))
									: (i = [t]);
							const r = [];
							for (let t of i) {
								t = t._getTransformedByDeletion(e.sourcePosition, e.howMany);
								const n = e.getMovedRangeStart(),
									o = t.start.hasSameParentAs(n),
									i = t._getTransformedByInsertion(n, e.howMany, o);
								r.push(...i);
							}
							o &&
								r.push(
									o._getTransformedByMove(
										e.sourcePosition,
										e.targetPosition,
										e.howMany,
										!1,
									)[0],
								);
							return r;
						})(t.range, e).map(
							(e) => new Fl(e, t.key, t.oldValue, t.newValue, t.baseVersion),
						),
					),
					Ad(Fl, Ll, (t, e) => {
						if (t.range.end.isEqual(e.insertionPosition))
							return e.graveyardPosition || t.range.end.offset++, [t];
						if (
							t.range.start.hasSameParentAs(e.splitPosition) &&
							t.range.containsPosition(e.splitPosition)
						) {
							const n = t.clone();
							return (
								(n.range = new qa(
									e.moveTargetPosition.clone(),
									t.range.end._getCombined(
										e.splitPosition,
										e.moveTargetPosition,
									),
								)),
								(t.range.end = e.splitPosition.clone()),
								(t.range.end.stickiness = "toPrevious"),
								[t, n]
							);
						}
						return (t.range = t.range._getTransformedBySplitOperation(e)), [t];
					}),
					Ad(zl, Fl, (t, e) => {
						const n = [t];
						if (
							t.shouldReceiveAttributes &&
							t.position.hasSameParentAs(e.range.start) &&
							e.range.containsPosition(t.position)
						) {
							const o = Ed(t, e.key, e.newValue);
							o && n.push(o);
						}
						return n;
					}),
					Ad(
						zl,
						zl,
						(t, e, n) => (
							(t.position.isEqual(e.position) && n.aIsStrong) ||
								(t.position = t.position._getTransformedByInsertOperation(e)),
							[t]
						),
					),
					Ad(
						zl,
						Il,
						(t, e) => (
							(t.position = t.position._getTransformedByMoveOperation(e)), [t]
						),
					),
					Ad(
						zl,
						Ll,
						(t, e) => (
							(t.position = t.position._getTransformedBySplitOperation(e)), [t]
						),
					),
					Ad(
						zl,
						Vl,
						(t, e) => (
							(t.position = t.position._getTransformedByMergeOperation(e)), [t]
						),
					),
					Ad(
						Rl,
						zl,
						(t, e) => (
							t.oldRange &&
								(t.oldRange =
									t.oldRange._getTransformedByInsertOperation(e)[0]),
							t.newRange &&
								(t.newRange =
									t.newRange._getTransformedByInsertOperation(e)[0]),
							[t]
						),
					),
					Ad(Rl, Rl, (t, e, n) => {
						if (t.name == e.name) {
							if (!n.aIsStrong) return [new Ol(0)];
							t.oldRange = e.newRange ? e.newRange.clone() : null;
						}
						return [t];
					}),
					Ad(
						Rl,
						Vl,
						(t, e) => (
							t.oldRange &&
								(t.oldRange = t.oldRange._getTransformedByMergeOperation(e)),
							t.newRange &&
								(t.newRange = t.newRange._getTransformedByMergeOperation(e)),
							[t]
						),
					),
					Ad(Rl, Il, (t, e, n) => {
						if (
							(t.oldRange &&
								(t.oldRange = qa._createFromRanges(
									t.oldRange._getTransformedByMoveOperation(e),
								)),
							t.newRange)
						) {
							if (n.abRelation) {
								const o = qa._createFromRanges(
									t.newRange._getTransformedByMoveOperation(e),
								);
								if (
									"left" == n.abRelation.side &&
									e.targetPosition.isEqual(t.newRange.start)
								)
									return (
										(t.newRange.end = o.end),
										(t.newRange.start.path = n.abRelation.path),
										[t]
									);
								if (
									"right" == n.abRelation.side &&
									e.targetPosition.isEqual(t.newRange.end)
								)
									return (
										(t.newRange.start = o.start),
										(t.newRange.end.path = n.abRelation.path),
										[t]
									);
							}
							t.newRange = qa._createFromRanges(
								t.newRange._getTransformedByMoveOperation(e),
							);
						}
						return [t];
					}),
					Ad(Rl, Ll, (t, e, n) => {
						if (
							(t.oldRange &&
								(t.oldRange = t.oldRange._getTransformedBySplitOperation(e)),
							t.newRange)
						) {
							if (n.abRelation) {
								const o = t.newRange._getTransformedBySplitOperation(e);
								return (
									t.newRange.start.isEqual(e.splitPosition) &&
									n.abRelation.wasStartBeforeMergedElement
										? (t.newRange.start = Na._createAt(e.insertionPosition))
										: t.newRange.start.isEqual(e.splitPosition) &&
											!n.abRelation.wasInLeftElement &&
											(t.newRange.start = Na._createAt(e.moveTargetPosition)),
									t.newRange.end.isEqual(e.splitPosition) &&
									n.abRelation.wasInRightElement
										? (t.newRange.end = Na._createAt(e.moveTargetPosition))
										: t.newRange.end.isEqual(e.splitPosition) &&
												n.abRelation.wasEndBeforeMergedElement
											? (t.newRange.end = Na._createAt(e.insertionPosition))
											: (t.newRange.end = o.end),
									[t]
								);
							}
							t.newRange = t.newRange._getTransformedBySplitOperation(e);
						}
						return [t];
					}),
					Ad(
						Vl,
						zl,
						(t, e) => (
							t.sourcePosition.hasSameParentAs(e.position) &&
								(t.howMany += e.howMany),
							(t.sourcePosition =
								t.sourcePosition._getTransformedByInsertOperation(e)),
							(t.targetPosition =
								t.targetPosition._getTransformedByInsertOperation(e)),
							[t]
						),
					),
					Ad(Vl, Vl, (t, e, n) => {
						if (
							t.sourcePosition.isEqual(e.sourcePosition) &&
							t.targetPosition.isEqual(e.targetPosition)
						) {
							if (n.bWasUndone) {
								const n = e.graveyardPosition.path.slice();
								return (
									n.push(0),
									(t.sourcePosition = new Na(e.graveyardPosition.root, n)),
									(t.howMany = 0),
									[t]
								);
							}
							return [new Ol(0)];
						}
						if (
							t.sourcePosition.isEqual(e.sourcePosition) &&
							!t.targetPosition.isEqual(e.targetPosition) &&
							!n.bWasUndone &&
							"splitAtSource" != n.abRelation
						) {
							const o = "$graveyard" == t.targetPosition.root.rootName,
								i = "$graveyard" == e.targetPosition.root.rootName,
								r = o && !i;
							if ((i && !o) || (!r && n.aIsStrong)) {
								const n = e.targetPosition._getTransformedByMergeOperation(e),
									o = t.targetPosition._getTransformedByMergeOperation(e);
								return [new Il(n, t.howMany, o, 0)];
							}
							return [new Ol(0)];
						}
						return (
							t.sourcePosition.hasSameParentAs(e.targetPosition) &&
								(t.howMany += e.howMany),
							(t.sourcePosition =
								t.sourcePosition._getTransformedByMergeOperation(e)),
							(t.targetPosition =
								t.targetPosition._getTransformedByMergeOperation(e)),
							(t.graveyardPosition.isEqual(e.graveyardPosition) &&
								n.aIsStrong) ||
								(t.graveyardPosition =
									t.graveyardPosition._getTransformedByMergeOperation(e)),
							[t]
						);
					}),
					Ad(Vl, Il, (t, e, n) => {
						const o = qa._createFromPositionAndShift(
							e.sourcePosition,
							e.howMany,
						);
						return "remove" == e.type &&
							!n.bWasUndone &&
							!n.forceWeakRemove &&
							t.deletionPosition.hasSameParentAs(e.sourcePosition) &&
							o.containsPosition(t.sourcePosition)
							? [new Ol(0)]
							: (t.sourcePosition.hasSameParentAs(e.targetPosition) &&
									(t.howMany += e.howMany),
								t.sourcePosition.hasSameParentAs(e.sourcePosition) &&
									(t.howMany -= e.howMany),
								(t.sourcePosition =
									t.sourcePosition._getTransformedByMoveOperation(e)),
								(t.targetPosition =
									t.targetPosition._getTransformedByMoveOperation(e)),
								t.graveyardPosition.isEqual(e.targetPosition) ||
									(t.graveyardPosition =
										t.graveyardPosition._getTransformedByMoveOperation(e)),
								[t]);
					}),
					Ad(Vl, Ll, (t, e, n) => {
						if (
							(e.graveyardPosition &&
								((t.graveyardPosition =
									t.graveyardPosition._getTransformedByDeletion(
										e.graveyardPosition,
										1,
									)),
								t.deletionPosition.isEqual(e.graveyardPosition) &&
									(t.howMany = e.howMany)),
							t.targetPosition.isEqual(e.splitPosition))
						) {
							const o = 0 != e.howMany,
								i =
									e.graveyardPosition &&
									t.deletionPosition.isEqual(e.graveyardPosition);
							if (o || i || "mergeTargetNotMoved" == n.abRelation)
								return (
									(t.sourcePosition =
										t.sourcePosition._getTransformedBySplitOperation(e)),
									[t]
								);
						}
						if (t.sourcePosition.isEqual(e.splitPosition)) {
							if ("mergeSourceNotMoved" == n.abRelation)
								return (
									(t.howMany = 0),
									(t.targetPosition =
										t.targetPosition._getTransformedBySplitOperation(e)),
									[t]
								);
							if (
								"mergeSameElement" == n.abRelation ||
								t.sourcePosition.offset > 0
							)
								return (
									(t.sourcePosition = e.moveTargetPosition.clone()),
									(t.targetPosition =
										t.targetPosition._getTransformedBySplitOperation(e)),
									[t]
								);
						}
						return (
							t.sourcePosition.hasSameParentAs(e.splitPosition) &&
								(t.howMany = e.splitPosition.offset),
							(t.sourcePosition =
								t.sourcePosition._getTransformedBySplitOperation(e)),
							(t.targetPosition =
								t.targetPosition._getTransformedBySplitOperation(e)),
							[t]
						);
					}),
					Ad(Il, zl, (t, e) => {
						const n = qa
							._createFromPositionAndShift(t.sourcePosition, t.howMany)
							._getTransformedByInsertOperation(e, !1)[0];
						return (
							(t.sourcePosition = n.start),
							(t.howMany = n.end.offset - n.start.offset),
							t.targetPosition.isEqual(e.position) ||
								(t.targetPosition =
									t.targetPosition._getTransformedByInsertOperation(e)),
							[t]
						);
					}),
					Ad(Il, Il, (t, e, n) => {
						const o = qa._createFromPositionAndShift(
								t.sourcePosition,
								t.howMany,
							),
							i = qa._createFromPositionAndShift(e.sourcePosition, e.howMany);
						let r,
							s = n.aIsStrong,
							a = !n.aIsStrong;
						if (
							("insertBefore" == n.abRelation || "insertAfter" == n.baRelation
								? (a = !0)
								: ("insertAfter" != n.abRelation &&
										"insertBefore" != n.baRelation) ||
									(a = !1),
							(r =
								t.targetPosition.isEqual(e.targetPosition) && a
									? t.targetPosition._getTransformedByDeletion(
											e.sourcePosition,
											e.howMany,
										)
									: t.targetPosition._getTransformedByMove(
											e.sourcePosition,
											e.targetPosition,
											e.howMany,
										)),
							Sd(t, e) && Sd(e, t))
						)
							return [e.getReversed()];
						if (o.containsPosition(e.targetPosition) && o.containsRange(i, !0))
							return (
								(o.start = o.start._getTransformedByMove(
									e.sourcePosition,
									e.targetPosition,
									e.howMany,
								)),
								(o.end = o.end._getTransformedByMove(
									e.sourcePosition,
									e.targetPosition,
									e.howMany,
								)),
								Bd([o], r)
							);
						if (i.containsPosition(t.targetPosition) && i.containsRange(o, !0))
							return (
								(o.start = o.start._getCombined(
									e.sourcePosition,
									e.getMovedRangeStart(),
								)),
								(o.end = o.end._getCombined(
									e.sourcePosition,
									e.getMovedRangeStart(),
								)),
								Bd([o], r)
							);
						const c = uo(
							t.sourcePosition.getParentPath(),
							e.sourcePosition.getParentPath(),
						);
						if ("prefix" == c || "extension" == c)
							return (
								(o.start = o.start._getTransformedByMove(
									e.sourcePosition,
									e.targetPosition,
									e.howMany,
								)),
								(o.end = o.end._getTransformedByMove(
									e.sourcePosition,
									e.targetPosition,
									e.howMany,
								)),
								Bd([o], r)
							);
						"remove" != t.type ||
						"remove" == e.type ||
						n.aWasUndone ||
						n.forceWeakRemove
							? "remove" == t.type ||
								"remove" != e.type ||
								n.bWasUndone ||
								n.forceWeakRemove ||
								(s = !1)
							: (s = !0);
						const l = [],
							d = o.getDifference(i);
						for (const t of d) {
							(t.start = t.start._getTransformedByDeletion(
								e.sourcePosition,
								e.howMany,
							)),
								(t.end = t.end._getTransformedByDeletion(
									e.sourcePosition,
									e.howMany,
								));
							const n =
									"same" ==
									uo(
										t.start.getParentPath(),
										e.getMovedRangeStart().getParentPath(),
									),
								o = t._getTransformedByInsertion(
									e.getMovedRangeStart(),
									e.howMany,
									n,
								);
							l.push(...o);
						}
						const u = o.getIntersection(i);
						return (
							null !== u &&
								s &&
								((u.start = u.start._getCombined(
									e.sourcePosition,
									e.getMovedRangeStart(),
								)),
								(u.end = u.end._getCombined(
									e.sourcePosition,
									e.getMovedRangeStart(),
								)),
								0 === l.length
									? l.push(u)
									: 1 == l.length
										? i.start.isBefore(o.start) || i.start.isEqual(o.start)
											? l.unshift(u)
											: l.push(u)
										: l.splice(1, 0, u)),
							0 === l.length ? [new Ol(t.baseVersion)] : Bd(l, r)
						);
					}),
					Ad(Il, Ll, (t, e, n) => {
						let o = t.targetPosition.clone();
						(t.targetPosition.isEqual(e.insertionPosition) &&
							e.graveyardPosition &&
							"moveTargetAfter" != n.abRelation) ||
							(o = t.targetPosition._getTransformedBySplitOperation(e));
						const i = qa._createFromPositionAndShift(
							t.sourcePosition,
							t.howMany,
						);
						if (i.end.isEqual(e.insertionPosition))
							return (
								e.graveyardPosition || t.howMany++, (t.targetPosition = o), [t]
							);
						if (
							i.start.hasSameParentAs(e.splitPosition) &&
							i.containsPosition(e.splitPosition)
						) {
							let t = new qa(e.splitPosition, i.end);
							t = t._getTransformedBySplitOperation(e);
							return Bd([new qa(i.start, e.splitPosition), t], o);
						}
						t.targetPosition.isEqual(e.splitPosition) &&
							"insertAtSource" == n.abRelation &&
							(o = e.moveTargetPosition),
							t.targetPosition.isEqual(e.insertionPosition) &&
								"insertBetween" == n.abRelation &&
								(o = t.targetPosition);
						const r = [i._getTransformedBySplitOperation(e)];
						if (e.graveyardPosition) {
							const o =
								i.start.isEqual(e.graveyardPosition) ||
								i.containsPosition(e.graveyardPosition);
							t.howMany > 1 &&
								o &&
								!n.aWasUndone &&
								r.push(qa._createFromPositionAndShift(e.insertionPosition, 1));
						}
						return Bd(r, o);
					}),
					Ad(Il, Vl, (t, e, n) => {
						const o = qa._createFromPositionAndShift(
							t.sourcePosition,
							t.howMany,
						);
						if (
							e.deletionPosition.hasSameParentAs(t.sourcePosition) &&
							o.containsPosition(e.sourcePosition)
						)
							if ("remove" != t.type || n.forceWeakRemove) {
								if (1 == t.howMany)
									return n.bWasUndone
										? ((t.sourcePosition = e.graveyardPosition.clone()),
											(t.targetPosition =
												t.targetPosition._getTransformedByMergeOperation(e)),
											[t])
										: [new Ol(0)];
							} else if (!n.aWasUndone) {
								const n = [];
								let o = e.graveyardPosition.clone(),
									i = e.targetPosition._getTransformedByMergeOperation(e);
								t.howMany > 1 &&
									(n.push(
										new Il(
											t.sourcePosition,
											t.howMany - 1,
											t.targetPosition,
											0,
										),
									),
									(o = o._getTransformedByMove(
										t.sourcePosition,
										t.targetPosition,
										t.howMany - 1,
									)),
									(i = i._getTransformedByMove(
										t.sourcePosition,
										t.targetPosition,
										t.howMany - 1,
									)));
								const r = e.deletionPosition._getCombined(
										t.sourcePosition,
										t.targetPosition,
									),
									s = new Il(o, 1, r, 0),
									a = s.getMovedRangeStart().path.slice();
								a.push(0);
								const c = new Na(s.targetPosition.root, a);
								i = i._getTransformedByMove(o, r, 1);
								const l = new Il(i, e.howMany, c, 0);
								return n.push(s), n.push(l), n;
							}
						const i = qa
							._createFromPositionAndShift(t.sourcePosition, t.howMany)
							._getTransformedByMergeOperation(e);
						return (
							(t.sourcePosition = i.start),
							(t.howMany = i.end.offset - i.start.offset),
							(t.targetPosition =
								t.targetPosition._getTransformedByMergeOperation(e)),
							[t]
						);
					}),
					Ad(
						Ml,
						zl,
						(t, e) => (
							(t.position = t.position._getTransformedByInsertOperation(e)), [t]
						),
					),
					Ad(Ml, Vl, (t, e) =>
						t.position.isEqual(e.deletionPosition)
							? ((t.position = e.graveyardPosition.clone()),
								(t.position.stickiness = "toNext"),
								[t])
							: ((t.position = t.position._getTransformedByMergeOperation(e)),
								[t]),
					),
					Ad(
						Ml,
						Il,
						(t, e) => (
							(t.position = t.position._getTransformedByMoveOperation(e)), [t]
						),
					),
					Ad(Ml, Ml, (t, e, n) => {
						if (t.position.isEqual(e.position)) {
							if (!n.aIsStrong) return [new Ol(0)];
							t.oldName = e.newName;
						}
						return [t];
					}),
					Ad(Ml, Ll, (t, e) => {
						if (
							"same" == uo(t.position.path, e.splitPosition.getParentPath()) &&
							!e.graveyardPosition
						) {
							const e = new Ml(
								t.position.getShiftedBy(1),
								t.oldName,
								t.newName,
								0,
							);
							return [t, e];
						}
						return (
							(t.position = t.position._getTransformedBySplitOperation(e)), [t]
						);
					}),
					Ad(Nl, Nl, (t, e, n) => {
						if (t.root === e.root && t.key === e.key) {
							if (!n.aIsStrong || t.newValue === e.newValue) return [new Ol(0)];
							t.oldValue = e.newValue;
						}
						return [t];
					}),
					Ad(
						Ll,
						zl,
						(t, e) => (
							t.splitPosition.hasSameParentAs(e.position) &&
								t.splitPosition.offset < e.position.offset &&
								(t.howMany += e.howMany),
							(t.splitPosition =
								t.splitPosition._getTransformedByInsertOperation(e)),
							(t.insertionPosition =
								t.insertionPosition._getTransformedByInsertOperation(e)),
							[t]
						),
					),
					Ad(Ll, Vl, (t, e, n) => {
						if (
							!t.graveyardPosition &&
							!n.bWasUndone &&
							t.splitPosition.hasSameParentAs(e.sourcePosition)
						) {
							const n = e.graveyardPosition.path.slice();
							n.push(0);
							const o = new Na(e.graveyardPosition.root, n),
								i = Ll.getInsertionPosition(
									new Na(e.graveyardPosition.root, n),
								),
								r = new Ll(o, 0, i, null, 0);
							return (
								(t.splitPosition =
									t.splitPosition._getTransformedByMergeOperation(e)),
								(t.insertionPosition = Ll.getInsertionPosition(
									t.splitPosition,
								)),
								(t.graveyardPosition = r.insertionPosition.clone()),
								(t.graveyardPosition.stickiness = "toNext"),
								[r, t]
							);
						}
						return (
							t.splitPosition.hasSameParentAs(e.deletionPosition) &&
								!t.splitPosition.isAfter(e.deletionPosition) &&
								t.howMany--,
							t.splitPosition.hasSameParentAs(e.targetPosition) &&
								(t.howMany += e.howMany),
							(t.splitPosition =
								t.splitPosition._getTransformedByMergeOperation(e)),
							(t.insertionPosition = Ll.getInsertionPosition(t.splitPosition)),
							t.graveyardPosition &&
								(t.graveyardPosition =
									t.graveyardPosition._getTransformedByMergeOperation(e)),
							[t]
						);
					}),
					Ad(Ll, Il, (t, e, n) => {
						const o = qa._createFromPositionAndShift(
							e.sourcePosition,
							e.howMany,
						);
						if (t.graveyardPosition) {
							const i =
								o.start.isEqual(t.graveyardPosition) ||
								o.containsPosition(t.graveyardPosition);
							if (!n.bWasUndone && i) {
								const n = t.splitPosition._getTransformedByMoveOperation(e),
									o = t.graveyardPosition._getTransformedByMoveOperation(e),
									i = o.path.slice();
								i.push(0);
								const r = new Na(o.root, i);
								return [new Il(n, t.howMany, r, 0)];
							}
							t.graveyardPosition =
								t.graveyardPosition._getTransformedByMoveOperation(e);
						}
						const i = t.splitPosition.isEqual(e.targetPosition);
						if (
							i &&
							("insertAtSource" == n.baRelation ||
								"splitBefore" == n.abRelation)
						)
							return (
								(t.howMany += e.howMany),
								(t.splitPosition = t.splitPosition._getTransformedByDeletion(
									e.sourcePosition,
									e.howMany,
								)),
								(t.insertionPosition = Ll.getInsertionPosition(
									t.splitPosition,
								)),
								[t]
							);
						if (i && n.abRelation && n.abRelation.howMany) {
							const { howMany: e, offset: o } = n.abRelation;
							return (
								(t.howMany += e),
								(t.splitPosition = t.splitPosition.getShiftedBy(o)),
								[t]
							);
						}
						if (
							t.splitPosition.hasSameParentAs(e.sourcePosition) &&
							o.containsPosition(t.splitPosition)
						) {
							const n =
								e.howMany - (t.splitPosition.offset - e.sourcePosition.offset);
							return (
								(t.howMany -= n),
								t.splitPosition.hasSameParentAs(e.targetPosition) &&
									t.splitPosition.offset < e.targetPosition.offset &&
									(t.howMany += e.howMany),
								(t.splitPosition = e.sourcePosition.clone()),
								(t.insertionPosition = Ll.getInsertionPosition(
									t.splitPosition,
								)),
								[t]
							);
						}
						return (
							e.sourcePosition.isEqual(e.targetPosition) ||
								(t.splitPosition.hasSameParentAs(e.sourcePosition) &&
									t.splitPosition.offset <= e.sourcePosition.offset &&
									(t.howMany -= e.howMany),
								t.splitPosition.hasSameParentAs(e.targetPosition) &&
									t.splitPosition.offset < e.targetPosition.offset &&
									(t.howMany += e.howMany)),
							(t.splitPosition.stickiness = "toNone"),
							(t.splitPosition =
								t.splitPosition._getTransformedByMoveOperation(e)),
							(t.splitPosition.stickiness = "toNext"),
							t.graveyardPosition
								? (t.insertionPosition =
										t.insertionPosition._getTransformedByMoveOperation(e))
								: (t.insertionPosition = Ll.getInsertionPosition(
										t.splitPosition,
									)),
							[t]
						);
					}),
					Ad(Ll, Ll, (t, e, n) => {
						if (t.splitPosition.isEqual(e.splitPosition)) {
							if (!t.graveyardPosition && !e.graveyardPosition)
								return [new Ol(0)];
							if (
								t.graveyardPosition &&
								e.graveyardPosition &&
								t.graveyardPosition.isEqual(e.graveyardPosition)
							)
								return [new Ol(0)];
							if ("splitBefore" == n.abRelation)
								return (
									(t.howMany = 0),
									(t.graveyardPosition =
										t.graveyardPosition._getTransformedBySplitOperation(e)),
									[t]
								);
						}
						if (
							t.graveyardPosition &&
							e.graveyardPosition &&
							t.graveyardPosition.isEqual(e.graveyardPosition)
						) {
							const o = "$graveyard" == t.splitPosition.root.rootName,
								i = "$graveyard" == e.splitPosition.root.rootName,
								r = o && !i;
							if ((i && !o) || (!r && n.aIsStrong)) {
								const n = [];
								return (
									e.howMany &&
										n.push(
											new Il(
												e.moveTargetPosition,
												e.howMany,
												e.splitPosition,
												0,
											),
										),
									t.howMany &&
										n.push(
											new Il(
												t.splitPosition,
												t.howMany,
												t.moveTargetPosition,
												0,
											),
										),
									n
								);
							}
							return [new Ol(0)];
						}
						if (
							(t.graveyardPosition &&
								(t.graveyardPosition =
									t.graveyardPosition._getTransformedBySplitOperation(e)),
							t.splitPosition.isEqual(e.insertionPosition) &&
								"splitBefore" == n.abRelation)
						)
							return t.howMany++, [t];
						if (
							e.splitPosition.isEqual(t.insertionPosition) &&
							"splitBefore" == n.baRelation
						) {
							const n = e.insertionPosition.path.slice();
							n.push(0);
							const o = new Na(e.insertionPosition.root, n);
							return [t, new Il(t.insertionPosition, 1, o, 0)];
						}
						return (
							t.splitPosition.hasSameParentAs(e.splitPosition) &&
								t.splitPosition.offset < e.splitPosition.offset &&
								(t.howMany -= e.howMany),
							(t.splitPosition =
								t.splitPosition._getTransformedBySplitOperation(e)),
							(t.insertionPosition = Ll.getInsertionPosition(t.splitPosition)),
							[t]
						);
					});
				class Td extends ds {
					constructor(t) {
						super(t), (this.domEventType = "click");
					}
					onDomEvent(t) {
						this.fire(t.type, t);
					}
				}
				class Pd extends ds {
					constructor(t) {
						super(t),
							(this.domEventType = [
								"mousedown",
								"mouseup",
								"mouseover",
								"mouseout",
							]);
					}
					onDomEvent(t) {
						this.fire(t.type, t);
					}
				}
				class Fd {
					constructor(t) {
						this.document = t;
					}
					createDocumentFragment(t) {
						return new sr(this.document, t);
					}
					createElement(t, e, n) {
						return new mi(this.document, t, e, n);
					}
					createText(t) {
						return new go(this.document, t);
					}
					clone(t, e = !1) {
						return t._clone(e);
					}
					appendChild(t, e) {
						return e._appendChild(t);
					}
					insertChild(t, e, n) {
						return n._insertChild(t, e);
					}
					removeChildren(t, e, n) {
						return n._removeChildren(t, e);
					}
					remove(t) {
						const e = t.parent;
						return e ? this.removeChildren(e.getChildIndex(t), 1, e) : [];
					}
					replace(t, e) {
						const n = t.parent;
						if (n) {
							const o = n.getChildIndex(t);
							return (
								this.removeChildren(o, 1, n), this.insertChild(o, e, n), !0
							);
						}
						return !1;
					}
					unwrapElement(t) {
						const e = t.parent;
						if (e) {
							const n = e.getChildIndex(t);
							this.remove(t), this.insertChild(n, t.getChildren(), e);
						}
					}
					rename(t, e) {
						const n = new mi(
							this.document,
							t,
							e.getAttributes(),
							e.getChildren(),
						);
						return this.replace(e, n) ? n : null;
					}
					setAttribute(t, e, n) {
						n._setAttribute(t, e);
					}
					removeAttribute(t, e) {
						e._removeAttribute(t);
					}
					addClass(t, e) {
						e._addClass(t);
					}
					removeClass(t, e) {
						e._removeClass(t);
					}
					setStyle(t, e, n) {
						it(t) && void 0 === n ? e._setStyle(t) : n._setStyle(t, e);
					}
					removeStyle(t, e) {
						e._removeStyle(t);
					}
					setCustomProperty(t, e, n) {
						n._setCustomProperty(t, e);
					}
					removeCustomProperty(t, e) {
						return e._removeCustomProperty(t);
					}
					createPositionAt(t, e) {
						return yi._createAt(t, e);
					}
					createPositionAfter(t) {
						return yi._createAfter(t);
					}
					createPositionBefore(t) {
						return yi._createBefore(t);
					}
					createRange(t, e) {
						return new xi(t, e);
					}
					createRangeOn(t) {
						return xi._createOn(t);
					}
					createRangeIn(t) {
						return xi._createIn(t);
					}
					createSelection(...t) {
						return new Si(...t);
					}
				}
				new Set([
					"black",
					"silver",
					"gray",
					"white",
					"maroon",
					"red",
					"purple",
					"fuchsia",
					"green",
					"lime",
					"olive",
					"yellow",
					"navy",
					"blue",
					"teal",
					"aqua",
					"orange",
					"aliceblue",
					"antiquewhite",
					"aquamarine",
					"azure",
					"beige",
					"bisque",
					"blanchedalmond",
					"blueviolet",
					"brown",
					"burlywood",
					"cadetblue",
					"chartreuse",
					"chocolate",
					"coral",
					"cornflowerblue",
					"cornsilk",
					"crimson",
					"cyan",
					"darkblue",
					"darkcyan",
					"darkgoldenrod",
					"darkgray",
					"darkgreen",
					"darkgrey",
					"darkkhaki",
					"darkmagenta",
					"darkolivegreen",
					"darkorange",
					"darkorchid",
					"darkred",
					"darksalmon",
					"darkseagreen",
					"darkslateblue",
					"darkslategray",
					"darkslategrey",
					"darkturquoise",
					"darkviolet",
					"deeppink",
					"deepskyblue",
					"dimgray",
					"dimgrey",
					"dodgerblue",
					"firebrick",
					"floralwhite",
					"forestgreen",
					"gainsboro",
					"ghostwhite",
					"gold",
					"goldenrod",
					"greenyellow",
					"grey",
					"honeydew",
					"hotpink",
					"indianred",
					"indigo",
					"ivory",
					"khaki",
					"lavender",
					"lavenderblush",
					"lawngreen",
					"lemonchiffon",
					"lightblue",
					"lightcoral",
					"lightcyan",
					"lightgoldenrodyellow",
					"lightgray",
					"lightgreen",
					"lightgrey",
					"lightpink",
					"lightsalmon",
					"lightseagreen",
					"lightskyblue",
					"lightslategray",
					"lightslategrey",
					"lightsteelblue",
					"lightyellow",
					"limegreen",
					"linen",
					"magenta",
					"mediumaquamarine",
					"mediumblue",
					"mediumorchid",
					"mediumpurple",
					"mediumseagreen",
					"mediumslateblue",
					"mediumspringgreen",
					"mediumturquoise",
					"mediumvioletred",
					"midnightblue",
					"mintcream",
					"mistyrose",
					"moccasin",
					"navajowhite",
					"oldlace",
					"olivedrab",
					"orangered",
					"orchid",
					"palegoldenrod",
					"palegreen",
					"paleturquoise",
					"palevioletred",
					"papayawhip",
					"peachpuff",
					"peru",
					"pink",
					"plum",
					"powderblue",
					"rosybrown",
					"royalblue",
					"saddlebrown",
					"salmon",
					"sandybrown",
					"seagreen",
					"seashell",
					"sienna",
					"skyblue",
					"slateblue",
					"slategray",
					"slategrey",
					"snow",
					"springgreen",
					"steelblue",
					"tan",
					"thistle",
					"tomato",
					"turquoise",
					"violet",
					"wheat",
					"whitesmoke",
					"yellowgreen",
					"activeborder",
					"activecaption",
					"appworkspace",
					"background",
					"buttonface",
					"buttonhighlight",
					"buttonshadow",
					"buttontext",
					"captiontext",
					"graytext",
					"highlight",
					"highlighttext",
					"inactiveborder",
					"inactivecaption",
					"inactivecaptiontext",
					"infobackground",
					"infotext",
					"menu",
					"menutext",
					"scrollbar",
					"threeddarkshadow",
					"threedface",
					"threedhighlight",
					"threedlightshadow",
					"threedshadow",
					"window",
					"windowframe",
					"windowtext",
					"rebeccapurple",
					"currentcolor",
					"transparent",
				]);
				class Id {
					constructor(t, e, n) {
						(this.model = t),
							(this.writer = e),
							(this.position = n),
							(this.canMergeWith = new Set([this.position.parent])),
							(this.schema = t.schema),
							(this._documentFragment = e.createDocumentFragment()),
							(this._documentFragmentPosition = e.createPositionAt(
								this._documentFragment,
								0,
							)),
							(this._firstNode = null),
							(this._lastNode = null),
							(this._lastAutoParagraph = null),
							(this._filterAttributesOf = []),
							(this._affectedStart = null),
							(this._affectedEnd = null);
					}
					handleNodes(t) {
						for (const e of Array.from(t)) this._handleNode(e);
						this._insertPartialFragment(),
							this._lastAutoParagraph &&
								this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph),
							this._mergeOnRight(),
							this.schema.removeDisallowedAttributes(
								this._filterAttributesOf,
								this.writer,
							),
							(this._filterAttributesOf = []);
					}
					_updateLastNodeFromAutoParagraph(t) {
						const e = this.writer.createPositionAfter(this._lastNode),
							n = this.writer.createPositionAfter(t);
						if (n.isAfter(e)) {
							if (
								((this._lastNode = t),
								this.position.parent != t || !this.position.isAtEnd)
							)
								throw new l.a("insertcontent-invalid-insertion-position", this);
							(this.position = n), this._setAffectedBoundaries(this.position);
						}
					}
					getSelectionRange() {
						return this._nodeToSelect
							? qa._createOn(this._nodeToSelect)
							: this.model.schema.getNearestSelectionRange(this.position);
					}
					getAffectedRange() {
						return this._affectedStart
							? new qa(this._affectedStart, this._affectedEnd)
							: null;
					}
					destroy() {
						this._affectedStart && this._affectedStart.detach(),
							this._affectedEnd && this._affectedEnd.detach();
					}
					_handleNode(t) {
						if (this.schema.isObject(t)) return void this._handleObject(t);
						let e = this._checkAndAutoParagraphToAllowedPosition(t);
						e || ((e = this._checkAndSplitToAllowedPosition(t)), e)
							? (this._appendToFragment(t),
								this._firstNode || (this._firstNode = t),
								(this._lastNode = t))
							: this._handleDisallowedNode(t);
					}
					_insertPartialFragment() {
						if (this._documentFragment.isEmpty) return;
						const t = ed.fromPosition(this.position, "toNext");
						this._setAffectedBoundaries(this.position),
							this._documentFragment.getChild(0) == this._firstNode &&
								(this.writer.insert(this._firstNode, this.position),
								this._mergeOnLeft(),
								(this.position = t.toPosition())),
							this._documentFragment.isEmpty ||
								this.writer.insert(this._documentFragment, this.position),
							(this._documentFragmentPosition = this.writer.createPositionAt(
								this._documentFragment,
								0,
							)),
							(this.position = t.toPosition()),
							t.detach();
					}
					_handleObject(t) {
						this._checkAndSplitToAllowedPosition(t)
							? this._appendToFragment(t)
							: this._tryAutoparagraphing(t);
					}
					_handleDisallowedNode(t) {
						t.is("element")
							? this.handleNodes(t.getChildren())
							: this._tryAutoparagraphing(t);
					}
					_appendToFragment(t) {
						if (!this.schema.checkChild(this.position, t))
							throw new l.a("insertcontent-wrong-position", this, {
								node: t,
								position: this.position,
							});
						this.writer.insert(t, this._documentFragmentPosition),
							(this._documentFragmentPosition =
								this._documentFragmentPosition.getShiftedBy(t.offsetSize)),
							this.schema.isObject(t) &&
							!this.schema.checkChild(this.position, "$text")
								? (this._nodeToSelect = t)
								: (this._nodeToSelect = null),
							this._filterAttributesOf.push(t);
					}
					_setAffectedBoundaries(t) {
						this._affectedStart ||
							(this._affectedStart = ed.fromPosition(t, "toPrevious")),
							(this._affectedEnd && !this._affectedEnd.isBefore(t)) ||
								(this._affectedEnd && this._affectedEnd.detach(),
								(this._affectedEnd = ed.fromPosition(t, "toNext")));
					}
					_mergeOnLeft() {
						const t = this._firstNode;
						if (!(t instanceof Ra)) return;
						if (!this._canMergeLeft(t)) return;
						const e = ed._createBefore(t);
						e.stickiness = "toNext";
						const n = ed.fromPosition(this.position, "toNext");
						this._affectedStart.isEqual(e) &&
							(this._affectedStart.detach(),
							(this._affectedStart = ed._createAt(
								e.nodeBefore,
								"end",
								"toPrevious",
							))),
							this._firstNode === this._lastNode &&
								((this._firstNode = e.nodeBefore),
								(this._lastNode = e.nodeBefore)),
							this.writer.merge(e),
							e.isEqual(this._affectedEnd) &&
								this._firstNode === this._lastNode &&
								(this._affectedEnd.detach(),
								(this._affectedEnd = ed._createAt(
									e.nodeBefore,
									"end",
									"toNext",
								))),
							(this.position = n.toPosition()),
							n.detach(),
							this._filterAttributesOf.push(this.position.parent),
							e.detach();
					}
					_mergeOnRight() {
						const t = this._lastNode;
						if (!(t instanceof Ra)) return;
						if (!this._canMergeRight(t)) return;
						const e = ed._createAfter(t);
						if (((e.stickiness = "toNext"), !this.position.isEqual(e)))
							throw new l.a("insertcontent-invalid-insertion-position", this);
						this.position = Na._createAt(e.nodeBefore, "end");
						const n = ed.fromPosition(this.position, "toPrevious");
						this._affectedEnd.isEqual(e) &&
							(this._affectedEnd.detach(),
							(this._affectedEnd = ed._createAt(
								e.nodeBefore,
								"end",
								"toNext",
							))),
							this._firstNode === this._lastNode &&
								((this._firstNode = e.nodeBefore),
								(this._lastNode = e.nodeBefore)),
							this.writer.merge(e),
							e.getShiftedBy(-1).isEqual(this._affectedStart) &&
								this._firstNode === this._lastNode &&
								(this._affectedStart.detach(),
								(this._affectedStart = ed._createAt(
									e.nodeBefore,
									0,
									"toPrevious",
								))),
							(this.position = n.toPosition()),
							n.detach(),
							this._filterAttributesOf.push(this.position.parent),
							e.detach();
					}
					_canMergeLeft(t) {
						const e = t.previousSibling;
						return (
							e instanceof Ra &&
							this.canMergeWith.has(e) &&
							this.model.schema.checkMerge(e, t)
						);
					}
					_canMergeRight(t) {
						const e = t.nextSibling;
						return (
							e instanceof Ra &&
							this.canMergeWith.has(e) &&
							this.model.schema.checkMerge(t, e)
						);
					}
					_tryAutoparagraphing(t) {
						const e = this.writer.createElement("paragraph");
						this._getAllowedIn(this.position.parent, e) &&
							this.schema.checkChild(e, t) &&
							(e._appendChild(t), this._handleNode(e));
					}
					_checkAndAutoParagraphToAllowedPosition(t) {
						if (this.schema.checkChild(this.position.parent, t)) return !0;
						if (
							!this.schema.checkChild(this.position.parent, "paragraph") ||
							!this.schema.checkChild("paragraph", t)
						)
							return !1;
						this._insertPartialFragment();
						const e = this.writer.createElement("paragraph");
						return (
							this.writer.insert(e, this.position),
							this._setAffectedBoundaries(this.position),
							(this._lastAutoParagraph = e),
							(this.position = this.writer.createPositionAt(e, 0)),
							!0
						);
					}
					_checkAndSplitToAllowedPosition(t) {
						const e = this._getAllowedIn(this.position.parent, t);
						if (!e) return !1;
						for (
							e != this.position.parent && this._insertPartialFragment();
							e != this.position.parent;
						)
							if (this.position.isAtStart) {
								const t = this.position.parent;
								(this.position = this.writer.createPositionBefore(t)),
									t.isEmpty && t.parent === e && this.writer.remove(t);
							} else if (this.position.isAtEnd)
								this.position = this.writer.createPositionAfter(
									this.position.parent,
								);
							else {
								const t = this.writer.createPositionAfter(this.position.parent);
								this._setAffectedBoundaries(this.position),
									this.writer.split(this.position),
									(this.position = t),
									this.canMergeWith.add(this.position.nodeAfter);
							}
						return !0;
					}
					_getAllowedIn(t, e) {
						return this.schema.checkChild(t, e)
							? t
							: this.schema.isLimit(t)
								? null
								: this._getAllowedIn(t.parent, e);
					}
				}
				function zd(t, e, n = "auto") {
					const o = t.getSelectedElement();
					if (o && e.schema.isObject(o) && !e.schema.isInline(o))
						return "before" == n || "after" == n
							? e.createRange(e.createPositionAt(o, n))
							: e.createRangeOn(o);
					const i = ya(t.getSelectedBlocks());
					if (!i) return e.createRange(t.focus);
					if (i.isEmpty) return e.createRange(e.createPositionAt(i, 0));
					const r = e.createPositionAfter(i);
					return t.focus.isTouching(r)
						? e.createRange(r)
						: e.createRange(e.createPositionBefore(i));
				}
				function Rd(t, e, n, o, i = {}) {
					if (!t.schema.isObject(e))
						throw new l.a("insertobject-element-not-an-object", t, {
							object: e,
						});
					let r;
					r = n
						? n instanceof Qa || n instanceof sc
							? n
							: t.createSelection(n, o)
						: t.document.selection;
					let s = r;
					i.findOptimalPosition &&
						t.schema.isBlock(e) &&
						(s = t.createSelection(zd(r, t, i.findOptimalPosition)));
					const a = ya(r.getSelectedBlocks()),
						c = {};
					return (
						a &&
							Object.assign(
								c,
								t.schema.getAttributesWithProperty(a, "copyOnReplace", !0),
							),
						t.change((n) => {
							s.isCollapsed || t.deleteContent(s, { doNotAutoparagraph: !0 });
							let o = e;
							const r = s.anchor.parent;
							!t.schema.checkChild(r, e) &&
								t.schema.checkChild(r, "paragraph") &&
								t.schema.checkChild("paragraph", e) &&
								((o = n.createElement("paragraph")), n.insert(e, o)),
								t.schema.setAllowedAttributes(o, c, n);
							const a = t.insertContent(o, s);
							return (
								a.isCollapsed ||
									(i.setSelection &&
										(function (t, e, n, o) {
											const i = t.model;
											if ("after" == n) {
												let n = e.nextSibling;
												!(n && i.schema.checkChild(n, "$text")) &&
													i.schema.checkChild(e.parent, "paragraph") &&
													((n = t.createElement("paragraph")),
													i.schema.setAllowedAttributes(n, o, t),
													i.insertContent(n, t.createPositionAfter(e))),
													n && t.setSelection(n, 0);
											} else {
												if ("on" != n)
													throw new l.a(
														"insertobject-invalid-place-parameter-value",
														i,
													);
												t.setSelection(e, "on");
											}
										})(n, e, i.setSelection, c)),
								a
							);
						})
					);
				}
				function Od(t, e) {
					const {
							isForward: n,
							walker: o,
							unit: i,
							schema: r,
							treatEmojiAsSingleUnit: s,
						} = t,
						{ type: a, item: c, nextPosition: l } = e;
					if ("text" == a)
						return "word" === t.unit
							? (function (t, e) {
									let n = t.position.textNode;
									n || (n = e ? t.position.nodeAfter : t.position.nodeBefore);
									for (; n && n.is("$text"); ) {
										const o = t.position.offset - n.startOffset;
										if (Vd(n, o, e))
											n = e ? t.position.nodeAfter : t.position.nodeBefore;
										else {
											if (Nd(n.data, o, e)) break;
											t.next();
										}
									}
									return t.position;
								})(o, n)
							: (function (t, e, n) {
									const o = t.position.textNode;
									if (o) {
										const i = o.data;
										let r = t.position.offset - o.startOffset;
										for (
											;
											gl(i, r) ||
											("character" == e && fl(i, r)) ||
											(n && kl(i, r));
										)
											t.next(), (r = t.position.offset - o.startOffset);
									}
									return t.position;
								})(o, i, s);
					if (a == (n ? "elementStart" : "elementEnd")) {
						if (r.isSelectable(c))
							return Na._createAt(c, n ? "after" : "before");
						if (r.checkChild(l, "$text")) return l;
					} else {
						if (r.isLimit(c)) return void o.skip(() => !0);
						if (r.checkChild(l, "$text")) return l;
					}
				}
				function Md(t, e) {
					const n = t.root,
						o = Na._createAt(n, e ? "end" : 0);
					return e ? new qa(t, o) : new qa(o, t);
				}
				function Nd(t, e, n) {
					const o = e + (n ? 0 : -1);
					return ' ,.?!:;"-()'.includes(t.charAt(o));
				}
				function Vd(t, e, n) {
					return e === (n ? t.offsetSize : 0);
				}
				class Ld extends B {
					constructor() {
						super(),
							(this.markers = new _l()),
							(this.document = new wl(this)),
							(this.schema = new Vc()),
							(this._pendingChanges = []),
							(this._currentWriter = null),
							[
								"insertContent",
								"insertObject",
								"deleteContent",
								"modifySelection",
								"getSelectedContent",
								"applyOperation",
							].forEach((t) => this.decorate(t)),
							this.on(
								"applyOperation",
								(t, e) => {
									e[0]._validate();
								},
								{ priority: "highest" },
							),
							this.schema.register("$root", { isLimit: !0 }),
							this.schema.register("$container", {
								allowIn: ["$root", "$container"],
							}),
							this.schema.register("$block", {
								allowIn: ["$root", "$container"],
								isBlock: !0,
							}),
							this.schema.register("$blockObject", {
								allowWhere: "$block",
								isBlock: !0,
								isObject: !0,
							}),
							this.schema.register("$inlineObject", {
								allowWhere: "$text",
								allowAttributesOf: "$text",
								isInline: !0,
								isObject: !0,
							}),
							this.schema.register("$text", {
								allowIn: "$block",
								isInline: !0,
								isContent: !0,
							}),
							this.schema.register("$clipboardHolder", {
								allowContentOf: "$root",
								allowChildren: "$text",
								isLimit: !0,
							}),
							this.schema.register("$documentFragment", {
								allowContentOf: "$root",
								allowChildren: "$text",
								isLimit: !0,
							}),
							this.schema.register("$marker"),
							this.schema.addChildCheck((t, e) => {
								if ("$marker" === e.name) return !0;
							}),
							Ql(this),
							this.document.registerPostFixer(yc);
					}
					change(t) {
						try {
							return 0 === this._pendingChanges.length
								? (this._pendingChanges.push({ batch: new al(), callback: t }),
									this._runPendingChanges()[0])
								: t(this._currentWriter);
						} catch (t) {
							l.a.rethrowUnexpectedError(t, this);
						}
					}
					enqueueChange(t, e) {
						try {
							t
								? "function" == typeof t
									? ((e = t), (t = new al()))
									: t instanceof al || (t = new al(t))
								: (t = new al()),
								this._pendingChanges.push({ batch: t, callback: e }),
								1 == this._pendingChanges.length && this._runPendingChanges();
						} catch (t) {
							l.a.rethrowUnexpectedError(t, this);
						}
					}
					applyOperation(t) {
						t._execute();
					}
					insertContent(t, e, n) {
						return (function (t, e, n, o) {
							return t.change((i) => {
								let r;
								(r = n
									? n instanceof Qa || n instanceof sc
										? n
										: i.createSelection(n, o)
									: t.document.selection),
									r.isCollapsed ||
										t.deleteContent(r, { doNotAutoparagraph: !0 });
								const s = new Id(t, i, r.anchor),
									a = [];
								let c;
								if (e.is("documentFragment")) {
									if (e.markers.size) {
										const t = [];
										for (const [n, o] of e.markers) {
											const { start: e, end: i } = o,
												r = e.isEqual(i);
											t.push(
												{ position: e, name: n, isCollapsed: r },
												{ position: i, name: n, isCollapsed: r },
											);
										}
										t.sort(({ position: t }, { position: e }) =>
											t.isBefore(e) ? 1 : -1,
										);
										for (const { position: n, name: o, isCollapsed: r } of t) {
											let t = null,
												s = null;
											const c = n.parent === e && n.isAtStart,
												l = n.parent === e && n.isAtEnd;
											c || l
												? r && (s = c ? "start" : "end")
												: ((t = i.createElement("$marker")), i.insert(t, n)),
												a.push({ name: o, element: t, collapsed: s });
										}
									}
									c = e.getChildren();
								} else c = [e];
								s.handleNodes(c);
								let l = s.getSelectionRange();
								if (e.is("documentFragment") && a.length) {
									const t = l ? nc.fromRange(l) : null,
										e = {};
									for (let t = a.length - 1; t >= 0; t--) {
										const { name: n, element: o, collapsed: r } = a[t],
											c = !e[n];
										if ((c && (e[n] = []), o)) {
											const t = i.createPositionAt(o, "before");
											e[n].push(t), i.remove(o);
										} else {
											const t = s.getAffectedRange();
											if (!t) {
												r && e[n].push(s.position);
												continue;
											}
											r ? e[n].push(t[r]) : e[n].push(c ? t.start : t.end);
										}
									}
									for (const [t, [n, o]] of Object.entries(e))
										n &&
											o &&
											n.root === o.root &&
											i.addMarker(t, {
												usingOperation: !0,
												affectsData: !0,
												range: new qa(n, o),
											});
									t && ((l = t.toRange()), t.detach());
								}
								l && (r instanceof sc ? i.setSelection(l) : r.setTo(l));
								const d = s.getAffectedRange() || t.createRange(r.anchor);
								return s.destroy(), d;
							});
						})(this, t, e, n);
					}
					insertObject(t, e, n, o) {
						return Rd(this, t, e, n, o);
					}
					deleteContent(t, e) {
						id(this, t, e);
					}
					modifySelection(t, e) {
						!(function (t, e, n = {}) {
							const o = t.schema,
								i = "backward" != n.direction,
								r = n.unit ? n.unit : "character",
								s = !!n.treatEmojiAsSingleUnit,
								a = e.focus,
								c = new Oa({
									boundaries: Md(a, i),
									singleCharacters: !0,
									direction: i ? "forward" : "backward",
								}),
								l = {
									walker: c,
									schema: o,
									isForward: i,
									unit: r,
									treatEmojiAsSingleUnit: s,
								};
							let d;
							for (; (d = c.next()); ) {
								if (d.done) return;
								const n = Od(l, d.value);
								if (n)
									return void (e instanceof sc
										? t.change((t) => {
												t.setSelectionFocus(n);
											})
										: e.setFocus(n));
							}
						})(this, t, e);
					}
					getSelectedContent(t) {
						return (function (t, e) {
							return t.change((t) => {
								const n = t.createDocumentFragment(),
									o = e.getFirstRange();
								if (!o || o.isCollapsed) return n;
								const i = o.start.root,
									r = o.start.getCommonPath(o.end),
									s = i.getNodeByPath(r);
								let a;
								a =
									o.start.parent == o.end.parent
										? o
										: t.createRange(
												t.createPositionAt(s, o.start.path[r.length]),
												t.createPositionAt(s, o.end.path[r.length] + 1),
											);
								const c = a.end.offset - a.start.offset;
								for (const e of a.getItems({ shallow: !0 }))
									e.is("$textProxy")
										? t.appendText(e.data, e.getAttributes(), n)
										: t.append(t.cloneElement(e, !0), n);
								if (a != o) {
									const e = o._getTransformedByMove(
											a.start,
											t.createPositionAt(n, 0),
											c,
										)[0],
										i = t.createRange(t.createPositionAt(n, 0), e.start);
									dd(t.createRange(e.end, t.createPositionAt(n, "end")), t),
										dd(i, t);
								}
								return n;
							});
						})(this, t);
					}
					hasContent(t, e = {}) {
						const n = t instanceof qa ? t : qa._createIn(t);
						if (n.isCollapsed) return !1;
						const { ignoreWhitespaces: o = !1, ignoreMarkers: i = !1 } = e;
						if (!i)
							for (const t of this.markers.getMarkersIntersectingRange(n))
								if (t.affectsData) return !0;
						for (const t of n.getItems())
							if (this.schema.isContent(t)) {
								if (!t.is("$textProxy")) return !0;
								if (!o) return !0;
								if (-1 !== t.data.search(/\S/)) return !0;
							}
						return !1;
					}
					createPositionFromPath(t, e, n) {
						return new Na(t, e, n);
					}
					createPositionAt(t, e) {
						return Na._createAt(t, e);
					}
					createPositionAfter(t) {
						return Na._createAfter(t);
					}
					createPositionBefore(t) {
						return Na._createBefore(t);
					}
					createRange(t, e) {
						return new qa(t, e);
					}
					createRangeIn(t) {
						return qa._createIn(t);
					}
					createRangeOn(t) {
						return qa._createOn(t);
					}
					createSelection(...t) {
						return new Qa(...t);
					}
					createBatch(t) {
						return new al(t);
					}
					createOperationFromJSON(t) {
						return Hl.fromJSON(t, this.document);
					}
					destroy() {
						this.document.destroy(), this.stopListening();
					}
					_runPendingChanges() {
						const t = [];
						this.fire("_beforeChanges");
						try {
							for (; this._pendingChanges.length; ) {
								const e = this._pendingChanges[0].batch;
								this._currentWriter = new Ul(this, e);
								const n = this._pendingChanges[0].callback(this._currentWriter);
								t.push(n),
									this.document._handleChangeBlock(this._currentWriter),
									this._pendingChanges.shift(),
									(this._currentWriter = null);
							}
						} finally {
							(this._pendingChanges.length = 0),
								(this._currentWriter = null),
								this.fire("_afterChanges");
						}
						return t;
					}
				}
				class jd extends Da {
					constructor(t) {
						super(), (this.editor = t);
					}
					set(t, e, n = {}) {
						if ("string" == typeof e) {
							const t = e;
							e = (e, n) => {
								this.editor.execute(t), n();
							};
						}
						super.set(t, e, n);
					}
				}
				class Hd extends B {
					constructor(t = {}) {
						super();
						const e = this.constructor,
							n = t.language || (e.defaultConfig && e.defaultConfig.language);
						(this._context = t.context || new ao({ language: n })),
							this._context._addEditor(this, !t.context);
						const o = Array.from(e.builtinPlugins || []);
						(this.config = new Gn(t, e.defaultConfig)),
							this.config.define("plugins", o),
							this.config.define(this._context._getEditorConfig()),
							(this.plugins = new Zn(this, o, this._context.plugins)),
							(this.locale = this._context.locale),
							(this.t = this.locale.t),
							(this._readOnlyLocks = new Set()),
							(this.commands = new Rc()),
							this.set("state", "initializing"),
							this.once("ready", () => (this.state = "ready"), {
								priority: "high",
							}),
							this.once("destroy", () => (this.state = "destroyed"), {
								priority: "high",
							}),
							(this.model = new Ld());
						const i = new pi();
						(this.data = new ol(this.model, i)),
							(this.editing = new zc(this.model, i)),
							this.editing.view.document.bind("isReadOnly").to(this),
							(this.conversion = new il(
								[this.editing.downcastDispatcher, this.data.downcastDispatcher],
								this.data.upcastDispatcher,
							)),
							this.conversion.addAlias(
								"dataDowncast",
								this.data.downcastDispatcher,
							),
							this.conversion.addAlias(
								"editingDowncast",
								this.editing.downcastDispatcher,
							),
							(this.keystrokes = new jd(this)),
							this.keystrokes.listenTo(this.editing.view.document);
					}
					get isReadOnly() {
						return this._readOnlyLocks.size > 0;
					}
					set isReadOnly(t) {
						throw new l.a("editor-isreadonly-has-no-setter");
					}
					enableReadOnlyMode(t) {
						if ("string" != typeof t && "symbol" != typeof t)
							throw new l.a("editor-read-only-lock-id-invalid", null, {
								lockId: t,
							});
						this._readOnlyLocks.has(t) ||
							(this._readOnlyLocks.add(t),
							1 === this._readOnlyLocks.size &&
								this.fire("change:isReadOnly", "isReadOnly", !0, !1));
					}
					disableReadOnlyMode(t) {
						if ("string" != typeof t && "symbol" != typeof t)
							throw new l.a("editor-read-only-lock-id-invalid", null, {
								lockId: t,
							});
						this._readOnlyLocks.has(t) &&
							(this._readOnlyLocks.delete(t),
							0 === this._readOnlyLocks.size &&
								this.fire("change:isReadOnly", "isReadOnly", !1, !0));
					}
					initPlugins() {
						const t = this.config,
							e = t.get("plugins"),
							n = t.get("removePlugins") || [],
							o = t.get("extraPlugins") || [],
							i = t.get("substitutePlugins") || [];
						return this.plugins.init(e.concat(o), n, i);
					}
					destroy() {
						let t = Promise.resolve();
						return (
							"initializing" == this.state &&
								(t = new Promise((t) => this.once("ready", t))),
							t
								.then(() => {
									this.fire("destroy"),
										this.stopListening(),
										this.commands.destroy();
								})
								.then(() => this.plugins.destroy())
								.then(() => {
									this.model.destroy(),
										this.data.destroy(),
										this.editing.destroy(),
										this.keystrokes.destroy();
								})
								.then(() => this._context._removeEditor(this))
						);
					}
					execute(t, ...e) {
						try {
							return this.commands.execute(t, ...e);
						} catch (t) {
							l.a.rethrowUnexpectedError(t, this);
						}
					}
					focus() {
						this.editing.view.focus();
					}
				}
				class $d {
					constructor(t) {
						(this.editor = t), (this._components = new Map());
					}
					*names() {
						for (const t of this._components.values()) yield t.originalName;
					}
					add(t, e) {
						this._components.set(qd(t), { callback: e, originalName: t });
					}
					create(t) {
						if (!this.has(t))
							throw new l.a("componentfactory-item-missing", this, { name: t });
						return this._components.get(qd(t)).callback(this.editor.locale);
					}
					has(t) {
						return this._components.has(qd(t));
					}
				}
				function qd(t) {
					return String(t).toLowerCase();
				}
				class Ud extends Xn {
					constructor(t = []) {
						super(t, { idProperty: "viewUid" }),
							this.on("add", (t, e, n) => {
								this._renderViewIntoCollectionParent(e, n);
							}),
							this.on("remove", (t, e) => {
								e.element && this._parentElement && e.element.remove();
							}),
							(this._parentElement = null);
					}
					destroy() {
						this.map((t) => t.destroy());
					}
					setParent(t) {
						this._parentElement = t;
						for (const t of this) this._renderViewIntoCollectionParent(t);
					}
					delegate(...t) {
						if (!t.length || !t.every((t) => "string" == typeof t))
							throw new l.a("ui-viewcollection-delegate-wrong-events", this);
						return {
							to: (e) => {
								for (const n of this) for (const o of t) n.delegate(o).to(e);
								this.on("add", (n, o) => {
									for (const n of t) o.delegate(n).to(e);
								}),
									this.on("remove", (n, o) => {
										for (const n of t) o.stopDelegating(n, e);
									});
							},
						};
					}
					_renderViewIntoCollectionParent(t, e) {
						t.isRendered || t.render(),
							t.element &&
								this._parentElement &&
								this._parentElement.insertBefore(
									t.element,
									this._parentElement.children[e],
								);
					}
				}
				class Wd extends g {
					constructor(t) {
						super(),
							Object.assign(this, nu(eu(t))),
							(this._isRendered = !1),
							(this._revertData = null);
					}
					render() {
						const t = this._renderNode({ intoFragment: !0 });
						return (this._isRendered = !0), t;
					}
					apply(t) {
						return (
							(this._revertData = {
								children: [],
								bindings: [],
								attributes: {},
							}),
							this._renderNode({
								node: t,
								intoFragment: !1,
								isApplying: !0,
								revertData: this._revertData,
							}),
							t
						);
					}
					revert(t) {
						if (!this._revertData)
							throw new l.a("ui-template-revert-not-applied", [this, t]);
						this._revertTemplateFromNode(t, this._revertData);
					}
					*getViews() {
						yield* (function* t(e) {
							if (e.children)
								for (const n of e.children)
									cu(n) ? yield n : lu(n) && (yield* t(n));
						})(this);
					}
					static bind(t, e) {
						return {
							to: (n, o) =>
								new Gd({
									eventNameOrFunction: n,
									attribute: n,
									observable: t,
									emitter: e,
									callback: o,
								}),
							if: (n, o, i) =>
								new Jd({
									observable: t,
									emitter: e,
									attribute: n,
									valueIfTrue: o,
									callback: i,
								}),
						};
					}
					static extend(t, e) {
						if (t._isRendered)
							throw new l.a("template-extend-render", [this, t]);
						su(t, nu(eu(e)));
					}
					_renderNode(t) {
						let e;
						if (
							((e = t.node
								? this.tag && this.text
								: this.tag
									? this.text
									: !this.text),
							e)
						)
							throw new l.a("ui-template-wrong-syntax", this);
						return this.text ? this._renderText(t) : this._renderElement(t);
					}
					_renderElement(t) {
						let e = t.node;
						return (
							e ||
								(e = t.node =
									document.createElementNS(
										this.ns || "http://www.w3.org/1999/xhtml",
										this.tag,
									)),
							this._renderAttributes(t),
							this._renderElementChildren(t),
							this._setUpListeners(t),
							e
						);
					}
					_renderText(t) {
						let e = t.node;
						return (
							e
								? (t.revertData.text = e.textContent)
								: (e = t.node = document.createTextNode("")),
							Yd(this.text)
								? this._bindToObservable({
										schema: this.text,
										updater: Xd(e),
										data: t,
									})
								: (e.textContent = this.text.join("")),
							e
						);
					}
					_renderAttributes(t) {
						if (!this.attributes) return;
						const e = t.node,
							n = t.revertData;
						for (const o in this.attributes) {
							const i = e.getAttribute(o),
								r = this.attributes[o];
							n && (n.attributes[o] = i);
							const s = uu(r) ? r[0].ns : null;
							if (Yd(r)) {
								const a = uu(r) ? r[0].value : r;
								n && hu(o) && a.unshift(i),
									this._bindToObservable({
										schema: a,
										updater: Zd(e, o, s),
										data: t,
									});
							} else if ("style" == o && "string" != typeof r[0])
								this._renderStyleAttribute(r[0], t);
							else {
								n && i && hu(o) && r.unshift(i);
								const t = r
									.map((t) => (t && t.value) || t)
									.reduce((t, e) => t.concat(e), [])
									.reduce(iu, "");
								au(t) || e.setAttributeNS(s, o, t);
							}
						}
					}
					_renderStyleAttribute(t, e) {
						const n = e.node;
						for (const o in t) {
							const i = t[o];
							Yd(i)
								? this._bindToObservable({
										schema: [i],
										updater: tu(n, o),
										data: e,
									})
								: (n.style[o] = i);
						}
					}
					_renderElementChildren(t) {
						const e = t.node,
							n = t.intoFragment ? document.createDocumentFragment() : e,
							o = t.isApplying;
						let i = 0;
						for (const r of this.children)
							if (du(r)) {
								if (!o) {
									r.setParent(e);
									for (const t of r) n.appendChild(t.element);
								}
							} else if (cu(r))
								o || (r.isRendered || r.render(), n.appendChild(r.element));
							else if (zr(r)) n.appendChild(r);
							else if (o) {
								const e = { children: [], bindings: [], attributes: {} };
								t.revertData.children.push(e),
									r._renderNode({
										intoFragment: !1,
										node: n.childNodes[i++],
										isApplying: !0,
										revertData: e,
									});
							} else n.appendChild(r.render());
						t.intoFragment && e.appendChild(n);
					}
					_setUpListeners(t) {
						if (this.eventListeners)
							for (const e in this.eventListeners) {
								const n = this.eventListeners[e].map((n) => {
									const [o, i] = e.split("@");
									return n.activateDomEventListener(o, i, t);
								});
								t.revertData && t.revertData.bindings.push(n);
							}
					}
					_bindToObservable({ schema: t, updater: e, data: n }) {
						const o = n.revertData;
						Qd(t, e, n);
						const i = t
							.filter((t) => !au(t))
							.filter((t) => t.observable)
							.map((o) => o.activateAttributeListener(t, e, n));
						o && o.bindings.push(i);
					}
					_revertTemplateFromNode(t, e) {
						for (const t of e.bindings) for (const e of t) e();
						if (e.text) return void (t.textContent = e.text);
						const n = t;
						for (const t in e.attributes) {
							const o = e.attributes[t];
							null === o ? n.removeAttribute(t) : n.setAttribute(t, o);
						}
						for (let t = 0; t < e.children.length; ++t)
							this._revertTemplateFromNode(n.childNodes[t], e.children[t]);
					}
				}
				class Kd {
					constructor(t) {
						(this.attribute = t.attribute),
							(this.observable = t.observable),
							(this.emitter = t.emitter),
							(this.callback = t.callback);
					}
					getValue(t) {
						const e = this.observable[this.attribute];
						return this.callback ? this.callback(e, t) : e;
					}
					activateAttributeListener(t, e, n) {
						const o = () => Qd(t, e, n);
						return (
							this.emitter.listenTo(
								this.observable,
								`change:${this.attribute}`,
								o,
							),
							() => {
								this.emitter.stopListening(
									this.observable,
									`change:${this.attribute}`,
									o,
								);
							}
						);
					}
				}
				class Gd extends Kd {
					constructor(t) {
						super(t), (this.eventNameOrFunction = t.eventNameOrFunction);
					}
					activateDomEventListener(t, e, n) {
						const o = (t, n) => {
							(e && !n.target.matches(e)) ||
								("function" == typeof this.eventNameOrFunction
									? this.eventNameOrFunction(n)
									: this.observable.fire(this.eventNameOrFunction, n));
						};
						return (
							this.emitter.listenTo(n.node, t, o),
							() => {
								this.emitter.stopListening(n.node, t, o);
							}
						);
					}
				}
				class Jd extends Kd {
					constructor(t) {
						super(t), (this.valueIfTrue = t.valueIfTrue);
					}
					getValue(t) {
						return !au(super.getValue(t)) && (this.valueIfTrue || !0);
					}
				}
				function Yd(t) {
					return (
						!!t &&
						(t.value && (t = t.value),
						Array.isArray(t) ? t.some(Yd) : t instanceof Kd)
					);
				}
				function Qd(t, e, { node: n }) {
					const o = (function (t, e) {
						return t.map((t) => (t instanceof Kd ? t.getValue(e) : t));
					})(t, n);
					let i;
					(i = 1 == t.length && t[0] instanceof Jd ? o[0] : o.reduce(iu, "")),
						au(i) ? e.remove() : e.set(i);
				}
				function Xd(t) {
					return {
						set(e) {
							t.textContent = e;
						},
						remove() {
							t.textContent = "";
						},
					};
				}
				function Zd(t, e, n) {
					return {
						set(o) {
							t.setAttributeNS(n, e, o);
						},
						remove() {
							t.removeAttributeNS(n, e);
						},
					};
				}
				function tu(t, e) {
					return {
						set(n) {
							t.style[e] = n;
						},
						remove() {
							t.style[e] = null;
						},
					};
				}
				function eu(t) {
					return Wn(t, (t) => {
						if (t && (t instanceof Kd || lu(t) || cu(t) || du(t))) return t;
					});
				}
				function nu(t) {
					if (
						("string" == typeof t
							? (t = (function (t) {
									return { text: [t] };
								})(t))
							: t.text &&
								(function (t) {
									t.text = to(t.text);
								})(t),
						t.on &&
							((t.eventListeners = (function (t) {
								for (const e in t) ou(t, e);
								return t;
							})(t.on)),
							delete t.on),
						!t.text)
					) {
						t.attributes &&
							(function (t) {
								for (const e in t)
									t[e].value && (t[e].value = to(t[e].value)), ou(t, e);
							})(t.attributes);
						const e = [];
						if (t.children)
							if (du(t.children)) e.push(t.children);
							else
								for (const n of t.children)
									lu(n) || cu(n) || zr(n) ? e.push(n) : e.push(new Wd(n));
						t.children = e;
					}
					return t;
				}
				function ou(t, e) {
					t[e] = to(t[e]);
				}
				function iu(t, e) {
					return au(e) ? t : au(t) ? e : `${t} ${e}`;
				}
				function ru(t, e) {
					for (const n in e) t[n] ? t[n].push(...e[n]) : (t[n] = e[n]);
				}
				function su(t, e) {
					if (
						(e.attributes &&
							(t.attributes || (t.attributes = {}),
							ru(t.attributes, e.attributes)),
						e.eventListeners &&
							(t.eventListeners || (t.eventListeners = {}),
							ru(t.eventListeners, e.eventListeners)),
						e.text && t.text.push(...e.text),
						e.children && e.children.length)
					) {
						if (t.children.length != e.children.length)
							throw new l.a("ui-template-extend-children-mismatch", t);
						let n = 0;
						for (const o of e.children) su(t.children[n++], o);
					}
				}
				function au(t) {
					return !t && 0 !== t;
				}
				function cu(t) {
					return t instanceof fu;
				}
				function lu(t) {
					return t instanceof Wd;
				}
				function du(t) {
					return t instanceof Ud;
				}
				function uu(t) {
					return C(t[0]) && t[0].ns;
				}
				function hu(t) {
					return "class" == t || "style" == t;
				}
				var pu = n(17),
					gu = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(pu.a, gu), pu.a.locals;
				class fu extends os(B) {
					constructor(t) {
						super(),
							(this.element = null),
							(this.isRendered = !1),
							(this.locale = t),
							(this.t = t && t.t),
							(this._viewCollections = new Xn()),
							(this._unboundChildren = this.createCollection()),
							this._viewCollections.on("add", (e, n) => {
								(n.locale = t), (n.t = t && t.t);
							}),
							this.decorate("render");
					}
					get bindTemplate() {
						return this._bindTemplate
							? this._bindTemplate
							: (this._bindTemplate = Wd.bind(this, this));
					}
					createCollection(t) {
						const e = new Ud(t);
						return this._viewCollections.add(e), e;
					}
					registerChild(t) {
						Qn(t) || (t = [t]);
						for (const e of t) this._unboundChildren.add(e);
					}
					deregisterChild(t) {
						Qn(t) || (t = [t]);
						for (const e of t) this._unboundChildren.remove(e);
					}
					setTemplate(t) {
						this.template = new Wd(t);
					}
					extendTemplate(t) {
						Wd.extend(this.template, t);
					}
					render() {
						if (this.isRendered)
							throw new l.a("ui-view-render-already-rendered", this);
						this.template &&
							((this.element = this.template.render()),
							this.registerChild(this.template.getViews())),
							(this.isRendered = !0);
					}
					destroy() {
						this.stopListening(),
							this._viewCollections.map((t) => t.destroy()),
							this.template &&
								this.template._revertData &&
								this.template.revert(this.element);
					}
				}
				function mu({
					element: t,
					target: e,
					positions: n,
					limiter: o,
					fitInViewport: i,
					viewportOffsetConfig: r,
				}) {
					At(e) && (e = e()), At(o) && (o = o());
					const s = (function (t) {
							return t && t.parentNode
								? t.offsetParent === no.document.body
									? null
									: t.offsetParent
								: null;
						})(t),
						a = new aa(t),
						c = new aa(e);
					let l;
					const d =
							(i &&
								(function (t) {
									t = Object.assign(
										{ top: 0, bottom: 0, left: 0, right: 0 },
										t,
									);
									const e = new aa(no.window);
									return (
										(e.top += t.top),
										(e.height -= t.top),
										(e.bottom -= t.bottom),
										(e.height -= t.bottom),
										e
									);
								})(r)) ||
							null,
						u = {
							targetRect: c,
							elementRect: a,
							positionedElementAncestor: s,
							viewportRect: d,
						};
					if (o || i) {
						const t = o && new aa(o).getVisible();
						Object.assign(u, { limiterRect: t, viewportRect: d }),
							(l =
								(function (t, e) {
									const { elementRect: n } = e,
										o = n.getArea(),
										i = t.map((t) => new bu(t, e)).filter((t) => !!t.name);
									let r = 0,
										s = null;
									for (const t of i) {
										const {
											limiterIntersectionArea: e,
											viewportIntersectionArea: n,
										} = t;
										if (e === o) return t;
										const i = n ** 2 + e ** 2;
										i > r && ((r = i), (s = t));
									}
									return s;
								})(n, u) || new bu(n[0], u));
					} else l = new bu(n[0], u);
					return l;
				}
				function ku(t) {
					const { scrollX: e, scrollY: n } = no.window;
					return t.clone().moveBy(e, n);
				}
				class bu {
					constructor(t, e) {
						const n = t(e.targetRect, e.elementRect, e.viewportRect);
						if (!n) return;
						const { left: o, top: i, name: r, config: s } = n;
						(this.name = r),
							(this.config = s),
							(this._positioningFunctionCorrdinates = { left: o, top: i }),
							(this._options = e);
					}
					get left() {
						return this._absoluteRect.left;
					}
					get top() {
						return this._absoluteRect.top;
					}
					get limiterIntersectionArea() {
						const t = this._options.limiterRect;
						if (t) {
							const e = this._options.viewportRect;
							if (!e) return t.getIntersectionArea(this._rect);
							{
								const n = t.getIntersection(e);
								if (n) return n.getIntersectionArea(this._rect);
							}
						}
						return 0;
					}
					get viewportIntersectionArea() {
						const t = this._options.viewportRect;
						return t ? t.getIntersectionArea(this._rect) : 0;
					}
					get _rect() {
						return (
							this._cachedRect ||
								(this._cachedRect = this._options.elementRect
									.clone()
									.moveTo(
										this._positioningFunctionCorrdinates.left,
										this._positioningFunctionCorrdinates.top,
									)),
							this._cachedRect
						);
					}
					get _absoluteRect() {
						return (
							this._cachedAbsoluteRect ||
								((this._cachedAbsoluteRect = ku(this._rect)),
								this._options.positionedElementAncestor &&
									(function (t, e) {
										const n = ku(new aa(e)),
											o = ra(e);
										let i = 0,
											r = 0;
										(i -= n.left),
											(r -= n.top),
											(i += e.scrollLeft),
											(r += e.scrollTop),
											(i -= o.left),
											(r -= o.top),
											t.moveBy(i, r);
									})(
										this._cachedAbsoluteRect,
										this._options.positionedElementAncestor,
									)),
							this._cachedAbsoluteRect
						);
					}
				}
				var wu = n(18),
					Au = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(wu.a, Au), wu.a.locals;
				const _u = pa("px"),
					Cu = no.document.body;
				class vu extends fu {
					constructor(t) {
						super(t);
						const e = this.bindTemplate;
						this.set("top", 0),
							this.set("left", 0),
							this.set("position", "arrow_nw"),
							this.set("isVisible", !1),
							this.set("withArrow", !0),
							this.set("class", void 0),
							(this._pinWhenIsVisibleCallback = null),
							(this.content = this.createCollection()),
							this.setTemplate({
								tag: "div",
								attributes: {
									class: [
										"ck",
										"ck-balloon-panel",
										e.to("position", (t) => `ck-balloon-panel_${t}`),
										e.if("isVisible", "ck-balloon-panel_visible"),
										e.if("withArrow", "ck-balloon-panel_with-arrow"),
										e.to("class"),
									],
									style: { top: e.to("top", _u), left: e.to("left", _u) },
								},
								children: this.content,
							});
					}
					show() {
						this.isVisible = !0;
					}
					hide() {
						this.isVisible = !1;
					}
					attachTo(t) {
						this.show();
						const e = vu.defaultPositions,
							n = Object.assign(
								{},
								{
									element: this.element,
									positions: [
										e.southArrowNorth,
										e.southArrowNorthMiddleWest,
										e.southArrowNorthMiddleEast,
										e.southArrowNorthWest,
										e.southArrowNorthEast,
										e.northArrowSouth,
										e.northArrowSouthMiddleWest,
										e.northArrowSouthMiddleEast,
										e.northArrowSouthWest,
										e.northArrowSouthEast,
										e.viewportStickyNorth,
									],
									limiter: Cu,
									fitInViewport: !0,
								},
								t,
							),
							o = vu._getOptimalPosition(n),
							i = parseInt(o.left),
							r = parseInt(o.top),
							s = o.name,
							a = o.config || {},
							{ withArrow: c = !0 } = a;
						(this.top = r),
							(this.left = i),
							(this.position = s),
							(this.withArrow = c);
					}
					pin(t) {
						this.unpin(),
							(this._pinWhenIsVisibleCallback = () => {
								this.isVisible ? this._startPinning(t) : this._stopPinning();
							}),
							this._startPinning(t),
							this.listenTo(
								this,
								"change:isVisible",
								this._pinWhenIsVisibleCallback,
							);
					}
					unpin() {
						this._pinWhenIsVisibleCallback &&
							(this._stopPinning(),
							this.stopListening(
								this,
								"change:isVisible",
								this._pinWhenIsVisibleCallback,
							),
							(this._pinWhenIsVisibleCallback = null),
							this.hide());
					}
					_startPinning(t) {
						this.attachTo(t);
						const e = yu(t.target),
							n = t.limiter ? yu(t.limiter) : Cu;
						this.listenTo(
							no.document,
							"scroll",
							(o, i) => {
								const r = i.target,
									s = e && r.contains(e),
									a = n && r.contains(n);
								(!s && !a && e && n) || this.attachTo(t);
							},
							{ useCapture: !0 },
						),
							this.listenTo(no.window, "resize", () => {
								this.attachTo(t);
							});
					}
					_stopPinning() {
						this.stopListening(no.document, "scroll"),
							this.stopListening(no.window, "resize");
					}
				}
				function yu(t) {
					return Kn(t)
						? t
						: ia(t)
							? t.commonAncestorContainer
							: "function" == typeof t
								? yu(t())
								: null;
				}
				function xu(t = {}) {
					const {
						sideOffset: e = vu.arrowSideOffset,
						heightOffset: n = vu.arrowHeightOffset,
						stickyVerticalOffset: o = vu.stickyVerticalOffset,
						config: i,
					} = t;
					return {
						northWestArrowSouthWest: (t, n) => ({
							top: r(t, n),
							left: t.left - e,
							name: "arrow_sw",
							...(i && { config: i }),
						}),
						northWestArrowSouthMiddleWest: (t, n) => ({
							top: r(t, n),
							left: t.left - 0.25 * n.width - e,
							name: "arrow_smw",
							...(i && { config: i }),
						}),
						northWestArrowSouth: (t, e) => ({
							top: r(t, e),
							left: t.left - e.width / 2,
							name: "arrow_s",
							...(i && { config: i }),
						}),
						northWestArrowSouthMiddleEast: (t, n) => ({
							top: r(t, n),
							left: t.left - 0.75 * n.width + e,
							name: "arrow_sme",
							...(i && { config: i }),
						}),
						northWestArrowSouthEast: (t, n) => ({
							top: r(t, n),
							left: t.left - n.width + e,
							name: "arrow_se",
							...(i && { config: i }),
						}),
						northArrowSouthWest: (t, n) => ({
							top: r(t, n),
							left: t.left + t.width / 2 - e,
							name: "arrow_sw",
							...(i && { config: i }),
						}),
						northArrowSouthMiddleWest: (t, n) => ({
							top: r(t, n),
							left: t.left + t.width / 2 - 0.25 * n.width - e,
							name: "arrow_smw",
							...(i && { config: i }),
						}),
						northArrowSouth: (t, e) => ({
							top: r(t, e),
							left: t.left + t.width / 2 - e.width / 2,
							name: "arrow_s",
							...(i && { config: i }),
						}),
						northArrowSouthMiddleEast: (t, n) => ({
							top: r(t, n),
							left: t.left + t.width / 2 - 0.75 * n.width + e,
							name: "arrow_sme",
							...(i && { config: i }),
						}),
						northArrowSouthEast: (t, n) => ({
							top: r(t, n),
							left: t.left + t.width / 2 - n.width + e,
							name: "arrow_se",
							...(i && { config: i }),
						}),
						northEastArrowSouthWest: (t, n) => ({
							top: r(t, n),
							left: t.right - e,
							name: "arrow_sw",
							...(i && { config: i }),
						}),
						northEastArrowSouthMiddleWest: (t, n) => ({
							top: r(t, n),
							left: t.right - 0.25 * n.width - e,
							name: "arrow_smw",
							...(i && { config: i }),
						}),
						northEastArrowSouth: (t, e) => ({
							top: r(t, e),
							left: t.right - e.width / 2,
							name: "arrow_s",
							...(i && { config: i }),
						}),
						northEastArrowSouthMiddleEast: (t, n) => ({
							top: r(t, n),
							left: t.right - 0.75 * n.width + e,
							name: "arrow_sme",
							...(i && { config: i }),
						}),
						northEastArrowSouthEast: (t, n) => ({
							top: r(t, n),
							left: t.right - n.width + e,
							name: "arrow_se",
							...(i && { config: i }),
						}),
						southWestArrowNorthWest: (t) => ({
							top: s(t),
							left: t.left - e,
							name: "arrow_nw",
							...(i && { config: i }),
						}),
						southWestArrowNorthMiddleWest: (t, n) => ({
							top: s(t),
							left: t.left - 0.25 * n.width - e,
							name: "arrow_nmw",
							...(i && { config: i }),
						}),
						southWestArrowNorth: (t, e) => ({
							top: s(t),
							left: t.left - e.width / 2,
							name: "arrow_n",
							...(i && { config: i }),
						}),
						southWestArrowNorthMiddleEast: (t, n) => ({
							top: s(t),
							left: t.left - 0.75 * n.width + e,
							name: "arrow_nme",
							...(i && { config: i }),
						}),
						southWestArrowNorthEast: (t, n) => ({
							top: s(t),
							left: t.left - n.width + e,
							name: "arrow_ne",
							...(i && { config: i }),
						}),
						southArrowNorthWest: (t) => ({
							top: s(t),
							left: t.left + t.width / 2 - e,
							name: "arrow_nw",
							...(i && { config: i }),
						}),
						southArrowNorthMiddleWest: (t, n) => ({
							top: s(t),
							left: t.left + t.width / 2 - 0.25 * n.width - e,
							name: "arrow_nmw",
							...(i && { config: i }),
						}),
						southArrowNorth: (t, e) => ({
							top: s(t),
							left: t.left + t.width / 2 - e.width / 2,
							name: "arrow_n",
							...(i && { config: i }),
						}),
						southArrowNorthMiddleEast: (t, n) => ({
							top: s(t),
							left: t.left + t.width / 2 - 0.75 * n.width + e,
							name: "arrow_nme",
							...(i && { config: i }),
						}),
						southArrowNorthEast: (t, n) => ({
							top: s(t),
							left: t.left + t.width / 2 - n.width + e,
							name: "arrow_ne",
							...(i && { config: i }),
						}),
						southEastArrowNorthWest: (t) => ({
							top: s(t),
							left: t.right - e,
							name: "arrow_nw",
							...(i && { config: i }),
						}),
						southEastArrowNorthMiddleWest: (t, n) => ({
							top: s(t),
							left: t.right - 0.25 * n.width - e,
							name: "arrow_nmw",
							...(i && { config: i }),
						}),
						southEastArrowNorth: (t, e) => ({
							top: s(t),
							left: t.right - e.width / 2,
							name: "arrow_n",
							...(i && { config: i }),
						}),
						southEastArrowNorthMiddleEast: (t, n) => ({
							top: s(t),
							left: t.right - 0.75 * n.width + e,
							name: "arrow_nme",
							...(i && { config: i }),
						}),
						southEastArrowNorthEast: (t, n) => ({
							top: s(t),
							left: t.right - n.width + e,
							name: "arrow_ne",
							...(i && { config: i }),
						}),
						westArrowEast: (t, e) => ({
							top: t.top + t.height / 2 - e.height / 2,
							left: t.left - e.width - n,
							name: "arrow_e",
							...(i && { config: i }),
						}),
						eastArrowWest: (t, e) => ({
							top: t.top + t.height / 2 - e.height / 2,
							left: t.right + n,
							name: "arrow_w",
							...(i && { config: i }),
						}),
						viewportStickyNorth: (t, e, n) =>
							t.getIntersection(n)
								? {
										top: n.top + o,
										left: t.left + t.width / 2 - e.width / 2,
										name: "arrowless",
										config: { withArrow: !1, ...i },
									}
								: null,
					};
					function r(t, e) {
						return t.top - e.height - n;
					}
					function s(t) {
						return t.bottom + n;
					}
				}
				(vu.arrowSideOffset = 25),
					(vu.arrowHeightOffset = 10),
					(vu.stickyVerticalOffset = 20),
					(vu._getOptimalPosition = mu),
					(vu.defaultPositions = xu());
				var Du = n(19),
					Eu = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Du.a, Eu), Du.a.locals;
				const Su = "ck-tooltip";
				class Bu extends is {
					constructor(t) {
						if ((super(), Bu._editors.add(t), Bu._instance))
							return Bu._instance;
						(Bu._instance = this),
							(this.tooltipTextView = new fu(t.locale)),
							this.tooltipTextView.set("text", ""),
							this.tooltipTextView.setTemplate({
								tag: "span",
								attributes: { class: ["ck", "ck-tooltip__text"] },
								children: [
									{ text: this.tooltipTextView.bindTemplate.to("text") },
								],
							}),
							(this.balloonPanelView = new vu(t.locale)),
							(this.balloonPanelView.class = Su),
							this.balloonPanelView.content.add(this.tooltipTextView),
							(this._resizeObserver = null),
							(this._currentElementWithTooltip = null),
							(this._currentTooltipPosition = null),
							(this._pinTooltipDebounced = ys(this._pinTooltip, 600)),
							this.listenTo(
								no.document,
								"mouseenter",
								this._onEnterOrFocus.bind(this),
								{ useCapture: !0 },
							),
							this.listenTo(
								no.document,
								"mouseleave",
								this._onLeaveOrBlur.bind(this),
								{ useCapture: !0 },
							),
							this.listenTo(
								no.document,
								"focus",
								this._onEnterOrFocus.bind(this),
								{ useCapture: !0 },
							),
							this.listenTo(
								no.document,
								"blur",
								this._onLeaveOrBlur.bind(this),
								{ useCapture: !0 },
							),
							this.listenTo(no.document, "scroll", this._onScroll.bind(this), {
								useCapture: !0,
							}),
							(this._watchdogExcluded = !0);
					}
					destroy(t) {
						const e = t.ui.view && t.ui.view.body;
						Bu._editors.delete(t),
							this.stopListening(t.ui),
							e &&
								e.has(this.balloonPanelView) &&
								e.remove(this.balloonPanelView),
							Bu._editors.size ||
								(this._unpinTooltip(),
								this.balloonPanelView.destroy(),
								this.stopListening(),
								(Bu._instance = null));
					}
					static getPositioningFunctions(t) {
						const e = Bu.defaultBalloonPositions;
						return {
							s: [
								e.southArrowNorth,
								e.southArrowNorthEast,
								e.southArrowNorthWest,
							],
							n: [e.northArrowSouth],
							e: [e.eastArrowWest],
							w: [e.westArrowEast],
							sw: [e.southArrowNorthEast],
							se: [e.southArrowNorthWest],
						}[t];
					}
					_onEnterOrFocus(t, { target: e }) {
						const n = Tu(e);
						var o;
						n &&
							n !== this._currentElementWithTooltip &&
							(this._unpinTooltip(),
							this._pinTooltipDebounced(n, {
								text: (o = n).dataset.ckeTooltipText,
								position: o.dataset.ckeTooltipPosition || "s",
								cssClass: o.dataset.ckeTooltipClass || "",
							}));
					}
					_onLeaveOrBlur(t, { target: e, relatedTarget: n }) {
						if ("mouseleave" === t.name) {
							if (!Kn(e)) return;
							if (
								this._currentElementWithTooltip &&
								e !== this._currentElementWithTooltip
							)
								return;
							const t = Tu(e),
								o = Tu(n);
							t && t !== o && this._unpinTooltip();
						} else {
							if (
								this._currentElementWithTooltip &&
								e !== this._currentElementWithTooltip
							)
								return;
							this._unpinTooltip();
						}
					}
					_onScroll(t, { target: e }) {
						this._currentElementWithTooltip &&
							((e.contains(this.balloonPanelView.element) &&
								e.contains(this._currentElementWithTooltip)) ||
								this._unpinTooltip());
					}
					_pinTooltip(t, { text: e, position: n, cssClass: o }) {
						const i = ya(Bu._editors.values()).ui.view.body;
						i.has(this.balloonPanelView) || i.add(this.balloonPanelView),
							(this.tooltipTextView.text = e),
							this.balloonPanelView.pin({
								target: t,
								positions: Bu.getPositioningFunctions(n),
							}),
							(this._resizeObserver = new ua(t, () => {
								ga(t) || this._unpinTooltip();
							})),
							(this.balloonPanelView.class = [Su, o]
								.filter((t) => t)
								.join(" "));
						for (const t of Bu._editors)
							this.listenTo(
								t.ui,
								"update",
								this._updateTooltipPosition.bind(this),
								{ priority: "low" },
							);
						(this._currentElementWithTooltip = t),
							(this._currentTooltipPosition = n);
					}
					_unpinTooltip() {
						this._pinTooltipDebounced.cancel(), this.balloonPanelView.unpin();
						for (const t of Bu._editors) this.stopListening(t.ui, "update");
						(this._currentElementWithTooltip = null),
							(this._currentTooltipPosition = null),
							this._resizeObserver && this._resizeObserver.destroy();
					}
					_updateTooltipPosition() {
						ga(this._currentElementWithTooltip)
							? this.balloonPanelView.pin({
									target: this._currentElementWithTooltip,
									positions: Bu.getPositioningFunctions(
										this._currentTooltipPosition,
									),
								})
							: this._unpinTooltip();
					}
				}
				function Tu(t) {
					return Kn(t)
						? t.closest(
								"[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])",
							)
						: null;
				}
				(Bu.defaultBalloonPositions = xu({ heightOffset: 5, sideOffset: 13 })),
					(Bu._editors = new Set()),
					(Bu._instance = null);
				class Pu extends B {
					constructor(t) {
						super(),
							(this.editor = t),
							(this.componentFactory = new $d(t)),
							(this.focusTracker = new xa()),
							(this.tooltipManager = new Bu(t)),
							this.set("viewportOffset", this._readViewportOffsetFromConfig()),
							(this.isReady = !1),
							this.once("ready", () => {
								this.isReady = !0;
							}),
							(this._editableElementsMap = new Map()),
							(this._focusableToolbarDefinitions = []),
							this.listenTo(t.editing.view.document, "layoutChanged", () =>
								this.update(),
							),
							this._initFocusTracking();
					}
					get element() {
						return null;
					}
					update() {
						this.fire("update");
					}
					destroy() {
						this.stopListening(),
							this.focusTracker.destroy(),
							this.tooltipManager.destroy(this.editor);
						for (const t of this._editableElementsMap.values())
							t.ckeditorInstance = null;
						(this._editableElementsMap = new Map()),
							(this._focusableToolbarDefinitions = []);
					}
					setEditableElement(t, e) {
						this._editableElementsMap.set(t, e),
							e.ckeditorInstance || (e.ckeditorInstance = this.editor),
							this.focusTracker.add(e);
						const n = () => {
							this.editor.editing.view.getDomRoot(t) ||
								this.editor.keystrokes.listenTo(e);
						};
						this.isReady ? n() : this.once("ready", n);
					}
					getEditableElement(t = "main") {
						return this._editableElementsMap.get(t);
					}
					getEditableElementsNames() {
						return this._editableElementsMap.keys();
					}
					addToolbar(t, e = {}) {
						t.isRendered
							? (this.focusTracker.add(t.element),
								this.editor.keystrokes.listenTo(t.element))
							: t.once("render", () => {
									this.focusTracker.add(t.element),
										this.editor.keystrokes.listenTo(t.element);
								}),
							this._focusableToolbarDefinitions.push({
								toolbarView: t,
								options: e,
							});
					}
					get _editableElements() {
						return (
							console.warn(
								"editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.",
								{ editorUI: this },
							),
							this._editableElementsMap
						);
					}
					_readViewportOffsetFromConfig() {
						const t = this.editor,
							e = t.config.get("ui.viewportOffset");
						if (e) return e;
						const n = t.config.get("toolbar.viewportTopOffset");
						return n
							? (console.warn(
									"editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead.",
								),
								{ top: n })
							: { top: 0 };
					}
					_initFocusTracking() {
						const t = this.editor,
							e = t.editing.view;
						let n, o;
						t.keystrokes.set("Alt+F10", (t, i) => {
							const r = this.focusTracker.focusedElement;
							Array.from(this._editableElementsMap.values()).includes(r) &&
								!Array.from(e.domRoots.values()).includes(r) &&
								(n = r);
							const s = this._getCurrentFocusedToolbarDefinition();
							(s && o) || (o = this._getFocusableCandidateToolbarDefinitions());
							for (let t = 0; t < o.length; t++) {
								const t = o.shift();
								if (
									(o.push(t),
									t !== s && this._focusFocusableCandidateToolbar(t))
								) {
									s && s.options.afterBlur && s.options.afterBlur();
									break;
								}
							}
							i();
						}),
							t.keystrokes.set("Esc", (e, o) => {
								const i = this._getCurrentFocusedToolbarDefinition();
								i &&
									(n ? (n.focus(), (n = null)) : t.editing.view.focus(),
									i.options.afterBlur && i.options.afterBlur(),
									o());
							});
					}
					_getFocusableCandidateToolbarDefinitions() {
						const t = [];
						for (const e of this._focusableToolbarDefinitions) {
							const { toolbarView: n, options: o } = e;
							(ga(n.element) || o.beforeFocus) && t.push(e);
						}
						return t.sort((t, e) => Fu(t) - Fu(e)), t;
					}
					_getCurrentFocusedToolbarDefinition() {
						for (const t of this._focusableToolbarDefinitions)
							if (
								t.toolbarView.element &&
								t.toolbarView.element.contains(this.focusTracker.focusedElement)
							)
								return t;
						return null;
					}
					_focusFocusableCandidateToolbar(t) {
						const {
							toolbarView: e,
							options: { beforeFocus: n },
						} = t;
						return n && n(), !!ga(e.element) && (e.focus(), !0);
					}
				}
				function Fu(t) {
					const { toolbarView: e, options: n } = t;
					let o = 10;
					return ga(e.element) && o--, n.isContextual && o--, o;
				}
				function Iu(t) {
					return class extends t {
						setData(t) {
							this.data.set(t);
						}
						getData(t) {
							return this.data.get(t);
						}
					};
				}
				{
					const t = Iu(Object);
					(Iu.setData = t.prototype.setData),
						(Iu.getData = t.prototype.getData);
				}
				function zu(t) {
					return class extends t {
						updateSourceElement(t = this.data.get()) {
							if (!this.sourceElement)
								throw new l.a("editor-missing-sourceelement", this);
							const e = this.config.get("updateSourceElementOnDestroy"),
								n = this.sourceElement instanceof HTMLTextAreaElement;
							ha(this.sourceElement, e || n ? t : "");
						}
					};
				}
				zu.updateSourceElement = zu(Object).prototype.updateSourceElement;
				class Ru extends co {
					static get pluginName() {
						return "PendingActions";
					}
					init() {
						this.set("hasAny", !1),
							(this._actions = new Xn({ idProperty: "_id" })),
							this._actions.delegate("add", "remove").to(this);
					}
					add(t) {
						if ("string" != typeof t)
							throw new l.a("pendingactions-add-invalid-message", this);
						const e = new B();
						return (
							e.set("message", t), this._actions.add(e), (this.hasAny = !0), e
						);
					}
					remove(t) {
						this._actions.remove(t), (this.hasAny = !!this._actions.length);
					}
					get first() {
						return this._actions.get(0);
					}
					[Symbol.iterator]() {
						return this._actions[Symbol.iterator]();
					}
				}
				var Ou =
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>',
					Mu =
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>';
				const Nu = {
					bold: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>',
					cancel:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>',
					caption:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>',
					check:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>',
					cog: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>',
					eraser:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>',
					image:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>',
					lowVision:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>',
					importExport:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path clip-rule="evenodd" d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>',
					paragraph: Mu,
					plus: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>',
					text: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path clip-rule="evenodd" d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>',
					alignBottom:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>',
					alignMiddle:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>',
					alignTop:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>',
					alignLeft:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
					alignCenter:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>',
					alignRight:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>',
					alignJustify:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
					objectLeft:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
					objectCenter:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>',
					objectRight:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',
					objectFullWidth:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>',
					objectInline:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
					objectBlockLeft:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
					objectBlockRight:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',
					objectSizeFull:
						'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>',
					objectSizeLarge:
						'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>',
					objectSizeSmall:
						'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>',
					objectSizeMedium:
						'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>',
					pencil:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>',
					pilcrow: Ou,
					quote:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>',
					threeVerticalDots:
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>',
				};
				function Vu({
					emitter: t,
					activator: e,
					callback: n,
					contextElements: o,
				}) {
					t.listenTo(document, "mousedown", (t, i) => {
						if (!e()) return;
						const r =
							"function" == typeof i.composedPath ? i.composedPath() : [];
						for (const t of o)
							if (t.contains(i.target) || r.includes(t)) return;
						n();
					});
				}
				function Lu(t) {
					const e = t;
					e.set("_isCssTransitionsDisabled", !1),
						(e.disableCssTransitions = () => {
							e._isCssTransitionsDisabled = !0;
						}),
						(e.enableCssTransitions = () => {
							e._isCssTransitionsDisabled = !1;
						}),
						e.extendTemplate({
							attributes: {
								class: [
									e.bindTemplate.if(
										"_isCssTransitionsDisabled",
										"ck-transitions-disabled",
									),
								],
							},
						});
				}
				function ju({ view: t }) {
					t.listenTo(
						t.element,
						"submit",
						(e, n) => {
							n.preventDefault(), t.fire("submit");
						},
						{ useCapture: !0 },
					);
				}
				function Hu({
					keystrokeHandler: t,
					focusTracker: e,
					gridItems: n,
					numberOfColumns: o,
				}) {
					const i = "number" == typeof o ? () => o : o;
					function r(t) {
						return (o) => {
							const i = n.find((t) => t.element === e.focusedElement),
								r = n.getIndex(i),
								s = t(r, n);
							n.get(s).focus(), o.stopPropagation(), o.preventDefault();
						};
					}
					t.set(
						"arrowright",
						r((t, e) => (t === e.length - 1 ? 0 : t + 1)),
					),
						t.set(
							"arrowleft",
							r((t, e) => (0 === t ? e.length - 1 : t - 1)),
						),
						t.set(
							"arrowup",
							r((t, e) => {
								let n = t - i();
								return (
									n < 0 &&
										((n = t + i() * Math.floor(e.length / i())),
										n > e.length - 1 && (n -= i())),
									n
								);
							}),
						),
						t.set(
							"arrowdown",
							r((t, e) => {
								let n = t + i();
								return n > e.length - 1 && (n = t % i()), n;
							}),
						);
				}
				class $u extends Ud {
					constructor(t, e = []) {
						super(e), (this.locale = t);
					}
					attachToDom() {
						this._bodyCollectionContainer = new Wd({
							tag: "div",
							attributes: {
								class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"],
								dir: this.locale.uiLanguageDirection,
							},
							children: this,
						}).render();
						let t = document.querySelector(".ck-body-wrapper");
						t ||
							((t = oa(document, "div", { class: "ck-body-wrapper" })),
							document.body.appendChild(t)),
							t.appendChild(this._bodyCollectionContainer);
					}
					detachFromDom() {
						super.destroy(),
							this._bodyCollectionContainer &&
								this._bodyCollectionContainer.remove();
						const t = document.querySelector(".ck-body-wrapper");
						t && 0 == t.childElementCount && t.remove();
					}
				}
				var qu = n(20),
					Uu = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(qu.a, Uu), qu.a.locals;
				class Wu extends fu {
					constructor() {
						super();
						const t = this.bindTemplate;
						this.set("content", ""),
							this.set("viewBox", "0 0 20 20"),
							this.set("fillColor", ""),
							this.set("isColorInherited", !0),
							this.setTemplate({
								tag: "svg",
								ns: "http://www.w3.org/2000/svg",
								attributes: {
									class: [
										"ck",
										"ck-icon",
										"ck-reset_all-excluded",
										t.if("isColorInherited", "ck-icon_inherit-color"),
									],
									viewBox: t.to("viewBox"),
								},
							});
					}
					render() {
						super.render(),
							this._updateXMLContent(),
							this._colorFillPaths(),
							this.on("change:content", () => {
								this._updateXMLContent(), this._colorFillPaths();
							}),
							this.on("change:fillColor", () => {
								this._colorFillPaths();
							});
					}
					_updateXMLContent() {
						if (this.content) {
							const t = new DOMParser()
									.parseFromString(this.content.trim(), "image/svg+xml")
									.querySelector("svg"),
								e = t.getAttribute("viewBox");
							e && (this.viewBox = e);
							for (const { name: e, value: n } of Array.from(t.attributes))
								Wu.presentationalAttributeNames.includes(e) &&
									this.element.setAttribute(e, n);
							for (; this.element.firstChild; )
								this.element.removeChild(this.element.firstChild);
							for (; t.childNodes.length > 0; )
								this.element.appendChild(t.childNodes[0]);
						}
					}
					_colorFillPaths() {
						this.fillColor &&
							this.element.querySelectorAll(".ck-icon__fill").forEach((t) => {
								t.style.fill = this.fillColor;
							});
					}
				}
				Wu.presentationalAttributeNames = [
					"alignment-baseline",
					"baseline-shift",
					"clip-path",
					"clip-rule",
					"color",
					"color-interpolation",
					"color-interpolation-filters",
					"color-rendering",
					"cursor",
					"direction",
					"display",
					"dominant-baseline",
					"fill",
					"fill-opacity",
					"fill-rule",
					"filter",
					"flood-color",
					"flood-opacity",
					"font-family",
					"font-size",
					"font-size-adjust",
					"font-stretch",
					"font-style",
					"font-variant",
					"font-weight",
					"image-rendering",
					"letter-spacing",
					"lighting-color",
					"marker-end",
					"marker-mid",
					"marker-start",
					"mask",
					"opacity",
					"overflow",
					"paint-order",
					"pointer-events",
					"shape-rendering",
					"stop-color",
					"stop-opacity",
					"stroke",
					"stroke-dasharray",
					"stroke-dashoffset",
					"stroke-linecap",
					"stroke-linejoin",
					"stroke-miterlimit",
					"stroke-opacity",
					"stroke-width",
					"text-anchor",
					"text-decoration",
					"text-overflow",
					"text-rendering",
					"transform",
					"unicode-bidi",
					"vector-effect",
					"visibility",
					"white-space",
					"word-spacing",
					"writing-mode",
				];
				var Ku = n(21),
					Gu = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Ku.a, Gu), Ku.a.locals;
				class Ju extends fu {
					constructor(t) {
						super(t);
						const e = this.bindTemplate,
							n = s();
						this.set("class", void 0),
							this.set("labelStyle", void 0),
							this.set("icon", void 0),
							this.set("isEnabled", !0),
							this.set("isOn", !1),
							this.set("isVisible", !0),
							this.set("isToggleable", !1),
							this.set("keystroke", void 0),
							this.set("label", void 0),
							this.set("tabindex", -1),
							this.set("tooltip", !1),
							this.set("tooltipPosition", "s"),
							this.set("type", "button"),
							this.set("withText", !1),
							this.set("withKeystroke", !1),
							(this.children = this.createCollection()),
							(this.labelView = this._createLabelView(n)),
							(this.iconView = new Wu()),
							this.iconView.extendTemplate({
								attributes: { class: "ck-button__icon" },
							}),
							(this.keystrokeView = this._createKeystrokeView()),
							this.bind("_tooltipString").to(
								this,
								"tooltip",
								this,
								"label",
								this,
								"keystroke",
								this._getTooltipString.bind(this),
							);
						const o = {
							tag: "button",
							attributes: {
								class: [
									"ck",
									"ck-button",
									e.to("class"),
									e.if("isEnabled", "ck-disabled", (t) => !t),
									e.if("isVisible", "ck-hidden", (t) => !t),
									e.to("isOn", (t) => (t ? "ck-on" : "ck-off")),
									e.if("withText", "ck-button_with-text"),
									e.if("withKeystroke", "ck-button_with-keystroke"),
								],
								type: e.to("type", (t) => t || "button"),
								tabindex: e.to("tabindex"),
								"aria-labelledby": `ck-editor__aria-label_${n}`,
								"aria-disabled": e.if("isEnabled", !0, (t) => !t),
								"aria-pressed": e.to(
									"isOn",
									(t) => !!this.isToggleable && String(!!t),
								),
								"data-cke-tooltip-text": e.to("_tooltipString"),
								"data-cke-tooltip-position": e.to("tooltipPosition"),
							},
							children: this.children,
							on: {
								click: e.to((t) => {
									this.isEnabled ? this.fire("execute") : t.preventDefault();
								}),
							},
						};
						Ui.isSafari &&
							(o.on.mousedown = e.to((t) => {
								this.focus(), t.preventDefault();
							})),
							this.setTemplate(o);
					}
					render() {
						super.render(),
							this.icon &&
								(this.iconView.bind("content").to(this, "icon"),
								this.children.add(this.iconView)),
							this.children.add(this.labelView),
							this.withKeystroke &&
								this.keystroke &&
								this.children.add(this.keystrokeView);
					}
					focus() {
						this.element.focus();
					}
					_createLabelView(t) {
						const e = new fu(),
							n = this.bindTemplate;
						return (
							e.setTemplate({
								tag: "span",
								attributes: {
									class: ["ck", "ck-button__label"],
									style: n.to("labelStyle"),
									id: `ck-editor__aria-label_${t}`,
								},
								children: [{ text: this.bindTemplate.to("label") }],
							}),
							e
						);
					}
					_createKeystrokeView() {
						const t = new fu();
						return (
							t.setTemplate({
								tag: "span",
								attributes: { class: ["ck", "ck-button__keystroke"] },
								children: [
									{ text: this.bindTemplate.to("keystroke", (t) => Zi(t)) },
								],
							}),
							t
						);
					}
					_getTooltipString(t, e, n) {
						return t
							? "string" == typeof t
								? t
								: (n && (n = Zi(n)),
									t instanceof Function ? t(e, n) : `${e}${n ? ` (${n})` : ""}`)
							: "";
					}
				}
				var Yu = n(22),
					Qu = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Yu.a, Qu), Yu.a.locals;
				class Xu extends Ju {
					constructor(t) {
						super(t),
							(this.isToggleable = !0),
							(this.toggleSwitchView = this._createToggleView()),
							this.extendTemplate({ attributes: { class: "ck-switchbutton" } });
					}
					render() {
						super.render(), this.children.add(this.toggleSwitchView);
					}
					_createToggleView() {
						const t = new fu();
						return (
							t.setTemplate({
								tag: "span",
								attributes: { class: ["ck", "ck-button__toggle"] },
								children: [
									{
										tag: "span",
										attributes: { class: ["ck", "ck-button__toggle__inner"] },
									},
								],
							}),
							t
						);
					}
				}
				var Zu = n(23),
					th = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Zu.a, th), Zu.a.locals;
				var eh =
					'<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
				class nh extends Ju {
					constructor(t) {
						super(t),
							(this.arrowView = this._createArrowView()),
							this.extendTemplate({
								attributes: {
									"aria-haspopup": !0,
									"aria-expanded": this.bindTemplate.to("isOn", (t) =>
										String(t),
									),
								},
							}),
							this.delegate("execute").to(this, "open");
					}
					render() {
						super.render(), this.children.add(this.arrowView);
					}
					_createArrowView() {
						const t = new Wu();
						return (
							(t.content = eh),
							t.extendTemplate({ attributes: { class: "ck-dropdown__arrow" } }),
							t
						);
					}
				}
				var oh = n(24),
					ih = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(oh.a, ih), oh.a.locals;
				class rh extends fu {
					constructor(t) {
						super(t);
						const e = this.bindTemplate;
						this.set("class", void 0),
							this.set("labelStyle", void 0),
							this.set("icon", void 0),
							this.set("isEnabled", !0),
							this.set("isOn", !1),
							this.set("isToggleable", !1),
							this.set("isVisible", !0),
							this.set("keystroke", void 0),
							this.set("withKeystroke", !1),
							this.set("label", void 0),
							this.set("tabindex", -1),
							this.set("tooltip", !1),
							this.set("tooltipPosition", "s"),
							this.set("type", "button"),
							this.set("withText", !1),
							(this.children = this.createCollection()),
							(this.actionView = this._createActionView()),
							(this.arrowView = this._createArrowView()),
							(this.keystrokes = new Da()),
							(this.focusTracker = new xa()),
							this.setTemplate({
								tag: "div",
								attributes: {
									class: [
										"ck",
										"ck-splitbutton",
										e.to("class"),
										e.if("isVisible", "ck-hidden", (t) => !t),
										this.arrowView.bindTemplate.if(
											"isOn",
											"ck-splitbutton_open",
										),
									],
								},
								children: this.children,
							});
					}
					render() {
						super.render(),
							this.children.add(this.actionView),
							this.children.add(this.arrowView),
							this.focusTracker.add(this.actionView.element),
							this.focusTracker.add(this.arrowView.element),
							this.keystrokes.listenTo(this.element),
							this.keystrokes.set("arrowright", (t, e) => {
								this.focusTracker.focusedElement === this.actionView.element &&
									(this.arrowView.focus(), e());
							}),
							this.keystrokes.set("arrowleft", (t, e) => {
								this.focusTracker.focusedElement === this.arrowView.element &&
									(this.actionView.focus(), e());
							});
					}
					destroy() {
						super.destroy(),
							this.focusTracker.destroy(),
							this.keystrokes.destroy();
					}
					focus() {
						this.actionView.focus();
					}
					_createActionView() {
						const t = new Ju();
						return (
							t
								.bind(
									"icon",
									"isEnabled",
									"isOn",
									"isToggleable",
									"keystroke",
									"label",
									"tabindex",
									"tooltip",
									"tooltipPosition",
									"type",
									"withText",
								)
								.to(this),
							t.extendTemplate({
								attributes: { class: "ck-splitbutton__action" },
							}),
							t.delegate("execute").to(this),
							t
						);
					}
					_createArrowView() {
						const t = new Ju(),
							e = t.bindTemplate;
						return (
							(t.icon = eh),
							t.extendTemplate({
								attributes: {
									class: ["ck-splitbutton__arrow"],
									"data-cke-tooltip-disabled": e.to("isOn"),
									"aria-haspopup": !0,
									"aria-expanded": e.to("isOn", (t) => String(t)),
								},
							}),
							t.bind("isEnabled").to(this),
							t.bind("label").to(this),
							t.bind("tooltip").to(this),
							t.delegate("execute").to(this, "open"),
							t
						);
					}
				}
				class sh extends fu {
					constructor(t) {
						super(t);
						const e = this.bindTemplate;
						this.set("isVisible", !1),
							this.set("position", "se"),
							(this.children = this.createCollection()),
							this.setTemplate({
								tag: "div",
								attributes: {
									class: [
										"ck",
										"ck-reset",
										"ck-dropdown__panel",
										e.to("position", (t) => `ck-dropdown__panel_${t}`),
										e.if("isVisible", "ck-dropdown__panel-visible"),
									],
								},
								children: this.children,
								on: { selectstart: e.to((t) => t.preventDefault()) },
							});
					}
					focus() {
						if (this.children.length) {
							const t = this.children.first;
							"function" == typeof t.focus
								? t.focus()
								: Object(l.b)("ui-dropdown-panel-focus-child-missing-focus", {
										childView: this.children.first,
										dropdownPanel: this,
									});
						}
					}
					focusLast() {
						if (this.children.length) {
							const t = this.children.last;
							"function" == typeof t.focusLast ? t.focusLast() : t.focus();
						}
					}
				}
				var ah = n(25),
					ch = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(ah.a, ch), ah.a.locals;
				class lh extends fu {
					constructor(t, e, n) {
						super(t);
						const o = this.bindTemplate;
						(this.buttonView = e),
							(this.panelView = n),
							this.set("isOpen", !1),
							this.set("isEnabled", !0),
							this.set("class", void 0),
							this.set("id", void 0),
							this.set("panelPosition", "auto"),
							(this.keystrokes = new Da()),
							(this.focusTracker = new xa()),
							this.setTemplate({
								tag: "div",
								attributes: {
									class: [
										"ck",
										"ck-dropdown",
										o.to("class"),
										o.if("isEnabled", "ck-disabled", (t) => !t),
									],
									id: o.to("id"),
									"aria-describedby": o.to("ariaDescribedById"),
								},
								children: [e, n],
							}),
							e.extendTemplate({
								attributes: {
									class: ["ck-dropdown__button"],
									"data-cke-tooltip-disabled": o.to("isOpen"),
								},
							});
					}
					render() {
						super.render(),
							this.focusTracker.add(this.buttonView.element),
							this.focusTracker.add(this.panelView.element),
							this.listenTo(this.buttonView, "open", () => {
								this.isOpen = !this.isOpen;
							}),
							this.panelView.bind("isVisible").to(this, "isOpen"),
							this.on("change:isOpen", (t, e, n) => {
								n &&
									("auto" === this.panelPosition
										? (this.panelView.position = lh._getOptimalPosition({
												element: this.panelView.element,
												target: this.buttonView.element,
												fitInViewport: !0,
												positions: this._panelPositions,
											}).name)
										: (this.panelView.position = this.panelPosition));
							}),
							this.keystrokes.listenTo(this.element);
						const t = (t, e) => {
							this.isOpen && ((this.isOpen = !1), e());
						};
						this.keystrokes.set("arrowdown", (t, e) => {
							this.buttonView.isEnabled &&
								!this.isOpen &&
								((this.isOpen = !0), e());
						}),
							this.keystrokes.set("arrowright", (t, e) => {
								this.isOpen && e();
							}),
							this.keystrokes.set("arrowleft", t),
							this.keystrokes.set("esc", t);
					}
					focus() {
						this.buttonView.focus();
					}
					get _panelPositions() {
						const {
							south: t,
							north: e,
							southEast: n,
							southWest: o,
							northEast: i,
							northWest: r,
							southMiddleEast: s,
							southMiddleWest: a,
							northMiddleEast: c,
							northMiddleWest: l,
						} = lh.defaultPanelPositions;
						return "rtl" !== this.locale.uiLanguageDirection
							? [n, o, s, a, t, i, r, c, l, e]
							: [o, n, a, s, t, r, i, l, c, e];
					}
				}
				(lh.defaultPanelPositions = {
					south: (t, e) => ({
						top: t.bottom,
						left: t.left - (e.width - t.width) / 2,
						name: "s",
					}),
					southEast: (t) => ({ top: t.bottom, left: t.left, name: "se" }),
					southWest: (t, e) => ({
						top: t.bottom,
						left: t.left - e.width + t.width,
						name: "sw",
					}),
					southMiddleEast: (t, e) => ({
						top: t.bottom,
						left: t.left - (e.width - t.width) / 4,
						name: "sme",
					}),
					southMiddleWest: (t, e) => ({
						top: t.bottom,
						left: t.left - (3 * (e.width - t.width)) / 4,
						name: "smw",
					}),
					north: (t, e) => ({
						top: t.top - e.height,
						left: t.left - (e.width - t.width) / 2,
						name: "n",
					}),
					northEast: (t, e) => ({
						top: t.top - e.height,
						left: t.left,
						name: "ne",
					}),
					northWest: (t, e) => ({
						top: t.top - e.height,
						left: t.left - e.width + t.width,
						name: "nw",
					}),
					northMiddleEast: (t, e) => ({
						top: t.top - e.height,
						left: t.left - (e.width - t.width) / 4,
						name: "nme",
					}),
					northMiddleWest: (t, e) => ({
						top: t.top - e.height,
						left: t.left - (3 * (e.width - t.width)) / 4,
						name: "nmw",
					}),
				}),
					(lh._getOptimalPosition = mu);
				class dh {
					constructor(t) {
						if (
							((this.focusables = t.focusables),
							(this.focusTracker = t.focusTracker),
							(this.keystrokeHandler = t.keystrokeHandler),
							(this.actions = t.actions),
							t.actions && t.keystrokeHandler)
						)
							for (const e in t.actions) {
								let n = t.actions[e];
								"string" == typeof n && (n = [n]);
								for (const o of n)
									t.keystrokeHandler.set(o, (t, n) => {
										this[e](), n();
									});
							}
					}
					get first() {
						return this.focusables.find(uh) || null;
					}
					get last() {
						return this.focusables.filter(uh).slice(-1)[0] || null;
					}
					get next() {
						return this._getFocusableItem(1);
					}
					get previous() {
						return this._getFocusableItem(-1);
					}
					get current() {
						let t = null;
						return null === this.focusTracker.focusedElement
							? null
							: (this.focusables.find((e, n) => {
									const o = e.element === this.focusTracker.focusedElement;
									return o && (t = n), o;
								}),
								t);
					}
					focusFirst() {
						this._focus(this.first);
					}
					focusLast() {
						this._focus(this.last);
					}
					focusNext() {
						this._focus(this.next);
					}
					focusPrevious() {
						this._focus(this.previous);
					}
					_focus(t) {
						t && t.focus();
					}
					_getFocusableItem(t) {
						const e = this.current,
							n = this.focusables.length;
						if (!n) return null;
						if (null === e) return this[1 === t ? "first" : "last"];
						let o = (e + n + t) % n;
						do {
							const e = this.focusables.get(o);
							if (uh(e)) return e;
							o = (o + n + t) % n;
						} while (o !== e);
						return null;
					}
				}
				function uh(t) {
					return !(!t.focus || !ga(t.element));
				}
				class hh extends fu {
					constructor(t) {
						super(t),
							this.setTemplate({
								tag: "span",
								attributes: { class: ["ck", "ck-toolbar__separator"] },
							});
					}
				}
				class ph extends fu {
					constructor(t) {
						super(t),
							this.setTemplate({
								tag: "span",
								attributes: { class: ["ck", "ck-toolbar__line-break"] },
							});
					}
				}
				function gh(t) {
					return Array.isArray(t)
						? { items: t, removeItems: [] }
						: t
							? Object.assign({ items: [], removeItems: [] }, t)
							: { items: [], removeItems: [] };
				}
				var fh = n(26),
					mh = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(fh.a, mh), fh.a.locals;
				const { threeVerticalDots: kh } = Nu,
					bh = {
						alignLeft: Nu.alignLeft,
						bold: Nu.bold,
						importExport: Nu.importExport,
						paragraph: Nu.paragraph,
						plus: Nu.plus,
						text: Nu.text,
						threeVerticalDots: Nu.threeVerticalDots,
					};
				class wh extends fu {
					constructor(t, e) {
						super(t);
						const n = this.bindTemplate,
							o = this.t;
						(this.options = e || {}),
							this.set("ariaLabel", o("Editor toolbar")),
							this.set("maxWidth", "auto"),
							(this.items = this.createCollection()),
							(this.focusTracker = new xa()),
							(this.keystrokes = new Da()),
							this.set("class", void 0),
							this.set("isCompact", !1),
							(this.itemsView = new Ah(t)),
							(this.children = this.createCollection()),
							this.children.add(this.itemsView),
							(this.focusables = this.createCollection());
						const i = "rtl" === t.uiLanguageDirection;
						this._focusCycler = new dh({
							focusables: this.focusables,
							focusTracker: this.focusTracker,
							keystrokeHandler: this.keystrokes,
							actions: {
								focusPrevious: [i ? "arrowright" : "arrowleft", "arrowup"],
								focusNext: [i ? "arrowleft" : "arrowright", "arrowdown"],
							},
						});
						const r = [
							"ck",
							"ck-toolbar",
							n.to("class"),
							n.if("isCompact", "ck-toolbar_compact"),
						];
						var s;
						this.options.shouldGroupWhenFull &&
							this.options.isFloating &&
							r.push("ck-toolbar_floating"),
							this.setTemplate({
								tag: "div",
								attributes: {
									class: r,
									role: "toolbar",
									"aria-label": n.to("ariaLabel"),
									style: { maxWidth: n.to("maxWidth") },
								},
								children: this.children,
								on: {
									mousedown:
										((s = this),
										s.bindTemplate.to((t) => {
											t.target === s.element && t.preventDefault();
										})),
								},
							}),
							(this._behavior = this.options.shouldGroupWhenFull
								? new Ch(this)
								: new _h(this));
					}
					render() {
						super.render();
						for (const t of this.items) this.focusTracker.add(t.element);
						this.items.on("add", (t, e) => {
							this.focusTracker.add(e.element);
						}),
							this.items.on("remove", (t, e) => {
								this.focusTracker.remove(e.element);
							}),
							this.keystrokes.listenTo(this.element),
							this._behavior.render(this);
					}
					destroy() {
						return (
							this._behavior.destroy(),
							this.focusTracker.destroy(),
							this.keystrokes.destroy(),
							super.destroy()
						);
					}
					focus() {
						this._focusCycler.focusFirst();
					}
					focusLast() {
						this._focusCycler.focusLast();
					}
					fillFromConfig(t, e, n) {
						const o = gh(t),
							i = n || o.removeItems,
							r = this._cleanItemsConfiguration(o.items, e, i)
								.map((t) =>
									C(t)
										? this._createNestedToolbarDropdown(t, e, i)
										: "|" === t
											? new hh()
											: "-" === t
												? new ph()
												: e.create(t),
								)
								.filter((t) => !!t);
						this.items.addMany(r);
					}
					_cleanItemsConfiguration(t, e, n) {
						const o = t.filter(
							(t, o, i) =>
								"|" === t ||
								(-1 === n.indexOf(t) &&
									("-" === t
										? !this.options.shouldGroupWhenFull ||
											(Object(l.b)(
												"toolbarview-line-break-ignored-when-grouping-items",
												i,
											),
											!1)
										: !(!C(t) && !e.has(t)) ||
											(Object(l.b)("toolbarview-item-unavailable", { item: t }),
											!1))),
						);
						return this._cleanSeparatorsAndLineBreaks(o);
					}
					_cleanSeparatorsAndLineBreaks(t) {
						const e = (t) => "-" !== t && "|" !== t,
							n = t.length,
							o = t.findIndex(e);
						if (-1 === o) return [];
						const i = n - t.slice().reverse().findIndex(e);
						return t.slice(o, i).filter((t, n, o) => {
							if (e(t)) return !0;
							return !(n > 0 && o[n - 1] === t);
						});
					}
					_createNestedToolbarDropdown(t, e, n) {
						let {
							label: o,
							icon: i,
							items: r,
							tooltip: s = !0,
							withText: a = !1,
						} = t;
						if (((r = this._cleanItemsConfiguration(r, e, n)), !r.length))
							return null;
						const c = Fh(this.locale);
						return (
							o ||
								Object(l.b)(
									"toolbarview-nested-toolbar-dropdown-missing-label",
									t,
								),
							(c.class = "ck-toolbar__nested-toolbar-dropdown"),
							c.buttonView.set({ label: o, tooltip: s, withText: !!a }),
							!1 !== i
								? (c.buttonView.icon = bh[i] || i || kh)
								: (c.buttonView.withText = !0),
							Ih(c, []),
							c.toolbarView.fillFromConfig(r, e, n),
							c
						);
					}
				}
				class Ah extends fu {
					constructor(t) {
						super(t),
							(this.children = this.createCollection()),
							this.setTemplate({
								tag: "div",
								attributes: { class: ["ck", "ck-toolbar__items"] },
								children: this.children,
							});
					}
				}
				class _h {
					constructor(t) {
						const e = t.bindTemplate;
						t.set("isVertical", !1),
							t.itemsView.children.bindTo(t.items).using((t) => t),
							t.focusables.bindTo(t.items).using((t) => t),
							t.extendTemplate({
								attributes: {
									class: [e.if("isVertical", "ck-toolbar_vertical")],
								},
							});
					}
					render() {}
					destroy() {}
				}
				class Ch {
					constructor(t) {
						(this.view = t),
							(this.viewChildren = t.children),
							(this.viewFocusables = t.focusables),
							(this.viewItemsView = t.itemsView),
							(this.viewFocusTracker = t.focusTracker),
							(this.viewLocale = t.locale),
							(this.ungroupedItems = t.createCollection()),
							(this.groupedItems = t.createCollection()),
							(this.groupedItemsDropdown = this._createGroupedItemsDropdown()),
							(this.resizeObserver = null),
							(this.cachedPadding = null),
							(this.shouldUpdateGroupingOnNextResize = !1),
							t.itemsView.children.bindTo(this.ungroupedItems).using((t) => t),
							this.ungroupedItems.on(
								"add",
								this._updateFocusCycleableItems.bind(this),
							),
							this.ungroupedItems.on(
								"remove",
								this._updateFocusCycleableItems.bind(this),
							),
							t.children.on("add", this._updateFocusCycleableItems.bind(this)),
							t.children.on(
								"remove",
								this._updateFocusCycleableItems.bind(this),
							),
							t.items.on("change", (t, e) => {
								const n = e.index,
									o = Array.from(e.added);
								for (const t of e.removed)
									n >= this.ungroupedItems.length
										? this.groupedItems.remove(t)
										: this.ungroupedItems.remove(t);
								for (let t = n; t < n + o.length; t++) {
									const e = o[t - n];
									t > this.ungroupedItems.length
										? this.groupedItems.add(e, t - this.ungroupedItems.length)
										: this.ungroupedItems.add(e, t);
								}
								this._updateGrouping();
							}),
							t.extendTemplate({
								attributes: { class: ["ck-toolbar_grouping"] },
							});
					}
					render(t) {
						(this.viewElement = t.element),
							this._enableGroupingOnResize(),
							this._enableGroupingOnMaxWidthChange(t);
					}
					destroy() {
						this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy();
					}
					_updateGrouping() {
						if (!this.viewElement.ownerDocument.body.contains(this.viewElement))
							return;
						if (!ga(this.viewElement))
							return void (this.shouldUpdateGroupingOnNextResize = !0);
						const t = this.groupedItems.length;
						let e;
						for (; this._areItemsOverflowing; ) this._groupLastItem(), (e = !0);
						if (!e && this.groupedItems.length) {
							for (; this.groupedItems.length && !this._areItemsOverflowing; )
								this._ungroupFirstItem();
							this._areItemsOverflowing && this._groupLastItem();
						}
						this.groupedItems.length !== t &&
							this.view.fire("groupedItemsUpdate");
					}
					get _areItemsOverflowing() {
						if (!this.ungroupedItems.length) return !1;
						const t = this.viewElement,
							e = this.viewLocale.uiLanguageDirection,
							n = new aa(t.lastChild),
							o = new aa(t);
						if (!this.cachedPadding) {
							const n = no.window.getComputedStyle(t),
								o = "ltr" === e ? "paddingRight" : "paddingLeft";
							this.cachedPadding = Number.parseInt(n[o]);
						}
						return "ltr" === e
							? n.right > o.right - this.cachedPadding
							: n.left < o.left + this.cachedPadding;
					}
					_enableGroupingOnResize() {
						let t;
						(this.resizeObserver = new ua(this.viewElement, (e) => {
							(t &&
								t === e.contentRect.width &&
								!this.shouldUpdateGroupingOnNextResize) ||
								((this.shouldUpdateGroupingOnNextResize = !1),
								this._updateGrouping(),
								(t = e.contentRect.width));
						})),
							this._updateGrouping();
					}
					_enableGroupingOnMaxWidthChange(t) {
						t.on("change:maxWidth", () => {
							this._updateGrouping();
						});
					}
					_groupLastItem() {
						this.groupedItems.length ||
							(this.viewChildren.add(new hh()),
							this.viewChildren.add(this.groupedItemsDropdown),
							this.viewFocusTracker.add(this.groupedItemsDropdown.element)),
							this.groupedItems.add(
								this.ungroupedItems.remove(this.ungroupedItems.last),
								0,
							);
					}
					_ungroupFirstItem() {
						this.ungroupedItems.add(
							this.groupedItems.remove(this.groupedItems.first),
						),
							this.groupedItems.length ||
								(this.viewChildren.remove(this.groupedItemsDropdown),
								this.viewChildren.remove(this.viewChildren.last),
								this.viewFocusTracker.remove(
									this.groupedItemsDropdown.element,
								));
					}
					_createGroupedItemsDropdown() {
						const t = this.viewLocale,
							e = t.t,
							n = Fh(t);
						return (
							(n.class = "ck-toolbar__grouped-dropdown"),
							(n.panelPosition = "ltr" === t.uiLanguageDirection ? "sw" : "se"),
							Ih(n, []),
							n.buttonView.set({
								label: e("Show more items"),
								tooltip: !0,
								tooltipPosition: "rtl" === t.uiLanguageDirection ? "se" : "sw",
								icon: kh,
							}),
							n.toolbarView.items.bindTo(this.groupedItems).using((t) => t),
							n
						);
					}
					_updateFocusCycleableItems() {
						this.viewFocusables.clear(),
							this.ungroupedItems.map((t) => {
								this.viewFocusables.add(t);
							}),
							this.groupedItems.length &&
								this.viewFocusables.add(this.groupedItemsDropdown);
					}
				}
				var vh = n(27),
					yh = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(vh.a, yh), vh.a.locals;
				class xh extends fu {
					constructor(t) {
						super(t),
							(this.items = this.createCollection()),
							(this.focusTracker = new xa()),
							(this.keystrokes = new Da()),
							(this._focusCycler = new dh({
								focusables: this.items,
								focusTracker: this.focusTracker,
								keystrokeHandler: this.keystrokes,
								actions: { focusPrevious: "arrowup", focusNext: "arrowdown" },
							})),
							this.setTemplate({
								tag: "ul",
								attributes: { class: ["ck", "ck-reset", "ck-list"] },
								children: this.items,
							});
					}
					render() {
						super.render();
						for (const t of this.items) this.focusTracker.add(t.element);
						this.items.on("add", (t, e) => {
							this.focusTracker.add(e.element);
						}),
							this.items.on("remove", (t, e) => {
								this.focusTracker.remove(e.element);
							}),
							this.keystrokes.listenTo(this.element);
					}
					destroy() {
						super.destroy(),
							this.focusTracker.destroy(),
							this.keystrokes.destroy();
					}
					focus() {
						this._focusCycler.focusFirst();
					}
					focusLast() {
						this._focusCycler.focusLast();
					}
				}
				class Dh extends fu {
					constructor(t) {
						super(t);
						const e = this.bindTemplate;
						this.set("isVisible", !0),
							(this.children = this.createCollection()),
							this.setTemplate({
								tag: "li",
								attributes: {
									class: [
										"ck",
										"ck-list__item",
										e.if("isVisible", "ck-hidden", (t) => !t),
									],
								},
								children: this.children,
							});
					}
					focus() {
						this.children.first.focus();
					}
				}
				class Eh extends fu {
					constructor(t) {
						super(t),
							this.setTemplate({
								tag: "li",
								attributes: { class: ["ck", "ck-list__separator"] },
							});
					}
				}
				var Sh = n(28),
					Bh = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					},
					Th = (Or()(Sh.a, Bh), Sh.a.locals, n(29)),
					Ph = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Th.a, Ph), Th.a.locals;
				function Fh(t, e = nh) {
					const n = new e(t),
						o = new sh(t),
						i = new lh(t, n, o);
					return (
						n.bind("isEnabled").to(i),
						n instanceof rh
							? n.arrowView.bind("isOn").to(i, "isOpen")
							: n.bind("isOn").to(i, "isOpen"),
						(function (t) {
							(function (t) {
								t.on("render", () => {
									Vu({
										emitter: t,
										activator: () => t.isOpen,
										callback: () => {
											t.isOpen = !1;
										},
										contextElements: [t.element],
									});
								});
							})(t),
								(function (t) {
									t.on("execute", (e) => {
										e.source instanceof Xu || (t.isOpen = !1);
									});
								})(t),
								(function (t) {
									t.focusTracker.on("change:isFocused", (e, n, o) => {
										t.isOpen && !o && (t.isOpen = !1);
									});
								})(t),
								(function (t) {
									t.keystrokes.set("arrowdown", (e, n) => {
										t.isOpen && (t.panelView.focus(), n());
									}),
										t.keystrokes.set("arrowup", (e, n) => {
											t.isOpen && (t.panelView.focusLast(), n());
										});
								})(t),
								(function (t) {
									t.on("change:isOpen", (e, n, o) => {
										o ||
											(t.panelView.element.contains(
												no.document.activeElement,
											) &&
												t.buttonView.focus());
									});
								})(t),
								(function (t) {
									t.on(
										"change:isOpen",
										(e, n, o) => {
											o && t.panelView.focus();
										},
										{ priority: "low" },
									);
								})(t);
						})(i),
						i
					);
				}
				function Ih(t, e, n = {}) {
					const o = t.locale,
						i = o.t,
						r = (t.toolbarView = new wh(o));
					r.set("ariaLabel", i("Dropdown toolbar")),
						t.extendTemplate({
							attributes: { class: ["ck-toolbar-dropdown"] },
						}),
						e.map((t) => r.items.add(t)),
						n.enableActiveItemFocusOnDropdownOpen &&
							Rh(t, () => r.items.find((t) => t.isOn)),
						t.panelView.children.add(r),
						r.items.delegate("execute").to(t);
				}
				function zh(t, e) {
					const n = t.locale,
						o = (t.listView = new xh(n));
					o.items.bindTo(e).using((t) => {
						if ("separator" === t.type) return new Eh(n);
						if ("button" === t.type || "switchbutton" === t.type) {
							const e = new Dh(n);
							let o;
							return (
								(o = "button" === t.type ? new Ju(n) : new Xu(n)),
								o.bind(...Object.keys(t.model)).to(t.model),
								o.delegate("execute").to(e),
								e.children.add(o),
								e
							);
						}
						return null;
					}),
						t.panelView.children.add(o),
						o.items.delegate("execute").to(t),
						Rh(t, () =>
							o.items.find((t) => t instanceof Dh && t.children.first.isOn),
						);
				}
				function Rh(t, e) {
					t.on(
						"change:isOpen",
						() => {
							if (!t.isOpen) return;
							const n = e();
							n &&
								("function" == typeof n.focus
									? n.focus()
									: Object(l.b)(
											"ui-dropdown-focus-child-on-open-child-missing-focus",
											{ view: n },
										));
						},
						{ priority: a.low - 10 },
					);
				}
				var Oh = n(30),
					Mh = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Oh.a, Mh), Oh.a.locals;
				class Nh extends fu {
					constructor(t) {
						super(t), (this.body = new $u(t));
					}
					render() {
						super.render(), this.body.attachToDom();
					}
					destroy() {
						return this.body.detachFromDom(), super.destroy();
					}
				}
				var Vh = n(31),
					Lh = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Vh.a, Lh), Vh.a.locals;
				class jh extends fu {
					constructor(t) {
						super(t),
							this.set("text", void 0),
							this.set("for", void 0),
							(this.id = `ck-editor__label_${s()}`);
						const e = this.bindTemplate;
						this.setTemplate({
							tag: "label",
							attributes: {
								class: ["ck", "ck-label"],
								id: this.id,
								for: e.to("for"),
							},
							children: [{ text: e.to("text") }],
						});
					}
				}
				class Hh extends fu {
					constructor(t, e, n) {
						super(t),
							this.setTemplate({
								tag: "div",
								attributes: {
									class: [
										"ck",
										"ck-content",
										"ck-editor__editable",
										"ck-rounded-corners",
									],
									lang: t.contentLanguage,
									dir: t.contentLanguageDirection,
								},
							}),
							(this.name = null),
							this.set("isFocused", !1),
							(this._editableElement = n),
							(this._hasExternalElement = !!this._editableElement),
							(this._editingView = e);
					}
					render() {
						super.render(),
							this._hasExternalElement
								? this.template.apply((this.element = this._editableElement))
								: (this._editableElement = this.element),
							this.on("change:isFocused", () => this._updateIsFocusedClasses()),
							this._updateIsFocusedClasses();
					}
					destroy() {
						this._hasExternalElement &&
							this.template.revert(this._editableElement),
							super.destroy();
					}
					_updateIsFocusedClasses() {
						const t = this._editingView;
						function e(e) {
							t.change((n) => {
								const o = t.document.getRoot(e.name);
								n.addClass(e.isFocused ? "ck-focused" : "ck-blurred", o),
									n.removeClass(e.isFocused ? "ck-blurred" : "ck-focused", o);
							});
						}
						t.isRenderingInProgress
							? (function n(o) {
									t.once("change:isRenderingInProgress", (t, i, r) => {
										r ? n(o) : e(o);
									});
								})(this)
							: e(this);
					}
				}
				class $h extends Hh {
					constructor(t, e, n, o = {}) {
						super(t, e, n);
						const i = t.t;
						this.extendTemplate({
							attributes: {
								role: "textbox",
								class: "ck-editor__editable_inline",
							},
						}),
							(this._generateLabel =
								o.label || (() => i("Editor editing area: %0", this.name)));
					}
					render() {
						super.render();
						const t = this._editingView;
						t.change((e) => {
							const n = t.document.getRoot(this.name);
							e.setAttribute("aria-label", this._generateLabel(this), n);
						});
					}
				}
				var qh = n(32),
					Uh = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(qh.a, Uh), qh.a.locals;
				var Wh = n(33),
					Kh = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Wh.a, Kh), Wh.a.locals;
				class Gh extends fu {
					constructor(t) {
						super(t),
							this.set("value", void 0),
							this.set("id", void 0),
							this.set("placeholder", void 0),
							this.set("isReadOnly", !1),
							this.set("hasError", !1),
							this.set("ariaDescribedById", void 0),
							(this.focusTracker = new xa()),
							this.bind("isFocused").to(this.focusTracker),
							this.set("isEmpty", !0),
							this.set("inputMode", "text");
						const e = this.bindTemplate;
						this.setTemplate({
							tag: "input",
							attributes: {
								class: [
									"ck",
									"ck-input",
									e.if("isFocused", "ck-input_focused"),
									e.if("isEmpty", "ck-input-text_empty"),
									e.if("hasError", "ck-error"),
								],
								id: e.to("id"),
								placeholder: e.to("placeholder"),
								readonly: e.to("isReadOnly"),
								inputmode: e.to("inputMode"),
								"aria-invalid": e.if("hasError", !0),
								"aria-describedby": e.to("ariaDescribedById"),
							},
							on: {
								input: e.to((...t) => {
									this.fire("input", ...t), this._updateIsEmpty();
								}),
								change: e.to(this._updateIsEmpty.bind(this)),
							},
						});
					}
					render() {
						super.render(),
							this.focusTracker.add(this.element),
							this._setDomElementValue(this.value),
							this._updateIsEmpty(),
							this.on("change:value", (t, e, n) => {
								this._setDomElementValue(n), this._updateIsEmpty();
							});
					}
					destroy() {
						super.destroy(), this.focusTracker.destroy();
					}
					select() {
						this.element.select();
					}
					focus() {
						this.element.focus();
					}
					_updateIsEmpty() {
						this.isEmpty = !this.element.value;
					}
					_setDomElementValue(t) {
						this.element.value = t || 0 === t ? t : "";
					}
				}
				class Jh extends Gh {
					constructor(t) {
						super(t),
							this.extendTemplate({
								attributes: { type: "text", class: ["ck-input-text"] },
							});
					}
				}
				class Yh extends Gh {
					constructor(t, { min: e, max: n, step: o } = {}) {
						super(t);
						const i = this.bindTemplate;
						this.set("min", e),
							this.set("max", n),
							this.set("step", o),
							this.extendTemplate({
								attributes: {
									type: "number",
									class: ["ck-input-number"],
									min: i.to("min"),
									max: i.to("max"),
									step: i.to("step"),
								},
							});
					}
				}
				var Qh = n(34),
					Xh = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Qh.a, Xh), Qh.a.locals;
				class Zh extends fu {
					constructor(t, e) {
						super(t);
						const n = `ck-labeled-field-view-${s()}`,
							o = `ck-labeled-field-view-status-${s()}`;
						(this.fieldView = e(this, n, o)),
							this.set("label", void 0),
							this.set("isEnabled", !0),
							this.set("isEmpty", !0),
							this.set("isFocused", !1),
							this.set("errorText", null),
							this.set("infoText", null),
							this.set("class", void 0),
							this.set("placeholder", void 0),
							(this.labelView = this._createLabelView(n)),
							(this.statusView = this._createStatusView(o)),
							(this.fieldWrapperChildren = this.createCollection([
								this.fieldView,
								this.labelView,
							])),
							this.bind("_statusText").to(
								this,
								"errorText",
								this,
								"infoText",
								(t, e) => t || e,
							);
						const i = this.bindTemplate;
						this.setTemplate({
							tag: "div",
							attributes: {
								class: [
									"ck",
									"ck-labeled-field-view",
									i.to("class"),
									i.if("isEnabled", "ck-disabled", (t) => !t),
									i.if("isEmpty", "ck-labeled-field-view_empty"),
									i.if("isFocused", "ck-labeled-field-view_focused"),
									i.if("placeholder", "ck-labeled-field-view_placeholder"),
									i.if("errorText", "ck-error"),
								],
							},
							children: [
								{
									tag: "div",
									attributes: {
										class: ["ck", "ck-labeled-field-view__input-wrapper"],
									},
									children: this.fieldWrapperChildren,
								},
								this.statusView,
							],
						});
					}
					_createLabelView(t) {
						const e = new jh(this.locale);
						return (e.for = t), e.bind("text").to(this, "label"), e;
					}
					_createStatusView(t) {
						const e = new fu(this.locale),
							n = this.bindTemplate;
						return (
							e.setTemplate({
								tag: "div",
								attributes: {
									class: [
										"ck",
										"ck-labeled-field-view__status",
										n.if("errorText", "ck-labeled-field-view__status_error"),
										n.if("_statusText", "ck-hidden", (t) => !t),
									],
									id: t,
									role: n.if("errorText", "alert"),
								},
								children: [{ text: n.to("_statusText") }],
							}),
							e
						);
					}
					focus() {
						this.fieldView.focus();
					}
				}
				function tp(t, e, n) {
					const o = new Jh(t.locale);
					return (
						o.set({ id: e, ariaDescribedById: n }),
						o.bind("isReadOnly").to(t, "isEnabled", (t) => !t),
						o.bind("hasError").to(t, "errorText", (t) => !!t),
						o.on("input", () => {
							t.errorText = null;
						}),
						t.bind("isEmpty", "isFocused", "placeholder").to(o),
						o
					);
				}
				function ep(t, e, n) {
					const o = new Yh(t.locale);
					return (
						o.set({ id: e, ariaDescribedById: n, inputMode: "numeric" }),
						o.bind("isReadOnly").to(t, "isEnabled", (t) => !t),
						o.bind("hasError").to(t, "errorText", (t) => !!t),
						o.on("input", () => {
							t.errorText = null;
						}),
						t.bind("isEmpty", "isFocused", "placeholder").to(o),
						o
					);
				}
				class np extends B {
					constructor(t, e) {
						super(), e && cs(this, e), t && this.set(t);
					}
				}
				var op = n(35),
					ip = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					},
					rp = (Or()(op.a, ip), op.a.locals, n(36)),
					sp = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(rp.a, sp), rp.a.locals;
				const ap = pa("px");
				class cp extends R {
					constructor(t) {
						super(t),
							(this.positionLimiter = () => {
								const t = this.editor.editing.view,
									e = t.document.selection.editableElement;
								return e ? t.domConverter.mapViewToDom(e.root) : null;
							}),
							this.set("visibleView", null),
							(this.view = new vu(t.locale)),
							t.ui.view.body.add(this.view),
							t.ui.focusTracker.add(this.view.element),
							(this._viewToStack = new Map()),
							(this._idToStack = new Map()),
							this.set("_numberOfStacks", 0),
							this.set("_singleViewMode", !1),
							(this._rotatorView = this._createRotatorView()),
							(this._fakePanelsView = this._createFakePanelsView());
					}
					static get pluginName() {
						return "ContextualBalloon";
					}
					destroy() {
						super.destroy(),
							this.view.destroy(),
							this._rotatorView.destroy(),
							this._fakePanelsView.destroy();
					}
					hasView(t) {
						return Array.from(this._viewToStack.keys()).includes(t);
					}
					add(t) {
						if (this.hasView(t.view))
							throw new l.a("contextualballoon-add-view-exist", [this, t]);
						const e = t.stackId || "main";
						if (!this._idToStack.has(e))
							return (
								this._idToStack.set(e, new Map([[t.view, t]])),
								this._viewToStack.set(t.view, this._idToStack.get(e)),
								(this._numberOfStacks = this._idToStack.size),
								void (
									(this._visibleStack && !t.singleViewMode) ||
									this.showStack(e)
								)
							);
						const n = this._idToStack.get(e);
						t.singleViewMode && this.showStack(e),
							n.set(t.view, t),
							this._viewToStack.set(t.view, n),
							n === this._visibleStack && this._showView(t);
					}
					remove(t) {
						if (!this.hasView(t))
							throw new l.a("contextualballoon-remove-view-not-exist", [
								this,
								t,
							]);
						const e = this._viewToStack.get(t);
						this._singleViewMode &&
							this.visibleView === t &&
							(this._singleViewMode = !1),
							this.visibleView === t &&
								(1 === e.size
									? this._idToStack.size > 1
										? this._showNextStack()
										: (this.view.hide(),
											(this.visibleView = null),
											this._rotatorView.hideView())
									: this._showView(Array.from(e.values())[e.size - 2])),
							1 === e.size
								? (this._idToStack.delete(this._getStackId(e)),
									(this._numberOfStacks = this._idToStack.size))
								: e.delete(t),
							this._viewToStack.delete(t);
					}
					updatePosition(t) {
						t && (this._visibleStack.get(this.visibleView).position = t),
							this.view.pin(this._getBalloonPosition()),
							this._fakePanelsView.updatePosition();
					}
					showStack(t) {
						this.visibleStack = t;
						const e = this._idToStack.get(t);
						if (!e)
							throw new l.a(
								"contextualballoon-showstack-stack-not-exist",
								this,
							);
						this._visibleStack !== e &&
							this._showView(Array.from(e.values()).pop());
					}
					get _visibleStack() {
						return this._viewToStack.get(this.visibleView);
					}
					_getStackId(t) {
						return Array.from(this._idToStack.entries()).find(
							(e) => e[1] === t,
						)[0];
					}
					_showNextStack() {
						const t = Array.from(this._idToStack.values());
						let e = t.indexOf(this._visibleStack) + 1;
						t[e] || (e = 0), this.showStack(this._getStackId(t[e]));
					}
					_showPrevStack() {
						const t = Array.from(this._idToStack.values());
						let e = t.indexOf(this._visibleStack) - 1;
						t[e] || (e = t.length - 1), this.showStack(this._getStackId(t[e]));
					}
					_createRotatorView() {
						const t = new lp(this.editor.locale),
							e = this.editor.locale.t;
						return (
							this.view.content.add(t),
							t
								.bind("isNavigationVisible")
								.to(
									this,
									"_numberOfStacks",
									this,
									"_singleViewMode",
									(t, e) => !e && t > 1,
								),
							t.on("change:isNavigationVisible", () => this.updatePosition(), {
								priority: "low",
							}),
							t
								.bind("counter")
								.to(this, "visibleView", this, "_numberOfStacks", (t, n) => {
									if (n < 2) return "";
									const o =
										Array.from(this._idToStack.values()).indexOf(
											this._visibleStack,
										) + 1;
									return e("%0 of %1", [o, n]);
								}),
							t.buttonNextView.on("execute", () => {
								t.focusTracker.isFocused && this.editor.editing.view.focus(),
									this._showNextStack();
							}),
							t.buttonPrevView.on("execute", () => {
								t.focusTracker.isFocused && this.editor.editing.view.focus(),
									this._showPrevStack();
							}),
							t
						);
					}
					_createFakePanelsView() {
						const t = new dp(this.editor.locale, this.view);
						return (
							t
								.bind("numberOfPanels")
								.to(this, "_numberOfStacks", this, "_singleViewMode", (t, e) =>
									!e && t >= 2 ? Math.min(t - 1, 2) : 0,
								),
							t.listenTo(this.view, "change:top", () => t.updatePosition()),
							t.listenTo(this.view, "change:left", () => t.updatePosition()),
							this.editor.ui.view.body.add(t),
							t
						);
					}
					_showView({
						view: t,
						balloonClassName: e = "",
						withArrow: n = !0,
						singleViewMode: o = !1,
					}) {
						(this.view.class = e),
							(this.view.withArrow = n),
							this._rotatorView.showView(t),
							(this.visibleView = t),
							this.view.pin(this._getBalloonPosition()),
							this._fakePanelsView.updatePosition(),
							o && (this._singleViewMode = !0);
					}
					_getBalloonPosition() {
						let t = Array.from(this._visibleStack.values()).pop().position;
						return (
							t &&
								(t.limiter ||
									(t = Object.assign({}, t, { limiter: this.positionLimiter })),
								(t = Object.assign({}, t, {
									viewportOffsetConfig: this.editor.ui.viewportOffset,
								}))),
							t
						);
					}
				}
				class lp extends fu {
					constructor(t) {
						super(t);
						const e = t.t,
							n = this.bindTemplate;
						this.set("isNavigationVisible", !0),
							(this.focusTracker = new xa()),
							(this.buttonPrevView = this._createButtonView(
								e("Previous"),
								'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>',
							)),
							(this.buttonNextView = this._createButtonView(
								e("Next"),
								'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>',
							)),
							(this.content = this.createCollection()),
							this.setTemplate({
								tag: "div",
								attributes: {
									class: ["ck", "ck-balloon-rotator"],
									"z-index": "-1",
								},
								children: [
									{
										tag: "div",
										attributes: {
											class: [
												"ck-balloon-rotator__navigation",
												n.to("isNavigationVisible", (t) =>
													t ? "" : "ck-hidden",
												),
											],
										},
										children: [
											this.buttonPrevView,
											{
												tag: "span",
												attributes: { class: ["ck-balloon-rotator__counter"] },
												children: [{ text: n.to("counter") }],
											},
											this.buttonNextView,
										],
									},
									{
										tag: "div",
										attributes: { class: "ck-balloon-rotator__content" },
										children: this.content,
									},
								],
							});
					}
					render() {
						super.render(), this.focusTracker.add(this.element);
					}
					destroy() {
						super.destroy(), this.focusTracker.destroy();
					}
					showView(t) {
						this.hideView(), this.content.add(t);
					}
					hideView() {
						this.content.clear();
					}
					_createButtonView(t, e) {
						const n = new Ju(this.locale);
						return n.set({ label: t, icon: e, tooltip: !0 }), n;
					}
				}
				class dp extends fu {
					constructor(t, e) {
						super(t);
						const n = this.bindTemplate;
						this.set("top", 0),
							this.set("left", 0),
							this.set("height", 0),
							this.set("width", 0),
							this.set("numberOfPanels", 0),
							(this.content = this.createCollection()),
							(this._balloonPanelView = e),
							this.setTemplate({
								tag: "div",
								attributes: {
									class: [
										"ck-fake-panel",
										n.to("numberOfPanels", (t) => (t ? "" : "ck-hidden")),
									],
									style: {
										top: n.to("top", ap),
										left: n.to("left", ap),
										width: n.to("width", ap),
										height: n.to("height", ap),
									},
								},
								children: this.content,
							}),
							this.on("change:numberOfPanels", (t, e, n, o) => {
								n > o ? this._addPanels(n - o) : this._removePanels(o - n),
									this.updatePosition();
							});
					}
					_addPanels(t) {
						for (; t--; ) {
							const t = new fu();
							t.setTemplate({ tag: "div" }),
								this.content.add(t),
								this.registerChild(t);
						}
					}
					_removePanels(t) {
						for (; t--; ) {
							const t = this.content.last;
							this.content.remove(t), this.deregisterChild(t), t.destroy();
						}
					}
					updatePosition() {
						if (this.numberOfPanels) {
							const { top: t, left: e } = this._balloonPanelView,
								{ width: n, height: o } = new aa(
									this._balloonPanelView.element,
								);
							Object.assign(this, { top: t, left: e, width: n, height: o });
						}
					}
				}
				var up = n(37),
					hp = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(up.a, hp), up.a.locals;
				pa("px");
				const pp = pa("px");
				class gp extends R {
					constructor(t) {
						super(t),
							(this._balloonConfig = gh(t.config.get("balloonToolbar"))),
							(this.toolbarView = this._createToolbarView()),
							(this.focusTracker = new xa()),
							t.ui.once("ready", () => {
								this.focusTracker.add(t.ui.getEditableElement()),
									this.focusTracker.add(this.toolbarView.element);
							}),
							t.ui.addToolbar(this.toolbarView, {
								beforeFocus: () => this.show(!0),
								afterBlur: () => this.hide(),
								isContextual: !0,
							}),
							(this._resizeObserver = null),
							(this._balloon = t.plugins.get(cp)),
							(this._fireSelectionChangeDebounced = ys(
								() => this.fire("_selectionChangeDebounced"),
								200,
							)),
							this.decorate("show");
					}
					static get pluginName() {
						return "BalloonToolbar";
					}
					static get requires() {
						return [cp];
					}
					init() {
						const t = this.editor,
							e = t.model.document.selection;
						this.listenTo(this.focusTracker, "change:isFocused", (t, e, n) => {
							const o = this._balloon.visibleView === this.toolbarView;
							!n && o ? this.hide() : n && this.show();
						}),
							this.listenTo(e, "change:range", (t, n) => {
								(n.directChange || e.isCollapsed) && this.hide(),
									this._fireSelectionChangeDebounced();
							}),
							this.listenTo(this, "_selectionChangeDebounced", () => {
								this.editor.editing.view.document.isFocused && this.show();
							}),
							this._balloonConfig.shouldNotGroupWhenFull ||
								this.listenTo(t, "ready", () => {
									const e = t.ui.view.editable.element;
									this._resizeObserver = new ua(e, () => {
										this.toolbarView.maxWidth = pp(0.9 * new aa(e).width);
									});
								}),
							this.listenTo(this.toolbarView, "groupedItemsUpdate", () => {
								this._updatePosition();
							});
					}
					afterInit() {
						const t = this.editor.ui.componentFactory;
						this.toolbarView.fillFromConfig(this._balloonConfig, t);
					}
					_createToolbarView() {
						const t = this.editor.locale.t,
							e = !this._balloonConfig.shouldNotGroupWhenFull,
							n = new wh(this.editor.locale, {
								shouldGroupWhenFull: e,
								isFloating: !0,
							});
						return (
							(n.ariaLabel = t("Editor contextual toolbar")), n.render(), n
						);
					}
					show(t = !1) {
						const e = this.editor,
							n = e.model.document.selection,
							o = e.model.schema;
						this._balloon.hasView(this.toolbarView) ||
							(n.isCollapsed && !t) ||
							(function (t, e) {
								if (1 === t.rangeCount) return !1;
								return [...t.getRanges()].every((t) => {
									const n = t.getContainedElement();
									return n && e.isSelectable(n);
								});
							})(n, o) ||
							Array.from(this.toolbarView.items).every(
								(t) => void 0 !== t.isEnabled && !t.isEnabled,
							) ||
							(this.listenTo(this.editor.ui, "update", () => {
								this._updatePosition();
							}),
							this._balloon.add({
								view: this.toolbarView,
								position: this._getBalloonPositionData(),
								balloonClassName: "ck-toolbar-container",
							}));
					}
					hide() {
						this._balloon.hasView(this.toolbarView) &&
							(this.stopListening(this.editor.ui, "update"),
							this._balloon.remove(this.toolbarView));
					}
					_getBalloonPositionData() {
						const t = this.editor.editing.view,
							e = t.document,
							n = e.selection,
							o = e.selection.isBackward;
						return {
							target: () => {
								const e = o ? n.getFirstRange() : n.getLastRange(),
									i = aa.getDomRangeRects(t.domConverter.viewRangeToDom(e));
								return o
									? i[0]
									: (i.length > 1 && 0 === i[i.length - 1].width && i.pop(),
										i[i.length - 1]);
							},
							positions: this._getBalloonPositions(o),
						};
					}
					_updatePosition() {
						this._balloon.updatePosition(this._getBalloonPositionData());
					}
					destroy() {
						super.destroy(),
							this.stopListening(),
							this._fireSelectionChangeDebounced.cancel(),
							this.toolbarView.destroy(),
							this.focusTracker.destroy(),
							this._resizeObserver && this._resizeObserver.destroy();
					}
					_getBalloonPositions(t) {
						const e =
							Ui.isSafari && Ui.isiOS
								? xu({
										heightOffset: Math.max(
											vu.arrowHeightOffset,
											Math.round(20 / no.window.visualViewport.scale),
										),
									})
								: vu.defaultPositions;
						return t
							? [
									e.northWestArrowSouth,
									e.northWestArrowSouthWest,
									e.northWestArrowSouthEast,
									e.northWestArrowSouthMiddleEast,
									e.northWestArrowSouthMiddleWest,
									e.southWestArrowNorth,
									e.southWestArrowNorthWest,
									e.southWestArrowNorthEast,
									e.southWestArrowNorthMiddleWest,
									e.southWestArrowNorthMiddleEast,
								]
							: [
									e.southEastArrowNorth,
									e.southEastArrowNorthEast,
									e.southEastArrowNorthWest,
									e.southEastArrowNorthMiddleEast,
									e.southEastArrowNorthMiddleWest,
									e.northEastArrowSouth,
									e.northEastArrowSouthEast,
									e.northEastArrowSouthWest,
									e.northEastArrowSouthMiddleEast,
									e.northEastArrowSouthMiddleWest,
								];
					}
				}
				var fp = n(38),
					mp = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(fp.a, mp), fp.a.locals;
				pa("px");
				pa("px");
				class kp extends Pu {
					constructor(t, e) {
						super(t), (this.view = e);
					}
					get element() {
						return this.view.editable.element;
					}
					init() {
						const t = this.editor,
							e = this.view,
							n = t.editing.view,
							o = e.editable,
							i = n.document.getRoot();
						(o.name = i.rootName), e.render();
						const r = o.element;
						this.setEditableElement(o.name, r),
							o.bind("isFocused").to(this.focusTracker),
							n.attachDomRoot(r),
							this._initPlaceholder(),
							this.fire("ready");
					}
					destroy() {
						super.destroy();
						const t = this.view;
						this.editor.editing.view.detachDomRoot(t.editable.name),
							t.destroy();
					}
					_initPlaceholder() {
						const t = this.editor,
							e = t.editing.view,
							n = e.document.getRoot(),
							o = t.sourceElement,
							i =
								t.config.get("placeholder") ||
								(o &&
									"textarea" === o.tagName.toLowerCase() &&
									o.getAttribute("placeholder"));
						i &&
							gd({
								view: e,
								element: n,
								text: i,
								isDirectHost: !1,
								keepOnFocus: !0,
							});
					}
				}
				class bp extends Nh {
					constructor(t, e, n) {
						super(t);
						const o = t.t;
						this.editable = new $h(t, e, n, {
							label: (t) => o("Rich Text Editor. Editing area: %0", t.name),
						});
					}
					render() {
						super.render(), this.registerChild(this.editable);
					}
				}
				class wp extends Hd {
					constructor(t, e = {}) {
						if (!Kn(t) && void 0 !== e.initialData)
							throw new l.a("editor-create-initial-data", null);
						super(e),
							void 0 === this.config.get("initialData") &&
								this.config.set(
									"initialData",
									(function (t) {
										return Kn(t)
											? ((e = t),
												e instanceof HTMLTextAreaElement
													? e.value
													: e.innerHTML)
											: t;
										var e;
									})(t),
								),
							Kn(t) &&
								((this.sourceElement = t),
								(function (t) {
									const e = t.sourceElement;
									if (e) {
										if (e.ckeditorInstance)
											throw new l.a("editor-source-element-already-used", t);
										(e.ckeditorInstance = t),
											t.once("destroy", () => {
												delete e.ckeditorInstance;
											});
									}
								})(this));
						const n = this.config.get("plugins");
						n.push(gp),
							this.config.set("plugins", n),
							this.config.define("balloonToolbar", this.config.get("toolbar")),
							this.model.document.createRoot();
						const o = new bp(
							this.locale,
							this.editing.view,
							this.sourceElement,
						);
						(this.ui = new kp(this, o)),
							(function (t) {
								if (!At(t.updateSourceElement))
									throw new l.a("attachtoform-missing-elementapi-interface", t);
								const e = t.sourceElement;
								if (
									(function (t) {
										return !!t && "textarea" === t.tagName.toLowerCase();
									})(e) &&
									e.form
								) {
									let n;
									const o = e.form,
										i = () => t.updateSourceElement();
									At(o.submit) &&
										((n = o.submit),
										(o.submit = () => {
											i(), n.apply(o);
										})),
										o.addEventListener("submit", i),
										t.on("destroy", () => {
											o.removeEventListener("submit", i), n && (o.submit = n);
										});
								}
							})(this);
					}
					destroy() {
						const t = this.getData();
						return (
							this.ui.destroy(),
							super.destroy().then(() => {
								this.sourceElement && this.updateSourceElement(t);
							})
						);
					}
					static create(t, e = {}) {
						return new Promise((n) => {
							if (Kn(t) && "TEXTAREA" === t.tagName)
								throw new l.a("editor-wrong-element", null);
							const o = new this(t, e);
							n(
								o
									.initPlugins()
									.then(() => o.ui.init())
									.then(() => o.data.init(o.config.get("initialData")))
									.then(() => o.fire("ready"))
									.then(() => o),
							);
						});
					}
				}
				ta(wp, Iu), ta(wp, zu);
				class Ap {
					constructor(t, e = 20) {
						(this._batch = null),
							(this.model = t),
							(this._size = 0),
							(this.limit = e),
							(this._isLocked = !1),
							(this._changeCallback = (t, e) => {
								e.isLocal &&
									e.isUndoable &&
									e !== this._batch &&
									this._reset(!0);
							}),
							(this._selectionChangeCallback = () => {
								this._reset();
							}),
							this.model.document.on("change", this._changeCallback),
							this.model.document.selection.on(
								"change:range",
								this._selectionChangeCallback,
							),
							this.model.document.selection.on(
								"change:attribute",
								this._selectionChangeCallback,
							);
					}
					get batch() {
						return (
							this._batch ||
								(this._batch = this.model.createBatch({ isTyping: !0 })),
							this._batch
						);
					}
					get size() {
						return this._size;
					}
					input(t) {
						(this._size += t), this._size >= this.limit && this._reset(!0);
					}
					get isLocked() {
						return this._isLocked;
					}
					lock() {
						this._isLocked = !0;
					}
					unlock() {
						this._isLocked = !1;
					}
					destroy() {
						this.model.document.off("change", this._changeCallback),
							this.model.document.selection.off(
								"change:range",
								this._selectionChangeCallback,
							),
							this.model.document.selection.off(
								"change:attribute",
								this._selectionChangeCallback,
							);
					}
					_reset(t = !1) {
						(this.isLocked && !t) || ((this._batch = null), (this._size = 0));
					}
				}
				class _p extends M {
					constructor(t, e) {
						super(t), (this._buffer = new Ap(t.model, e));
					}
					get buffer() {
						return this._buffer;
					}
					destroy() {
						super.destroy(), this._buffer.destroy();
					}
					execute(t = {}) {
						const e = this.editor.model,
							n = e.document,
							o = t.text || "",
							i = o.length;
						let r = n.selection;
						t.selection
							? (r = t.selection)
							: t.range && (r = e.createSelection(t.range));
						const s = t.resultRange;
						e.enqueueChange(this._buffer.batch, (t) => {
							this._buffer.lock(),
								e.deleteContent(r),
								o &&
									e.insertContent(
										t.createText(o, n.selection.getAttributes()),
										r,
									),
								s
									? t.setSelection(s)
									: r.is("documentSelection") || t.setSelection(r),
								this._buffer.unlock(),
								this._buffer.input(i);
						});
					}
				}
				const Cp = ["insertText", "insertReplacementText"];
				class vp extends as {
					constructor(t) {
						super(t), Ui.isAndroid && Cp.push("insertCompositionText");
						const e = t.document;
						e.on("beforeinput", (n, o) => {
							if (!this.isEnabled) return;
							const { data: r, targetRanges: s, inputType: a, domEvent: c } = o;
							if (!Cp.includes(a)) return;
							const l = new i(e, "insertText");
							e.fire(
								l,
								new ls(t, c, { text: r, selection: t.createSelection(s) }),
							),
								l.stop.called && n.stop();
						}),
							e.on(
								"compositionend",
								(n, { data: o, domEvent: i }) => {
									this.isEnabled &&
										!Ui.isAndroid &&
										o &&
										e.fire(
											"insertText",
											new ls(t, i, { text: o, selection: e.selection }),
										);
								},
								{ priority: "lowest" },
							);
					}
					observe() {}
				}
				class yp extends R {
					static get pluginName() {
						return "Input";
					}
					init() {
						const t = this.editor,
							e = t.model,
							n = t.editing.view,
							o = e.document.selection;
						n.addObserver(vp);
						const i = new _p(t, t.config.get("typing.undoStep") || 20);
						t.commands.add("insertText", i),
							t.commands.add("input", i),
							this.listenTo(n.document, "insertText", (o, i) => {
								n.document.isComposing || i.preventDefault();
								const { text: r, selection: s, resultRange: a } = i,
									c = Array.from(s.getRanges()).map((e) =>
										t.editing.mapper.toModelRange(e),
									);
								let l = r;
								if (Ui.isAndroid) {
									const t = Array.from(c[0].getItems()).reduce(
										(t, e) => t + (e.is("$textProxy") ? e.data : ""),
										"",
									);
									t &&
										(t.length <= l.length
											? l.startsWith(t) &&
												((l = l.substring(t.length)),
												(c[0].start = c[0].start.getShiftedBy(t.length)))
											: t.startsWith(l) &&
												((c[0].start = c[0].start.getShiftedBy(l.length)),
												(l = "")));
								}
								const d = { text: l, selection: e.createSelection(c) };
								a && (d.resultRange = t.editing.mapper.toModelRange(a)),
									t.execute("insertText", d);
							}),
							Ui.isAndroid
								? this.listenTo(n.document, "keydown", (t, r) => {
										!o.isCollapsed &&
											229 == r.keyCode &&
											n.document.isComposing &&
											xp(e, i);
									})
								: this.listenTo(n.document, "compositionstart", () => {
										o.isCollapsed || xp(e, i);
									});
					}
				}
				function xp(t, e) {
					if (!e.isEnabled) return;
					const n = e.buffer;
					n.lock(),
						t.enqueueChange(n.batch, () => {
							t.deleteContent(t.document.selection);
						}),
						n.unlock();
				}
				class Dp extends M {
					constructor(t, e) {
						super(t),
							(this.direction = e),
							(this._buffer = new Ap(t.model, t.config.get("typing.undoStep")));
					}
					get buffer() {
						return this._buffer;
					}
					execute(t = {}) {
						const e = this.editor.model,
							n = e.document;
						e.enqueueChange(this._buffer.batch, (o) => {
							this._buffer.lock();
							const i = o.createSelection(t.selection || n.selection),
								r = t.sequence || 1,
								s = i.isCollapsed;
							if (
								(i.isCollapsed &&
									e.modifySelection(i, {
										direction: this.direction,
										unit: t.unit,
										treatEmojiAsSingleUnit: !0,
									}),
								this._shouldEntireContentBeReplacedWithParagraph(r))
							)
								return void this._replaceEntireContentWithParagraph(o);
							if (this._shouldReplaceFirstBlockWithParagraph(i, r))
								return void this.editor.execute("paragraph", { selection: i });
							if (i.isCollapsed) return;
							let a = 0;
							i
								.getFirstRange()
								.getMinimalFlatRanges()
								.forEach((t) => {
									a += Ei(
										t.getWalker({
											singleCharacters: !0,
											ignoreElementEnd: !0,
											shallow: !0,
										}),
									);
								}),
								e.deleteContent(i, {
									doNotResetEntireContent: s,
									direction: this.direction,
								}),
								this._buffer.input(a),
								o.setSelection(i),
								this._buffer.unlock();
						});
					}
					_shouldEntireContentBeReplacedWithParagraph(t) {
						if (t > 1) return !1;
						const e = this.editor.model,
							n = e.document.selection,
							o = e.schema.getLimitElement(n);
						if (!(n.isCollapsed && n.containsEntireContent(o))) return !1;
						if (!e.schema.checkChild(o, "paragraph")) return !1;
						const i = o.getChild(0);
						return !i || !i.is("element", "paragraph");
					}
					_replaceEntireContentWithParagraph(t) {
						const e = this.editor.model,
							n = e.document.selection,
							o = e.schema.getLimitElement(n),
							i = t.createElement("paragraph");
						t.remove(t.createRangeIn(o)), t.insert(i, o), t.setSelection(i, 0);
					}
					_shouldReplaceFirstBlockWithParagraph(t, e) {
						const n = this.editor.model;
						if (e > 1 || "backward" != this.direction) return !1;
						if (!t.isCollapsed) return !1;
						const o = t.getFirstPosition(),
							i = n.schema.getLimitElement(o),
							r = i.getChild(0);
						return (
							o.parent == r &&
							!!t.containsEntireContent(r) &&
								!!n.schema.checkChild(i, "paragraph") &&
							"paragraph" != r.name
						);
					}
				}
				const Ep = "word",
					Sp = "selection",
					Bp = "backward",
					Tp = "forward",
					Pp = {
						deleteContent: { unit: Sp, direction: Bp },
						deleteContentBackward: { unit: "codePoint", direction: Bp },
						deleteWordBackward: { unit: Ep, direction: Bp },
						deleteHardLineBackward: { unit: Sp, direction: Bp },
						deleteSoftLineBackward: { unit: Sp, direction: Bp },
						deleteContentForward: { unit: "character", direction: Tp },
						deleteWordForward: { unit: Ep, direction: Tp },
						deleteHardLineForward: { unit: Sp, direction: Tp },
						deleteSoftLineForward: { unit: Sp, direction: Tp },
					};
				class Fp extends as {
					constructor(t) {
						super(t);
						const e = t.document;
						let n = 0;
						e.on("keydown", () => {
							n++;
						}),
							e.on("keyup", () => {
								n = 0;
							}),
							e.on("beforeinput", (o, i) => {
								if (!this.isEnabled) return;
								const { targetRanges: r, domEvent: s, inputType: a } = i,
									c = Pp[a];
								if (!c) return;
								const l = { direction: c.direction, unit: c.unit, sequence: n };
								l.unit == Sp && (l.selectionToRemove = t.createSelection(r[0])),
									Ui.isAndroid &&
										"deleteContentBackward" === a &&
										((l.sequence = 1),
										1 != r.length ||
											(r[0].start.parent == r[0].end.parent &&
												r[0].start.offset + 1 == r[0].end.offset) ||
											((l.unit = Sp),
											(l.selectionToRemove = t.createSelection(r))));
								const d = new Ti(e, "delete", r[0]);
								e.fire(d, new ls(t, s, l)), d.stop.called && o.stop();
							}),
							Ui.isBlink &&
								(function (t) {
									const e = t.view,
										n = e.document;
									let o = null,
										i = !1;
									function r(t) {
										return t == Ji.backspace || t == Ji.delete;
									}
									function s(t) {
										return t == Ji.backspace ? Bp : Tp;
									}
									n.on("keydown", (t, { keyCode: e }) => {
										(o = e), (i = !1);
									}),
										n.on("keyup", (a, { keyCode: c, domEvent: l }) => {
											const d = n.selection,
												u =
													t.isEnabled && c == o && r(c) && !d.isCollapsed && !i;
											if (((o = null), u)) {
												const t = d.getFirstRange(),
													o = new Ti(n, "delete", t),
													i = {
														unit: Sp,
														direction: s(c),
														selectionToRemove: d,
													};
												n.fire(o, new ls(e, l, i));
											}
										}),
										n.on("beforeinput", (t, { inputType: e }) => {
											const n = Pp[e];
											r(o) && n && n.direction == s(o) && (i = !0);
										}),
										n.on(
											"beforeinput",
											(t, { inputType: e, data: n }) => {
												o == Ji.delete &&
													"insertText" == e &&
													"" == n &&
													t.stop();
											},
											{ priority: "high" },
										);
								})(this);
					}
					observe() {}
				}
				class Ip extends R {
					static get pluginName() {
						return "Delete";
					}
					init() {
						const t = this.editor,
							e = t.editing.view,
							n = e.document,
							o = t.model.document;
						e.addObserver(Fp), (this._undoOnBackspace = !1);
						const i = new Dp(t, "forward");
						t.commands.add("deleteForward", i),
							t.commands.add("forwardDelete", i),
							t.commands.add("delete", new Dp(t, "backward")),
							this.listenTo(
								n,
								"delete",
								(o, i) => {
									n.isComposing || i.preventDefault();
									const {
											direction: r,
											sequence: s,
											selectionToRemove: a,
											unit: c,
										} = i,
										l = "forward" === r ? "deleteForward" : "delete",
										d = { sequence: s };
									if ("selection" == c) {
										const e = Array.from(a.getRanges()).map((e) =>
											t.editing.mapper.toModelRange(e),
										);
										d.selection = t.model.createSelection(e);
									} else d.unit = c;
									t.execute(l, d), e.scrollToTheSelection();
								},
								{ priority: "low" },
							),
							this.editor.plugins.has("UndoEditing") &&
								(this.listenTo(
									n,
									"delete",
									(e, n) => {
										this._undoOnBackspace &&
											"backward" == n.direction &&
											1 == n.sequence &&
											"codePoint" == n.unit &&
											((this._undoOnBackspace = !1),
											t.execute("undo"),
											n.preventDefault(),
											e.stop());
									},
									{ context: "$capture" },
								),
								this.listenTo(o, "change", () => {
									this._undoOnBackspace = !1;
								}));
					}
					requestUndoOnBackspace() {
						this.editor.plugins.has("UndoEditing") &&
							(this._undoOnBackspace = !0);
					}
				}
				class zp extends R {
					static get requires() {
						return [yp, Ip];
					}
					static get pluginName() {
						return "Typing";
					}
				}
				function Rp(t, e) {
					let n = t.start;
					return {
						text: Array.from(t.getItems()).reduce(
							(t, o) =>
								o.is("$text") || o.is("$textProxy")
									? t + o.data
									: ((n = e.createPositionAfter(o)), ""),
							"",
						),
						range: e.createRange(n, t.end),
					};
				}
				class Op extends B {
					constructor(t, e) {
						super(),
							(this.model = t),
							(this.testCallback = e),
							(this._hasMatch = !1),
							this.set("isEnabled", !0),
							this.on("change:isEnabled", () => {
								this.isEnabled
									? this._startListening()
									: (this.stopListening(t.document.selection),
										this.stopListening(t.document));
							}),
							this._startListening();
					}
					get hasMatch() {
						return this._hasMatch;
					}
					_startListening() {
						const t = this.model.document;
						this.listenTo(
							t.selection,
							"change:range",
							(e, { directChange: n }) => {
								n &&
									(t.selection.isCollapsed
										? this._evaluateTextBeforeSelection("selection")
										: this.hasMatch &&
											(this.fire("unmatched"), (this._hasMatch = !1)));
							},
						),
							this.listenTo(t, "change:data", (t, e) => {
								!e.isUndo &&
									e.isLocal &&
									this._evaluateTextBeforeSelection("data", { batch: e });
							});
					}
					_evaluateTextBeforeSelection(t, e = {}) {
						const n = this.model,
							o = n.document.selection,
							i = n.createRange(n.createPositionAt(o.focus.parent, 0), o.focus),
							{ text: r, range: s } = Rp(i, n),
							a = this.testCallback(r);
						if (
							(!a && this.hasMatch && this.fire("unmatched"),
							(this._hasMatch = !!a),
							a)
						) {
							const n = Object.assign(e, { text: r, range: s });
							"object" == typeof a && Object.assign(n, a),
								this.fire(`matched:${t}`, n);
						}
					}
				}
				class Mp extends R {
					constructor(t) {
						super(t), (this.attributes = new Set()), (this._overrideUid = null);
					}
					static get pluginName() {
						return "TwoStepCaretMovement";
					}
					init() {
						const t = this.editor,
							e = t.model,
							n = t.editing.view,
							o = t.locale,
							i = e.document.selection;
						this.listenTo(
							n.document,
							"arrowKey",
							(t, e) => {
								if (!i.isCollapsed) return;
								if (e.shiftKey || e.altKey || e.ctrlKey) return;
								const n = e.keyCode == Ji.arrowright,
									r = e.keyCode == Ji.arrowleft;
								if (!n && !r) return;
								const s = o.contentLanguageDirection;
								let a = !1;
								(a =
									("ltr" === s && n) || ("rtl" === s && r)
										? this._handleForwardMovement(e)
										: this._handleBackwardMovement(e)),
									!0 === a && t.stop();
							},
							{ context: "$text", priority: "highest" },
						),
							(this._isNextGravityRestorationSkipped = !1),
							this.listenTo(i, "change:range", (t, e) => {
								this._isNextGravityRestorationSkipped
									? (this._isNextGravityRestorationSkipped = !1)
									: this._isGravityOverridden &&
										((!e.directChange &&
											jp(i.getFirstPosition(), this.attributes)) ||
											this._restoreGravity());
							});
					}
					registerAttribute(t) {
						this.attributes.add(t);
					}
					_handleForwardMovement(t) {
						const e = this.attributes,
							n = this.editor.model.document.selection,
							o = n.getFirstPosition();
						return (
							!this._isGravityOverridden &&
							(!o.isAtStart || !Np(n, e)) && !!jp(o, e) &&
							(Lp(t), this._overrideGravity(), !0)
						);
					}
					_handleBackwardMovement(t) {
						const e = this.attributes,
							n = this.editor.model,
							o = n.document.selection,
							i = o.getFirstPosition();
						return this._isGravityOverridden
							? (Lp(t), this._restoreGravity(), Vp(n, e, i), !0)
							: i.isAtStart
								? !!Np(o, e) && (Lp(t), Vp(n, e, i), !0)
								: !!(function (t, e) {
										return jp(t.getShiftedBy(-1), e);
									})(i, e) &&
									(i.isAtEnd && !Np(o, e) && jp(i, e)
										? (Lp(t), Vp(n, e, i), !0)
										: ((this._isNextGravityRestorationSkipped = !0),
											this._overrideGravity(),
											!1));
					}
					get _isGravityOverridden() {
						return !!this._overrideUid;
					}
					_overrideGravity() {
						this._overrideUid = this.editor.model.change((t) =>
							t.overrideSelectionGravity(),
						);
					}
					_restoreGravity() {
						this.editor.model.change((t) => {
							t.restoreSelectionGravity(this._overrideUid),
								(this._overrideUid = null);
						});
					}
				}
				function Np(t, e) {
					for (const n of e) if (t.hasAttribute(n)) return !0;
					return !1;
				}
				function Vp(t, e, n) {
					const o = n.nodeBefore;
					t.change((t) => {
						o
							? t.setSelectionAttribute(o.getAttributes())
							: t.removeSelectionAttribute(e);
					});
				}
				function Lp(t) {
					t.preventDefault();
				}
				function jp(t, e) {
					const { nodeBefore: n, nodeAfter: o } = t;
					for (const t of e) {
						const e = n ? n.getAttribute(t) : void 0;
						if ((o ? o.getAttribute(t) : void 0) !== e) return !0;
					}
					return !1;
				}
				var Hp = /[\\^$.*+?()[\]{}|]/g,
					$p = RegExp(Hp.source);
				var qp = function (t) {
					return (t = zo(t)) && $p.test(t) ? t.replace(Hp, "\\$&") : t;
				};
				const Up = {
						copyright: { from: "(c)", to: "©" },
						registeredTrademark: { from: "(r)", to: "®" },
						trademark: { from: "(tm)", to: "™" },
						oneHalf: {
							from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i,
							to: [null, "½", null],
						},
						oneThird: {
							from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i,
							to: [null, "⅓", null],
						},
						twoThirds: {
							from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i,
							to: [null, "⅔", null],
						},
						oneForth: {
							from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i,
							to: [null, "¼", null],
						},
						threeQuarters: {
							from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i,
							to: [null, "¾", null],
						},
						lessThanOrEqual: { from: "<=", to: "≤" },
						greaterThanOrEqual: { from: ">=", to: "≥" },
						notEqual: { from: "!=", to: "≠" },
						arrowLeft: { from: "<-", to: "←" },
						arrowRight: { from: "->", to: "→" },
						horizontalEllipsis: { from: "...", to: "…" },
						enDash: { from: /(^| )(--)( )$/, to: [null, "–", null] },
						emDash: { from: /(^| )(---)( )$/, to: [null, "—", null] },
						quotesPrimary: { from: Qp('"'), to: [null, "“", null, "”"] },
						quotesSecondary: { from: Qp("'"), to: [null, "‘", null, "’"] },
						quotesPrimaryEnGb: { from: Qp("'"), to: [null, "‘", null, "’"] },
						quotesSecondaryEnGb: { from: Qp('"'), to: [null, "“", null, "”"] },
						quotesPrimaryPl: { from: Qp('"'), to: [null, "„", null, "”"] },
						quotesSecondaryPl: { from: Qp("'"), to: [null, "‚", null, "’"] },
					},
					Wp = {
						symbols: ["copyright", "registeredTrademark", "trademark"],
						mathematical: [
							"oneHalf",
							"oneThird",
							"twoThirds",
							"oneForth",
							"threeQuarters",
							"lessThanOrEqual",
							"greaterThanOrEqual",
							"notEqual",
							"arrowLeft",
							"arrowRight",
						],
						typography: ["horizontalEllipsis", "enDash", "emDash"],
						quotes: ["quotesPrimary", "quotesSecondary"],
					},
					Kp = ["symbols", "mathematical", "typography", "quotes"];
				function Gp(t) {
					return "string" == typeof t ? new RegExp(`(${qp(t)})$`) : t;
				}
				function Jp(t) {
					return "string" == typeof t
						? () => [t]
						: t instanceof Array
							? () => t
							: t;
				}
				function Yp(t) {
					return (t.textNode ? t.textNode : t.nodeAfter).getAttributes();
				}
				function Qp(t) {
					return new RegExp(`(^|\\s)(${t})([^${t}]*)(${t})$`);
				}
				function Xp(t, e, n, o) {
					return o.createRange(Zp(t, e, n, !0, o), Zp(t, e, n, !1, o));
				}
				function Zp(t, e, n, o, i) {
					let r = t.textNode || (o ? t.nodeBefore : t.nodeAfter),
						s = null;
					for (; r && r.getAttribute(e) == n; )
						(s = r), (r = o ? r.previousSibling : r.nextSibling);
					return s ? i.createPositionAt(s, o ? "before" : "after") : t;
				}
				function tg(t, e, n, o) {
					const i = t.editing.view,
						r = new Set();
					i.document.registerPostFixer((i) => {
						const s = t.model.document.selection;
						let a = !1;
						if (s.hasAttribute(e)) {
							const c = Xp(s.getFirstPosition(), e, s.getAttribute(e), t.model),
								l = t.editing.mapper.toViewRange(c);
							for (const t of l.getItems())
								t.is("element", n) &&
									!t.hasClass(o) &&
									(i.addClass(o, t), r.add(t), (a = !0));
						}
						return a;
					}),
						t.conversion.for("editingDowncast").add((t) => {
							function e() {
								i.change((t) => {
									for (const e of r.values()) t.removeClass(o, e), r.delete(e);
								});
							}
							t.on("insert", e, { priority: "highest" }),
								t.on("remove", e, { priority: "highest" }),
								t.on("attribute", e, { priority: "highest" }),
								t.on("selection", e, { priority: "highest" });
						});
				}
				function eg(t, e, n, o) {
					let i,
						r = null;
					"function" == typeof o
						? (i = o)
						: ((r = t.commands.get(o)),
							(i = () => {
								t.execute(o);
							})),
						t.model.document.on("change:data", (s, a) => {
							if ((r && !r.isEnabled) || !e.isEnabled) return;
							const c = ya(t.model.document.selection.getRanges());
							if (!c.isCollapsed) return;
							if (a.isUndo || !a.isLocal) return;
							const l = Array.from(t.model.document.differ.getChanges()),
								d = l[0];
							if (
								1 != l.length ||
								"insert" !== d.type ||
								"$text" != d.name ||
								1 != d.length
							)
								return;
							const u = d.position.parent;
							if (u.is("element", "codeBlock")) return;
							if (
								u.is("element", "listItem") &&
								"function" != typeof o &&
								!["numberedList", "bulletedList", "todoList"].includes(o)
							)
								return;
							if (r && !0 === r.value) return;
							const h = u.getChild(0),
								p = t.model.createRangeOn(h);
							if (!p.containsRange(c) && !c.end.isEqual(p.end)) return;
							const g = n.exec(h.data.substr(0, c.end.offset));
							g &&
								t.model.enqueueChange((e) => {
									const n = e.createPositionAt(u, 0),
										o = e.createPositionAt(u, g[0].length),
										r = new nc(n, o);
									if (!1 !== i({ match: g })) {
										e.remove(r);
										const n = t.model.document.selection.getFirstRange(),
											o = e.createRangeIn(u);
										!u.isEmpty ||
											o.isEqual(n) ||
											o.containsRange(n, !0) ||
											e.remove(u);
									}
									r.detach(),
										t.model.enqueueChange(() => {
											t.plugins.get("Delete").requestUndoOnBackspace();
										});
								});
						});
				}
				function ng(t, e, n, o) {
					let i, r;
					n instanceof RegExp ? (i = n) : (r = n),
						(r =
							r ||
							((t) => {
								let e;
								const n = [],
									o = [];
								for (; null !== (e = i.exec(t)) && !(e && e.length < 4); ) {
									let { index: t, 1: i, 2: r, 3: s } = e;
									const a = i + r + s;
									t += e[0].length - a.length;
									const c = [t, t + i.length],
										l = [
											t + i.length + r.length,
											t + i.length + r.length + s.length,
										];
									n.push(c),
										n.push(l),
										o.push([t + i.length, t + i.length + r.length]);
								}
								return { remove: n, format: o };
							})),
						t.model.document.on("change:data", (n, i) => {
							if (i.isUndo || !i.isLocal || !e.isEnabled) return;
							const s = t.model,
								a = s.document.selection;
							if (!a.isCollapsed) return;
							const c = Array.from(s.document.differ.getChanges()),
								l = c[0];
							if (
								1 != c.length ||
								"insert" !== l.type ||
								"$text" != l.name ||
								1 != l.length
							)
								return;
							const d = a.focus,
								u = d.parent,
								{ text: h, range: p } = (function (t, e) {
									let n = t.start;
									return {
										text: Array.from(t.getItems()).reduce(
											(t, o) =>
												(!o.is("$text") && !o.is("$textProxy")) ||
												o.getAttribute("code")
													? ((n = e.createPositionAfter(o)), "")
													: t + o.data,
											"",
										),
										range: e.createRange(n, t.end),
									};
								})(s.createRange(s.createPositionAt(u, 0), d), s),
								g = r(h),
								f = og(p.start, g.format, s),
								m = og(p.start, g.remove, s);
							f.length &&
								m.length &&
								s.enqueueChange((e) => {
									if (!1 !== o(e, f)) {
										for (const t of m.reverse()) e.remove(t);
										s.enqueueChange(() => {
											t.plugins.get("Delete").requestUndoOnBackspace();
										});
									}
								});
						});
				}
				function og(t, e, n) {
					return e
						.filter((t) => void 0 !== t[0] && void 0 !== t[1])
						.map((e) =>
							n.createRange(t.getShiftedBy(e[0]), t.getShiftedBy(e[1])),
						);
				}
				function ig(t, e) {
					return (n, o) => {
						if (!t.commands.get(e).isEnabled) return !1;
						const i = t.model.schema.getValidRanges(o, e);
						for (const t of i) n.setAttribute(e, !0, t);
						n.removeSelectionAttribute(e);
					};
				}
				class rg extends ds {
					constructor(t) {
						super(t);
						const e = this.document;
						function n(t) {
							return (n, o) => {
								o.preventDefault();
								const r = o.dropRange ? [o.dropRange] : null,
									s = new i(e, t);
								e.fire(s, {
									dataTransfer: o.dataTransfer,
									method: n.name,
									targetRanges: r,
									target: o.target,
								}),
									s.stop.called && o.stopPropagation();
							};
						}
						(this.domEventType = [
							"paste",
							"copy",
							"cut",
							"drop",
							"dragover",
							"dragstart",
							"dragend",
							"dragenter",
							"dragleave",
						]),
							this.listenTo(e, "paste", n("clipboardInput"), {
								priority: "low",
							}),
							this.listenTo(e, "drop", n("clipboardInput"), {
								priority: "low",
							}),
							this.listenTo(e, "dragover", n("dragging"), { priority: "low" });
					}
					onDomEvent(t) {
						const e = {
							dataTransfer: new Xs(
								"clipboardData" in t ? t.clipboardData : t.dataTransfer,
							),
						};
						("drop" != t.type && "dragover" != t.type) ||
							(e.dropRange = (function (t, e) {
								const n = e.target.ownerDocument,
									o = e.clientX,
									i = e.clientY;
								let r;
								n.caretRangeFromPoint && n.caretRangeFromPoint(o, i)
									? (r = n.caretRangeFromPoint(o, i))
									: e.rangeParent &&
										((r = n.createRange()),
										r.setStart(e.rangeParent, e.rangeOffset),
										r.collapse(!0));
								if (r) return t.domConverter.domRangeToView(r);
								return null;
							})(this.view, t)),
							this.fire(t.type, t, e);
					}
				}
				const sg = ["figcaption", "li"];
				function ag(t) {
					let e = "";
					if (t.is("$text") || t.is("$textProxy")) e = t.data;
					else if (t.is("element", "img") && t.hasAttribute("alt"))
						e = t.getAttribute("alt");
					else if (t.is("element", "br")) e = "\n";
					else {
						let n = null;
						for (const o of t.getChildren()) {
							const t = ag(o);
							n &&
								(n.is("containerElement") || o.is("containerElement")) &&
								(sg.includes(n.name) || sg.includes(o.name)
									? (e += "\n")
									: (e += "\n\n")),
								(e += t),
								(n = o);
						}
					}
					return e;
				}
				class cg extends R {
					static get pluginName() {
						return "ClipboardPipeline";
					}
					init() {
						this.editor.editing.view.addObserver(rg),
							this._setupPasteDrop(),
							this._setupCopyCut();
					}
					_setupPasteDrop() {
						const t = this.editor,
							e = t.model,
							n = t.editing.view,
							o = n.document;
						this.listenTo(
							o,
							"clipboardInput",
							(e) => {
								t.isReadOnly && e.stop();
							},
							{ priority: "highest" },
						),
							this.listenTo(
								o,
								"clipboardInput",
								(t, e) => {
									const o = e.dataTransfer;
									let r;
									if (e.content) r = e.content;
									else {
										let t = "";
										o.getData("text/html")
											? (t = (function (t) {
													return t
														.replace(
															/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g,
															(t, e) => (1 == e.length ? " " : e),
														)
														.replace(/<!--[\s\S]*?-->/g, "");
												})(o.getData("text/html")))
											: o.getData("text/plain") &&
												(((s = (s = o.getData("text/plain"))
													.replace(/</g, "&lt;")
													.replace(/>/g, "&gt;")
													.replace(/\r?\n\r?\n/g, "</p><p>")
													.replace(/\r?\n/g, "<br>")
													.replace(/^\s/, "&nbsp;")
													.replace(/\s$/, "&nbsp;")
													.replace(/\s\s/g, " &nbsp;")).includes("</p><p>") ||
													s.includes("<br>")) &&
													(s = `<p>${s}</p>`),
												(t = s)),
											(r = this.editor.data.htmlProcessor.toView(t));
									}
									var s;
									const a = new i(this, "inputTransformation");
									this.fire(a, {
										content: r,
										dataTransfer: o,
										targetRanges: e.targetRanges,
										method: e.method,
									}),
										a.stop.called && t.stop(),
										n.scrollToTheSelection();
								},
								{ priority: "low" },
							),
							this.listenTo(
								this,
								"inputTransformation",
								(t, n) => {
									if (n.content.isEmpty) return;
									const o = this.editor.data.toModel(
										n.content,
										"$clipboardHolder",
									);
									0 != o.childCount &&
										(t.stop(),
										e.change(() => {
											this.fire("contentInsertion", {
												content: o,
												method: n.method,
												dataTransfer: n.dataTransfer,
												targetRanges: n.targetRanges,
											});
										}));
								},
								{ priority: "low" },
							),
							this.listenTo(
								this,
								"contentInsertion",
								(t, n) => {
									n.resultRange = e.insertContent(n.content);
								},
								{ priority: "low" },
							);
					}
					_setupCopyCut() {
						const t = this.editor,
							e = t.model.document,
							n = t.editing.view.document,
							o = (o, i) => {
								const r = i.dataTransfer;
								i.preventDefault();
								const s = t.data.toView(
									t.model.getSelectedContent(e.selection),
								);
								n.fire("clipboardOutput", {
									dataTransfer: r,
									content: s,
									method: o.name,
								});
							};
						this.listenTo(n, "copy", o, { priority: "low" }),
							this.listenTo(
								n,
								"cut",
								(e, n) => {
									t.isReadOnly ? n.preventDefault() : o(e, n);
								},
								{ priority: "low" },
							),
							this.listenTo(
								n,
								"clipboardOutput",
								(n, o) => {
									o.content.isEmpty ||
										(o.dataTransfer.setData(
											"text/html",
											this.editor.data.htmlProcessor.toData(o.content),
										),
										o.dataTransfer.setData("text/plain", ag(o.content))),
										"cut" == o.method && t.model.deleteContent(e.selection);
								},
								{ priority: "low" },
							);
					}
				}
				function* lg(t, e) {
					for (const n of e)
						n && t.getAttributeProperties(n[0]).copyOnEnter && (yield n);
				}
				class dg extends M {
					execute() {
						const t = this.editor.model,
							e = t.document;
						t.change((n) => {
							!(function (t, e, n, o) {
								const i = n.isCollapsed,
									r = n.getFirstRange(),
									s = r.start.parent,
									a = r.end.parent;
								if (o.isLimit(s) || o.isLimit(a))
									return void (i || s != a || t.deleteContent(n));
								if (i) {
									const t = lg(e.model.schema, n.getAttributes());
									ug(e, r.start), e.setSelectionAttribute(t);
								} else {
									const o = !(r.start.isAtStart && r.end.isAtEnd),
										i = s == a;
									t.deleteContent(n, { leaveUnmerged: o }),
										o && (i ? ug(e, n.focus) : e.setSelection(a, 0));
								}
							})(this.editor.model, n, e.selection, t.schema),
								this.fire("afterExecute", { writer: n });
						});
					}
				}
				function ug(t, e) {
					t.split(e), t.setSelection(e.parent.nextSibling, 0);
				}
				const hg = {
					insertParagraph: { isSoft: !1 },
					insertLineBreak: { isSoft: !0 },
				};
				class pg extends as {
					constructor(t) {
						super(t);
						const e = this.document;
						e.on("beforeinput", (n, o) => {
							if (!this.isEnabled) return;
							const i = o.domEvent,
								r = hg[o.inputType];
							if (!r) return;
							const s = new Ti(e, "enter", o.targetRanges[0]);
							e.fire(s, new ls(t, i, { isSoft: r.isSoft })),
								s.stop.called && n.stop();
						});
					}
					observe() {}
				}
				class gg extends R {
					static get pluginName() {
						return "Enter";
					}
					init() {
						const t = this.editor,
							e = t.editing.view,
							n = e.document;
						e.addObserver(pg),
							t.commands.add("enter", new dg(t)),
							this.listenTo(
								n,
								"enter",
								(o, i) => {
									n.isComposing || i.preventDefault(),
										i.isSoft || (t.execute("enter"), e.scrollToTheSelection());
								},
								{ priority: "low" },
							);
					}
				}
				const fg = "ck-widget_selected";
				function mg(t) {
					return !!t.is("element") && !!t.getCustomProperty("widget");
				}
				function kg(t) {
					const e = t.getCustomProperty("widgetLabel");
					return e ? ("function" == typeof e ? e() : e) : "";
				}
				const bg = "widget-type-around";
				function wg(t, e, n) {
					return !!t && mg(t) && !n.isInline(e);
				}
				function Ag(t) {
					return t.getAttribute(bg);
				}
				var _g = n(39),
					Cg = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(_g.a, Cg), _g.a.locals;
				const vg = ["before", "after"],
					yg = new DOMParser().parseFromString(
						'<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>',
						"image/svg+xml",
					).firstChild,
					xg = "ck-widget__type-around_disabled";
				class Dg extends R {
					constructor(t) {
						super(t), (this._currentFakeCaretModelElement = null);
					}
					static get pluginName() {
						return "WidgetTypeAround";
					}
					static get requires() {
						return [gg, Ip];
					}
					init() {
						const t = this.editor,
							e = t.editing.view;
						this.on("change:isEnabled", (n, o, i) => {
							e.change((t) => {
								for (const n of e.document.roots)
									i ? t.removeClass(xg, n) : t.addClass(xg, n);
							}),
								i ||
									t.model.change((t) => {
										t.removeSelectionAttribute(bg);
									});
						}),
							this._enableTypeAroundUIInjection(),
							this._enableInsertingParagraphsOnButtonClick(),
							this._enableInsertingParagraphsOnEnterKeypress(),
							this._enableInsertingParagraphsOnTypingKeystroke(),
							this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(),
							this._enableDeleteIntegration(),
							this._enableInsertContentIntegration(),
							this._enableInsertObjectIntegration(),
							this._enableDeleteContentIntegration();
					}
					destroy() {
						super.destroy(), (this._currentFakeCaretModelElement = null);
					}
					_insertParagraph(t, e) {
						const n = this.editor,
							o = n.editing.view,
							i = n.model.schema.getAttributesWithProperty(
								t,
								"copyOnReplace",
								!0,
							);
						n.execute("insertParagraph", {
							position: n.model.createPositionAt(t, e),
							attributes: i,
						}),
							o.focus(),
							o.scrollToTheSelection();
					}
					_listenToIfEnabled(t, e, n, o) {
						this.listenTo(
							t,
							e,
							(...t) => {
								this.isEnabled && n(...t);
							},
							o,
						);
					}
					_insertParagraphAccordingToFakeCaretPosition() {
						const t = this.editor.model.document.selection,
							e = Ag(t);
						if (!e) return !1;
						const n = t.getSelectedElement();
						return this._insertParagraph(n, e), !0;
					}
					_enableTypeAroundUIInjection() {
						const t = this.editor,
							e = t.model.schema,
							n = t.locale.t,
							o = {
								before: n("Insert paragraph before block"),
								after: n("Insert paragraph after block"),
							};
						t.editing.downcastDispatcher.on(
							"insert",
							(t, n, i) => {
								const r = i.mapper.toViewElement(n.item);
								wg(r, n.item, e) &&
									(function (t, e, n) {
										const o = t.createUIElement(
											"div",
											{ class: "ck ck-reset_all ck-widget__type-around" },
											function (t) {
												const n = this.toDomElement(t);
												return (
													(function (t, e) {
														for (const n of vg) {
															const o = new Wd({
																tag: "div",
																attributes: {
																	class: [
																		"ck",
																		"ck-widget__type-around__button",
																		`ck-widget__type-around__button_${n}`,
																	],
																	title: e[n],
																},
																children: [t.ownerDocument.importNode(yg, !0)],
															});
															t.appendChild(o.render());
														}
													})(n, e),
													(function (t) {
														const e = new Wd({
															tag: "div",
															attributes: {
																class: [
																	"ck",
																	"ck-widget__type-around__fake-caret",
																],
															},
														});
														t.appendChild(e.render());
													})(n),
													n
												);
											},
										);
										t.insert(t.createPositionAt(n, "end"), o);
									})(i.writer, o, r);
							},
							{ priority: "low" },
						);
					}
					_enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
						const t = this.editor,
							e = t.model,
							n = e.document.selection,
							o = e.schema,
							i = t.editing.view;
						function r(t) {
							return `ck-widget_type-around_show-fake-caret_${t}`;
						}
						this._listenToIfEnabled(
							i.document,
							"arrowKey",
							(t, e) => {
								this._handleArrowKeyPress(t, e);
							},
							{ context: [mg, "$text"], priority: "high" },
						),
							this._listenToIfEnabled(n, "change:range", (e, n) => {
								n.directChange &&
									t.model.change((t) => {
										t.removeSelectionAttribute(bg);
									});
							}),
							this._listenToIfEnabled(e.document, "change:data", () => {
								const e = n.getSelectedElement();
								if (e) {
									if (wg(t.editing.mapper.toViewElement(e), e, o)) return;
								}
								t.model.change((t) => {
									t.removeSelectionAttribute(bg);
								});
							}),
							this._listenToIfEnabled(
								t.editing.downcastDispatcher,
								"selection",
								(t, e, n) => {
									const i = n.writer;
									if (this._currentFakeCaretModelElement) {
										const t = n.mapper.toViewElement(
											this._currentFakeCaretModelElement,
										);
										t &&
											(i.removeClass(vg.map(r), t),
											(this._currentFakeCaretModelElement = null));
									}
									const s = e.selection.getSelectedElement();
									if (!s) return;
									const a = n.mapper.toViewElement(s);
									if (!wg(a, s, o)) return;
									const c = Ag(e.selection);
									c &&
										(i.addClass(r(c), a),
										(this._currentFakeCaretModelElement = s));
								},
							),
							this._listenToIfEnabled(
								t.ui.focusTracker,
								"change:isFocused",
								(e, n, o) => {
									o ||
										t.model.change((t) => {
											t.removeSelectionAttribute(bg);
										});
								},
							);
					}
					_handleArrowKeyPress(t, e) {
						const n = this.editor,
							o = n.model,
							i = o.document.selection,
							r = o.schema,
							s = n.editing.view,
							a = (function (t, e) {
								const n = tr(t, e);
								return "down" === n || "right" === n;
							})(e.keyCode, n.locale.contentLanguageDirection),
							c = s.document.selection.getSelectedElement();
						let l;
						wg(c, n.editing.mapper.toModelElement(c), r)
							? (l = this._handleArrowKeyPressOnSelectedWidget(a))
							: i.isCollapsed
								? (l = this._handleArrowKeyPressWhenSelectionNextToAWidget(a))
								: e.shiftKey ||
									(l = this._handleArrowKeyPressWhenNonCollapsedSelection(a)),
							l && (e.preventDefault(), t.stop());
					}
					_handleArrowKeyPressOnSelectedWidget(t) {
						const e = this.editor.model,
							n = Ag(e.document.selection);
						return e.change((e) => {
							if (!n)
								return e.setSelectionAttribute(bg, t ? "after" : "before"), !0;
							if (!(n === (t ? "after" : "before")))
								return e.removeSelectionAttribute(bg), !0;
							return !1;
						});
					}
					_handleArrowKeyPressWhenSelectionNextToAWidget(t) {
						const e = this.editor,
							n = e.model,
							o = n.schema,
							i = e.plugins.get("Widget"),
							r = i._getObjectElementNextToSelection(t);
						return (
							!!wg(e.editing.mapper.toViewElement(r), r, o) &&
							(n.change((e) => {
								i._setSelectionOverElement(r),
									e.setSelectionAttribute(bg, t ? "before" : "after");
							}),
							!0)
						);
					}
					_handleArrowKeyPressWhenNonCollapsedSelection(t) {
						const e = this.editor,
							n = e.model,
							o = n.schema,
							i = e.editing.mapper,
							r = n.document.selection,
							s = t
								? r.getLastPosition().nodeBefore
								: r.getFirstPosition().nodeAfter;
						return (
							!!wg(i.toViewElement(s), s, o) &&
							(n.change((e) => {
								e.setSelection(s, "on"),
									e.setSelectionAttribute(bg, t ? "after" : "before");
							}),
							!0)
						);
					}
					_enableInsertingParagraphsOnButtonClick() {
						const t = this.editor,
							e = t.editing.view;
						this._listenToIfEnabled(e.document, "mousedown", (n, o) => {
							const i = o.domTarget.closest(".ck-widget__type-around__button");
							if (!i) return;
							const r = (function (t) {
									return t.classList.contains(
										"ck-widget__type-around__button_before",
									)
										? "before"
										: "after";
								})(i),
								s = (function (t, e) {
									const n = t.closest(".ck-widget");
									return e.mapDomToView(n);
								})(i, e.domConverter),
								a = t.editing.mapper.toModelElement(s);
							this._insertParagraph(a, r), o.preventDefault(), n.stop();
						});
					}
					_enableInsertingParagraphsOnEnterKeypress() {
						const t = this.editor,
							e = t.model.document.selection,
							n = t.editing.view;
						this._listenToIfEnabled(
							n.document,
							"enter",
							(n, o) => {
								if ("atTarget" != n.eventPhase) return;
								const i = e.getSelectedElement(),
									r = t.editing.mapper.toViewElement(i),
									s = t.model.schema;
								let a;
								this._insertParagraphAccordingToFakeCaretPosition()
									? (a = !0)
									: wg(r, i, s) &&
										(this._insertParagraph(i, o.isSoft ? "before" : "after"),
										(a = !0)),
									a && (o.preventDefault(), n.stop());
							},
							{ context: mg },
						);
					}
					_enableInsertingParagraphsOnTypingKeystroke() {
						const t = this.editor.editing.view.document;
						this._listenToIfEnabled(
							t,
							"insertText",
							(e, n) => {
								this._insertParagraphAccordingToFakeCaretPosition() &&
									(n.selection = t.selection);
							},
							{ priority: "high" },
						),
							Ui.isAndroid
								? this._listenToIfEnabled(t, "keydown", (t, e) => {
										229 == e.keyCode &&
											this._insertParagraphAccordingToFakeCaretPosition();
									})
								: this._listenToIfEnabled(
										t,
										"compositionstart",
										() => {
											this._insertParagraphAccordingToFakeCaretPosition();
										},
										{ priority: "high" },
									);
					}
					_enableDeleteIntegration() {
						const t = this.editor,
							e = t.editing.view,
							n = t.model,
							o = n.schema;
						this._listenToIfEnabled(
							e.document,
							"delete",
							(e, i) => {
								if ("atTarget" != e.eventPhase) return;
								const r = Ag(n.document.selection);
								if (!r) return;
								const s = i.direction,
									a = n.document.selection.getSelectedElement(),
									c = "forward" == s;
								if (("before" === r) === c)
									t.execute("delete", {
										selection: n.createSelection(a, "on"),
									});
								else {
									const e = o.getNearestSelectionRange(
										n.createPositionAt(a, r),
										s,
									);
									if (e)
										if (e.isCollapsed) {
											const i = n.createSelection(e.start);
											if (
												(n.modifySelection(i, { direction: s }),
												i.focus.isEqual(e.start))
											) {
												const t = (function (t, e) {
													let n = e;
													for (const o of e.getAncestors({ parentFirst: !0 })) {
														if (o.childCount > 1 || t.isLimit(o)) break;
														n = o;
													}
													return n;
												})(o, e.start.parent);
												n.deleteContent(n.createSelection(t, "on"), {
													doNotAutoparagraph: !0,
												});
											} else
												n.change((n) => {
													n.setSelection(e),
														t.execute(c ? "deleteForward" : "delete");
												});
										} else
											n.change((n) => {
												n.setSelection(e),
													t.execute(c ? "deleteForward" : "delete");
											});
								}
								i.preventDefault(), e.stop();
							},
							{ context: mg },
						);
					}
					_enableInsertContentIntegration() {
						const t = this.editor,
							e = this.editor.model,
							n = e.document.selection;
						this._listenToIfEnabled(
							t.model,
							"insertContent",
							(t, [o, i]) => {
								if (i && !i.is("documentSelection")) return;
								const r = Ag(n);
								return r
									? (t.stop(),
										e.change((t) => {
											const i = n.getSelectedElement(),
												s = e.createPositionAt(i, r),
												a = t.createSelection(s),
												c = e.insertContent(o, a);
											return t.setSelection(a), c;
										}))
									: void 0;
							},
							{ priority: "high" },
						);
					}
					_enableInsertObjectIntegration() {
						const t = this.editor,
							e = this.editor.model.document.selection;
						this._listenToIfEnabled(
							t.model,
							"insertObject",
							(t, n) => {
								const [, o, , i = {}] = n;
								if (o && !o.is("documentSelection")) return;
								const r = Ag(e);
								r && ((i.findOptimalPosition = r), (n[3] = i));
							},
							{ priority: "high" },
						);
					}
					_enableDeleteContentIntegration() {
						const t = this.editor,
							e = this.editor.model.document.selection;
						this._listenToIfEnabled(
							t.model,
							"deleteContent",
							(t, [n]) => {
								if (n && !n.is("documentSelection")) return;
								Ag(e) && t.stop();
							},
							{ priority: "high" },
						);
					}
				}
				function Eg(t) {
					const e = t.model;
					return (n, o) => {
						const i = o.keyCode == Ji.arrowup,
							r = o.keyCode == Ji.arrowdown,
							s = o.shiftKey,
							a = e.document.selection;
						if (!i && !r) return;
						const c = r;
						if (
							s &&
							(function (t, e) {
								return !t.isCollapsed && t.isBackward == e;
							})(a, c)
						)
							return;
						const l = (function (t, e, n) {
							const o = t.model;
							if (n) {
								const t = e.isCollapsed ? e.focus : e.getLastPosition(),
									n = Sg(o, t, "forward");
								if (!n) return null;
								const i = o.createRange(t, n),
									r = Bg(o.schema, i, "backward");
								return r ? o.createRange(t, r) : null;
							}
							{
								const t = e.isCollapsed ? e.focus : e.getFirstPosition(),
									n = Sg(o, t, "backward");
								if (!n) return null;
								const i = o.createRange(n, t),
									r = Bg(o.schema, i, "forward");
								return r ? o.createRange(r, t) : null;
							}
						})(t, a, c);
						if (l) {
							if (l.isCollapsed) {
								if (a.isCollapsed) return;
								if (s) return;
							}
							(l.isCollapsed ||
								(function (t, e, n) {
									const o = t.model,
										i = t.view.domConverter;
									if (n) {
										const t = o.createSelection(e.start);
										o.modifySelection(t),
											t.focus.isAtEnd ||
												e.start.isEqual(t.focus) ||
												(e = o.createRange(t.focus, e.end));
									}
									const r = t.mapper.toViewRange(e),
										s = i.viewRangeToDom(r),
										a = aa.getDomRangeRects(s);
									let c;
									for (const t of a)
										if (void 0 !== c) {
											if (Math.round(t.top) >= c) return !1;
											c = Math.max(c, Math.round(t.bottom));
										} else c = Math.round(t.bottom);
									return !0;
								})(t, l, c)) &&
								(e.change((t) => {
									const n = c ? l.end : l.start;
									if (s) {
										const o = e.createSelection(a.anchor);
										o.setFocus(n), t.setSelection(o);
									} else t.setSelection(n);
								}),
								n.stop(),
								o.preventDefault(),
								o.stopPropagation());
						}
					};
				}
				function Sg(t, e, n) {
					const o = t.schema,
						i = t.createRangeIn(e.root),
						r = "forward" == n ? "elementStart" : "elementEnd";
					for (const { previousPosition: t, item: s, type: a } of i.getWalker({
						startPosition: e,
						direction: n,
					})) {
						if (o.isLimit(s) && !o.isInline(s)) return t;
						if (a == r && o.isBlock(s)) return null;
					}
					return null;
				}
				function Bg(t, e, n) {
					const o = "backward" == n ? e.end : e.start;
					if (t.checkChild(o, "$text")) return o;
					for (const { nextPosition: o } of e.getWalker({ direction: n }))
						if (t.checkChild(o, "$text")) return o;
					return null;
				}
				var Tg = n(40),
					Pg = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Tg.a, Pg), Tg.a.locals;
				class Fg extends R {
					static get pluginName() {
						return "Widget";
					}
					static get requires() {
						return [Dg, Ip];
					}
					init() {
						const t = this.editor,
							e = t.editing.view,
							n = e.document;
						(this._previouslySelected = new Set()),
							this.editor.editing.downcastDispatcher.on(
								"selection",
								(e, n, o) => {
									const i = o.writer,
										r = n.selection;
									if (r.isCollapsed) return;
									const s = r.getSelectedElement();
									if (!s) return;
									const a = t.editing.mapper.toViewElement(s);
									mg(a) &&
										o.consumable.consume(r, "selection") &&
										i.setSelection(i.createRangeOn(a), {
											fake: !0,
											label: kg(a),
										});
								},
							),
							this.editor.editing.downcastDispatcher.on(
								"selection",
								(t, e, n) => {
									this._clearPreviouslySelectedWidgets(n.writer);
									const o = n.writer,
										i = o.document.selection;
									let r = null;
									for (const t of i.getRanges())
										for (const e of t) {
											const t = e.item;
											mg(t) &&
												!Ig(t, r) &&
												(o.addClass(fg, t),
												this._previouslySelected.add(t),
												(r = t));
										}
								},
								{ priority: "low" },
							),
							e.addObserver(Pd),
							this.listenTo(n, "mousedown", (...t) => this._onMousedown(...t)),
							this.listenTo(
								n,
								"arrowKey",
								(...t) => {
									this._handleSelectionChangeOnArrowKeyPress(...t);
								},
								{ context: [mg, "$text"] },
							),
							this.listenTo(
								n,
								"arrowKey",
								(...t) => {
									this._preventDefaultOnArrowKeyPress(...t);
								},
								{ context: "$root" },
							),
							this.listenTo(n, "arrowKey", Eg(this.editor.editing), {
								context: "$text",
							}),
							this.listenTo(
								n,
								"delete",
								(t, e) => {
									this._handleDelete("forward" == e.direction) &&
										(e.preventDefault(), t.stop());
								},
								{ context: "$root" },
							);
					}
					_onMousedown(t, e) {
						const n = this.editor,
							o = n.editing.view,
							i = o.document;
						let r = e.target;
						if (
							(function (t) {
								let e = t;
								for (; e; ) {
									if (e.is("editableElement") && !e.is("rootElement"))
										return !0;
									if (mg(e)) return !1;
									e = e.parent;
								}
								return !1;
							})(r)
						) {
							if ((Ui.isSafari || Ui.isGecko) && e.domEvent.detail >= 3) {
								const t = n.editing.mapper,
									o = r.is("attributeElement")
										? r.findAncestor((t) => !t.is("attributeElement"))
										: r,
									i = t.toModelElement(o);
								e.preventDefault(),
									this.editor.model.change((t) => {
										t.setSelection(i, "in");
									});
							}
							return;
						}
						if (!mg(r) && ((r = r.findAncestor(mg)), !r)) return;
						Ui.isAndroid && e.preventDefault(), i.isFocused || o.focus();
						const s = n.editing.mapper.toModelElement(r);
						this._setSelectionOverElement(s);
					}
					_handleSelectionChangeOnArrowKeyPress(t, e) {
						const n = e.keyCode,
							o = this.editor.model,
							i = o.schema,
							r = o.document.selection,
							s = r.getSelectedElement(),
							a = tr(n, this.editor.locale.contentLanguageDirection),
							c = "down" == a || "right" == a,
							l = "up" == a || "down" == a;
						if (s && i.isObject(s)) {
							const n = c ? r.getLastPosition() : r.getFirstPosition(),
								s = i.getNearestSelectionRange(n, c ? "forward" : "backward");
							return void (
								s &&
								(o.change((t) => {
									t.setSelection(s);
								}),
								e.preventDefault(),
								t.stop())
							);
						}
						if (!r.isCollapsed && !e.shiftKey) {
							const n = r.getFirstPosition(),
								s = r.getLastPosition(),
								a = n.nodeAfter,
								l = s.nodeBefore;
							return void (
								((a && i.isObject(a)) || (l && i.isObject(l))) &&
								(o.change((t) => {
									t.setSelection(c ? s : n);
								}),
								e.preventDefault(),
								t.stop())
							);
						}
						if (!r.isCollapsed) return;
						const d = this._getObjectElementNextToSelection(c);
						if (d && i.isObject(d)) {
							if (i.isInline(d) && l) return;
							this._setSelectionOverElement(d), e.preventDefault(), t.stop();
						}
					}
					_preventDefaultOnArrowKeyPress(t, e) {
						const n = this.editor.model,
							o = n.schema,
							i = n.document.selection.getSelectedElement();
						i && o.isObject(i) && (e.preventDefault(), t.stop());
					}
					_handleDelete(t) {
						if (this.editor.isReadOnly) return;
						const e = this.editor.model.document.selection;
						if (!e.isCollapsed) return;
						const n = this._getObjectElementNextToSelection(t);
						return n
							? (this.editor.model.change((t) => {
									let o = e.anchor.parent;
									for (; o.isEmpty; ) {
										const e = o;
										(o = e.parent), t.remove(e);
									}
									this._setSelectionOverElement(n);
								}),
								!0)
							: void 0;
					}
					_setSelectionOverElement(t) {
						this.editor.model.change((e) => {
							e.setSelection(e.createRangeOn(t));
						});
					}
					_getObjectElementNextToSelection(t) {
						const e = this.editor.model,
							n = e.schema,
							o = e.document.selection,
							i = e.createSelection(o);
						if (
							(e.modifySelection(i, { direction: t ? "forward" : "backward" }),
							i.isEqual(o))
						)
							return null;
						const r = t ? i.focus.nodeBefore : i.focus.nodeAfter;
						return r && n.isObject(r) ? r : null;
					}
					_clearPreviouslySelectedWidgets(t) {
						for (const e of this._previouslySelected) t.removeClass(fg, e);
						this._previouslySelected.clear();
					}
				}
				function Ig(t, e) {
					return !!e && Array.from(t.getAncestors()).includes(e);
				}
				var zg = function (t, e, n) {
						var o = !0,
							i = !0;
						if ("function" != typeof t)
							throw new TypeError("Expected a function");
						return (
							C(n) &&
								((o = "leading" in n ? !!n.leading : o),
								(i = "trailing" in n ? !!n.trailing : i)),
							ys(t, e, { leading: o, maxWait: e, trailing: i })
						);
					},
					Rg = n(41),
					Og = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Rg.a, Og), Rg.a.locals;
				class Mg extends R {
					static get pluginName() {
						return "DragDrop";
					}
					static get requires() {
						return [cg, Fg];
					}
					init() {
						const t = this.editor,
							e = t.editing.view;
						(this._draggedRange = null),
							(this._draggingUid = ""),
							(this._draggableElement = null),
							(this._updateDropMarkerThrottled = zg(
								(t) => this._updateDropMarker(t),
								40,
							)),
							(this._removeDropMarkerDelayed = Lg(
								() => this._removeDropMarker(),
								40,
							)),
							(this._clearDraggableAttributesDelayed = Lg(
								() => this._clearDraggableAttributes(),
								40,
							)),
							e.addObserver(rg),
							e.addObserver(Pd),
							this._setupDragging(),
							this._setupContentInsertionIntegration(),
							this._setupClipboardInputIntegration(),
							this._setupDropMarker(),
							this._setupDraggableAttributeHandling(),
							this.listenTo(t, "change:isReadOnly", (t, e, n) => {
								n
									? this.forceDisabled("readOnlyMode")
									: this.clearForceDisabled("readOnlyMode");
							}),
							this.on("change:isEnabled", (t, e, n) => {
								n || this._finalizeDragging(!1);
							}),
							Ui.isAndroid && this.forceDisabled("noAndroidSupport");
					}
					destroy() {
						return (
							this._draggedRange &&
								(this._draggedRange.detach(), (this._draggedRange = null)),
							this._updateDropMarkerThrottled.cancel(),
							this._removeDropMarkerDelayed.cancel(),
							this._clearDraggableAttributesDelayed.cancel(),
							super.destroy()
						);
					}
					_setupDragging() {
						const t = this.editor,
							e = t.model,
							n = e.document,
							o = t.editing.view,
							i = o.document;
						this.listenTo(
							i,
							"dragstart",
							(o, r) => {
								const a = n.selection;
								if (r.target && r.target.is("editableElement"))
									return void r.preventDefault();
								const c = r.target ? jg(r.target) : null;
								if (c) {
									const n = t.editing.mapper.toModelElement(c);
									(this._draggedRange = nc.fromRange(e.createRangeOn(n))),
										t.plugins.has("WidgetToolbarRepository") &&
											t.plugins
												.get("WidgetToolbarRepository")
												.forceDisabled("dragDrop");
								} else if (!i.selection.isCollapsed) {
									const t = i.selection.getSelectedElement();
									(t && mg(t)) ||
										(this._draggedRange = nc.fromRange(a.getFirstRange()));
								}
								if (!this._draggedRange) return void r.preventDefault();
								(this._draggingUid = s()),
									(r.dataTransfer.effectAllowed = this.isEnabled
										? "copyMove"
										: "copy"),
									r.dataTransfer.setData(
										"application/ckeditor5-dragging-uid",
										this._draggingUid,
									);
								const l = e.createSelection(this._draggedRange.toRange()),
									d = t.data.toView(e.getSelectedContent(l));
								i.fire("clipboardOutput", {
									dataTransfer: r.dataTransfer,
									content: d,
									method: "dragstart",
								}),
									this.isEnabled ||
										(this._draggedRange.detach(),
										(this._draggedRange = null),
										(this._draggingUid = ""));
							},
							{ priority: "low" },
						),
							this.listenTo(
								i,
								"dragend",
								(t, e) => {
									this._finalizeDragging(
										!e.dataTransfer.isCanceled &&
											"move" == e.dataTransfer.dropEffect,
									);
								},
								{ priority: "low" },
							),
							this.listenTo(i, "dragenter", () => {
								this.isEnabled && o.focus();
							}),
							this.listenTo(i, "dragleave", () => {
								this._removeDropMarkerDelayed();
							}),
							this.listenTo(
								i,
								"dragging",
								(e, n) => {
									if (!this.isEnabled)
										return void (n.dataTransfer.dropEffect = "none");
									this._removeDropMarkerDelayed.cancel();
									const o = Ng(t, n.targetRanges, n.target);
									this._draggedRange || (n.dataTransfer.dropEffect = "copy"),
										Ui.isGecko ||
											("copy" == n.dataTransfer.effectAllowed
												? (n.dataTransfer.dropEffect = "copy")
												: ["all", "copyMove"].includes(
														n.dataTransfer.effectAllowed,
													) && (n.dataTransfer.dropEffect = "move")),
										o && this._updateDropMarkerThrottled(o);
								},
								{ priority: "low" },
							);
					}
					_setupClipboardInputIntegration() {
						const t = this.editor,
							e = t.editing.view.document;
						this.listenTo(
							e,
							"clipboardInput",
							(e, n) => {
								if ("drop" != n.method) return;
								const o = Ng(t, n.targetRanges, n.target);
								if ((this._removeDropMarker(), !o))
									return this._finalizeDragging(!1), void e.stop();
								this._draggedRange &&
									this._draggingUid !=
										n.dataTransfer.getData(
											"application/ckeditor5-dragging-uid",
										) &&
									(this._draggedRange.detach(),
									(this._draggedRange = null),
									(this._draggingUid = ""));
								if (
									"move" == Vg(n.dataTransfer) &&
									this._draggedRange &&
									this._draggedRange.containsRange(o, !0)
								)
									return this._finalizeDragging(!1), void e.stop();
								n.targetRanges = [t.editing.mapper.toViewRange(o)];
							},
							{ priority: "high" },
						);
					}
					_setupContentInsertionIntegration() {
						const t = this.editor.plugins.get(cg);
						t.on(
							"contentInsertion",
							(t, e) => {
								if (!this.isEnabled || "drop" !== e.method) return;
								const n = e.targetRanges.map((t) =>
									this.editor.editing.mapper.toModelRange(t),
								);
								this.editor.model.change((t) => t.setSelection(n));
							},
							{ priority: "high" },
						),
							t.on(
								"contentInsertion",
								(t, e) => {
									if (!this.isEnabled || "drop" !== e.method) return;
									const n = "move" == Vg(e.dataTransfer),
										o = !e.resultRange || !e.resultRange.isCollapsed;
									this._finalizeDragging(o && n);
								},
								{ priority: "lowest" },
							);
					}
					_setupDraggableAttributeHandling() {
						const t = this.editor,
							e = t.editing.view,
							n = e.document;
						this.listenTo(n, "mousedown", (o, i) => {
							if (Ui.isAndroid || !i) return;
							this._clearDraggableAttributesDelayed.cancel();
							let r = jg(i.target);
							if (
								Ui.isBlink &&
								!t.isReadOnly &&
								!r &&
								!n.selection.isCollapsed
							) {
								const t = n.selection.getSelectedElement();
								(t && mg(t)) || (r = n.selection.editableElement);
							}
							r &&
								(e.change((t) => {
									t.setAttribute("draggable", "true", r);
								}),
								(this._draggableElement = t.editing.mapper.toModelElement(r)));
						}),
							this.listenTo(n, "mouseup", () => {
								Ui.isAndroid || this._clearDraggableAttributesDelayed();
							});
					}
					_clearDraggableAttributes() {
						const t = this.editor.editing;
						t.view.change((e) => {
							this._draggableElement &&
								"$graveyard" != this._draggableElement.root.rootName &&
								e.removeAttribute(
									"draggable",
									t.mapper.toViewElement(this._draggableElement),
								),
								(this._draggableElement = null);
						});
					}
					_setupDropMarker() {
						const t = this.editor;
						t.conversion
							.for("editingDowncast")
							.markerToHighlight({
								model: "drop-target",
								view: { classes: ["ck-clipboard-drop-target-range"] },
							}),
							t.conversion.for("editingDowncast").markerToElement({
								model: "drop-target",
								view: (e, { writer: n }) => {
									if (t.model.schema.checkChild(e.markerRange.start, "$text"))
										return n.createUIElement(
											"span",
											{ class: "ck ck-clipboard-drop-target-position" },
											function (t) {
												const e = this.toDomElement(t);
												return e.append("⁠", t.createElement("span"), "⁠"), e;
											},
										);
								},
							});
					}
					_updateDropMarker(t) {
						const e = this.editor,
							n = e.model.markers;
						e.model.change((e) => {
							n.has("drop-target")
								? n.get("drop-target").getRange().isEqual(t) ||
									e.updateMarker("drop-target", { range: t })
								: e.addMarker("drop-target", {
										range: t,
										usingOperation: !1,
										affectsData: !1,
									});
						});
					}
					_removeDropMarker() {
						const t = this.editor.model;
						this._removeDropMarkerDelayed.cancel(),
							this._updateDropMarkerThrottled.cancel(),
							t.markers.has("drop-target") &&
								t.change((t) => {
									t.removeMarker("drop-target");
								});
					}
					_finalizeDragging(t) {
						const e = this.editor,
							n = e.model;
						this._removeDropMarker(),
							this._clearDraggableAttributes(),
							e.plugins.has("WidgetToolbarRepository") &&
								e.plugins
									.get("WidgetToolbarRepository")
									.clearForceDisabled("dragDrop"),
							(this._draggingUid = ""),
							this._draggedRange &&
								(t &&
									this.isEnabled &&
									n.deleteContent(n.createSelection(this._draggedRange), {
										doNotAutoparagraph: !0,
									}),
								this._draggedRange.detach(),
								(this._draggedRange = null));
					}
				}
				function Ng(t, e, n) {
					const o = t.model,
						i = t.editing.mapper;
					let r = null;
					const s = e ? e[0].start : null;
					if (
						(n.is("uiElement") && (n = n.parent),
						(r = (function (t, e) {
							const n = t.model,
								o = t.editing.mapper;
							if (mg(e)) return n.createRangeOn(o.toModelElement(e));
							if (!e.is("editableElement")) {
								const t = e.findAncestor(
									(t) => mg(t) || t.is("editableElement"),
								);
								if (mg(t)) return n.createRangeOn(o.toModelElement(t));
							}
							return null;
						})(t, n)),
						r)
					)
						return r;
					const a = (function (t, e) {
							const n = t.editing.mapper,
								o = t.editing.view,
								i = n.toModelElement(e);
							if (i) return i;
							const r = o.createPositionBefore(e),
								s = n.findMappedViewAncestor(r);
							return n.toModelElement(s);
						})(t, n),
						c = s ? i.toModelPosition(s) : null;
					return c
						? ((r = (function (t, e, n) {
								const o = t.model;
								if (!o.schema.checkChild(n, "$block")) return null;
								const i = o.createPositionAt(n, 0),
									r = e.path.slice(0, i.path.length),
									s = o.createPositionFromPath(e.root, r).nodeAfter;
								if (s && o.schema.isObject(s)) return o.createRangeOn(s);
								return null;
							})(t, c, a)),
							r ||
								((r = o.schema.getNearestSelectionRange(
									c,
									Ui.isGecko ? "forward" : "backward",
								)),
								r ||
									(function (t, e) {
										const n = t.model;
										let o = e;
										for (; o; ) {
											if (n.schema.isObject(o)) return n.createRangeOn(o);
											o = o.parent;
										}
										return null;
									})(t, c.parent)))
						: (function (t, e) {
								const n = t.model,
									o = n.schema,
									i = n.createPositionAt(e, 0);
								return o.getNearestSelectionRange(i, "forward");
							})(t, a);
				}
				function Vg(t) {
					return Ui.isGecko
						? t.dropEffect
						: ["all", "copyMove"].includes(t.effectAllowed)
							? "move"
							: "copy";
				}
				function Lg(t, e) {
					let n;
					function o(...i) {
						o.cancel(), (n = setTimeout(() => t(...i), e));
					}
					return (
						(o.cancel = () => {
							clearTimeout(n);
						}),
						o
					);
				}
				function jg(t) {
					if (t.is("editableElement")) return null;
					if (t.hasClass("ck-widget__selection-handle"))
						return t.findAncestor(mg);
					if (mg(t)) return t;
					const e = t.findAncestor((t) => mg(t) || t.is("editableElement"));
					return mg(e) ? e : null;
				}
				class Hg extends R {
					static get pluginName() {
						return "PastePlainText";
					}
					static get requires() {
						return [cg];
					}
					init() {
						const t = this.editor,
							e = t.model,
							n = t.editing.view,
							o = n.document,
							i = e.document.selection;
						let r = !1;
						n.addObserver(rg),
							this.listenTo(o, "keydown", (t, e) => {
								r = e.shiftKey;
							}),
							t.plugins.get(cg).on("contentInsertion", (t, n) => {
								(r ||
									(function (t, e) {
										if (t.childCount > 1) return !1;
										const n = t.getChild(0);
										if (e.isObject(n)) return !1;
										return 0 == Array.from(n.getAttributeKeys()).length;
									})(n.content, e.schema)) &&
									e.change((t) => {
										const o = Array.from(i.getAttributes()).filter(
											([t]) => e.schema.getAttributeProperties(t).isFormatting,
										);
										i.isCollapsed ||
											e.deleteContent(i, { doNotAutoparagraph: !0 }),
											o.push(...i.getAttributes());
										const r = t.createRangeIn(n.content);
										for (const e of r.getItems())
											e.is("$textProxy") && t.setAttributes(o, e);
									});
							});
					}
				}
				class $g extends R {
					static get pluginName() {
						return "Clipboard";
					}
					static get requires() {
						return [cg, Mg, Hg];
					}
				}
				class qg extends M {
					constructor(t) {
						super(t),
							(this._stack = []),
							(this._createdBatches = new WeakSet()),
							this.refresh(),
							this.listenTo(
								t.data,
								"set",
								(t, e) => {
									e[1] = { ...e[1] };
									const n = e[1];
									n.batchType || (n.batchType = { isUndoable: !1 });
								},
								{ priority: "high" },
							),
							this.listenTo(t.data, "set", (t, e) => {
								e[1].batchType.isUndoable || this.clearStack();
							});
					}
					refresh() {
						this.isEnabled = this._stack.length > 0;
					}
					addBatch(t) {
						const e = this.editor.model.document.selection,
							n = {
								ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [],
								isBackward: e.isBackward,
							};
						this._stack.push({ batch: t, selection: n }), this.refresh();
					}
					clearStack() {
						(this._stack = []), this.refresh();
					}
					_restoreSelection(t, e, n) {
						const o = this.editor.model,
							i = o.document,
							r = [],
							s = t.map((t) => t.getTransformedByOperations(n)),
							a = s.flat();
						for (const t of s) {
							const e = t
								.filter((t) => t.root != i.graveyard)
								.filter((t) => !Wg(t, a));
							e.length && (Ug(e), r.push(e[0]));
						}
						r.length &&
							o.change((t) => {
								t.setSelection(r, { backward: e });
							});
					}
					_undo(t, e) {
						const n = this.editor.model,
							o = n.document;
						this._createdBatches.add(e);
						const i = t.operations.slice().filter((t) => t.isDocumentOperation);
						i.reverse();
						for (const t of i) {
							const i = t.baseVersion + 1,
								r = Array.from(o.history.getOperations(i)),
								s = vd([t.getReversed()], r, {
									useRelations: !0,
									document: this.editor.model.document,
									padWithNoOps: !1,
									forceWeakRemove: !0,
								}).operationsA;
							for (const i of s)
								e.addOperation(i),
									n.applyOperation(i),
									o.history.setOperationAsUndone(t, i);
						}
					}
				}
				function Ug(t) {
					t.sort((t, e) => (t.start.isBefore(e.start) ? -1 : 1));
					for (let e = 1; e < t.length; e++) {
						const n = t[e - 1].getJoined(t[e], !0);
						n && (e--, t.splice(e, 2, n));
					}
				}
				function Wg(t, e) {
					return e.some((e) => e !== t && e.containsRange(t, !0));
				}
				class Kg extends qg {
					execute(t = null) {
						const e = t
								? this._stack.findIndex((e) => e.batch == t)
								: this._stack.length - 1,
							n = this._stack.splice(e, 1)[0],
							o = this.editor.model.createBatch({ isUndo: !0 });
						this.editor.model.enqueueChange(o, () => {
							this._undo(n.batch, o);
							const t = this.editor.model.document.history.getOperations(
								n.batch.baseVersion,
							);
							this._restoreSelection(
								n.selection.ranges,
								n.selection.isBackward,
								t,
							),
								this.fire("revert", n.batch, o);
						}),
							this.refresh();
					}
				}
				class Gg extends qg {
					execute() {
						const t = this._stack.pop(),
							e = this.editor.model.createBatch({ isUndo: !0 });
						this.editor.model.enqueueChange(e, () => {
							const n =
									t.batch.operations[t.batch.operations.length - 1]
										.baseVersion + 1,
								o = this.editor.model.document.history.getOperations(n);
							this._restoreSelection(
								t.selection.ranges,
								t.selection.isBackward,
								o,
							),
								this._undo(t.batch, e);
						}),
							this.refresh();
					}
				}
				class Jg extends R {
					constructor(t) {
						super(t), (this._batchRegistry = new WeakSet());
					}
					static get pluginName() {
						return "UndoEditing";
					}
					init() {
						const t = this.editor;
						(this._undoCommand = new Kg(t)),
							(this._redoCommand = new Gg(t)),
							t.commands.add("undo", this._undoCommand),
							t.commands.add("redo", this._redoCommand),
							this.listenTo(
								t.model,
								"applyOperation",
								(t, e) => {
									const n = e[0];
									if (!n.isDocumentOperation) return;
									const o = n.batch,
										i = this._redoCommand._createdBatches.has(o),
										r = this._undoCommand._createdBatches.has(o);
									this._batchRegistry.has(o) ||
										(this._batchRegistry.add(o),
										o.isUndoable &&
											(i
												? this._undoCommand.addBatch(o)
												: r ||
													(this._undoCommand.addBatch(o),
													this._redoCommand.clearStack())));
								},
								{ priority: "highest" },
							),
							this.listenTo(this._undoCommand, "revert", (t, e, n) => {
								this._redoCommand.addBatch(n);
							}),
							t.keystrokes.set("CTRL+Z", "undo"),
							t.keystrokes.set("CTRL+Y", "redo"),
							t.keystrokes.set("CTRL+SHIFT+Z", "redo");
					}
				}
				var Yg =
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>',
					Qg =
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
				class Xg extends R {
					static get pluginName() {
						return "UndoUI";
					}
					init() {
						const t = this.editor,
							e = t.locale,
							n = t.t,
							o = "ltr" == e.uiLanguageDirection ? Yg : Qg,
							i = "ltr" == e.uiLanguageDirection ? Qg : Yg;
						this._addButton("undo", n("Undo"), "CTRL+Z", o),
							this._addButton("redo", n("Redo"), "CTRL+Y", i);
					}
					_addButton(t, e, n, o) {
						const i = this.editor;
						i.ui.componentFactory.add(t, (r) => {
							const s = i.commands.get(t),
								a = new Ju(r);
							return (
								a.set({ label: e, icon: o, keystroke: n, tooltip: !0 }),
								a.bind("isEnabled").to(s, "isEnabled"),
								this.listenTo(a, "execute", () => {
									i.execute(t), i.editing.view.focus();
								}),
								a
							);
						});
					}
				}
				class Zg extends R {
					static get requires() {
						return [Jg, Xg];
					}
					static get pluginName() {
						return "Undo";
					}
				}
				var tf = n(42),
					ef = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(tf.a, ef), tf.a.locals;
				new RegExp(
					String(
						/^(http(s)?:\/\/)?[\w-]+\.[\w.~:/[\]@!$&'()*+,;=%-]+/.source +
							/\.(jpg|jpeg|png|gif|ico|webp|JPG|JPEG|PNG|GIF|ICO|WEBP)/.source +
							/(\?[\w.~:/[\]@!$&'()*+,;=%-]*)?/.source +
							/(#[\w.~:/[\]@!$&'()*+,;=%-]*)?$/.source,
					),
				);
				var nf = function (t, e, n) {
						var o = t.length;
						return (n = void 0 === n ? o : n), !e && n >= o ? t : Vo(t, e, n);
					},
					of = RegExp(
						"[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]",
					);
				var rf = function (t) {
					return of.test(t);
				};
				var sf = function (t) {
						return t.split("");
					},
					af = "[\\ud800-\\udfff]",
					cf = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",
					lf = "\\ud83c[\\udffb-\\udfff]",
					df = "[^\\ud800-\\udfff]",
					uf = "(?:\\ud83c[\\udde6-\\uddff]){2}",
					hf = "[\\ud800-\\udbff][\\udc00-\\udfff]",
					pf = "(?:" + cf + "|" + lf + ")" + "?",
					gf = "[\\ufe0e\\ufe0f]?",
					ff =
						gf +
						pf +
						("(?:\\u200d(?:" + [df, uf, hf].join("|") + ")" + gf + pf + ")*"),
					mf = "(?:" + [df + cf + "?", cf, uf, hf, af].join("|") + ")",
					kf = RegExp(lf + "(?=" + lf + ")|" + mf + ff, "g");
				var bf = function (t) {
					return t.match(kf) || [];
				};
				var wf = function (t) {
					return rf(t) ? bf(t) : sf(t);
				};
				var Af = (function (t) {
					return function (e) {
						e = zo(e);
						var n = rf(e) ? wf(e) : void 0,
							o = n ? n[0] : e.charAt(0),
							i = n ? nf(n, 1).join("") : e.slice(1);
						return o[t]() + i;
					};
				})("toUpperCase");
				const _f =
						/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
					Cf =
						/^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i,
					vf =
						/^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i,
					yf = /^((\w+:(\/{2,})?)|(\W))/i,
					xf = "Ctrl+K";
				function Df(t, { writer: e }) {
					const n = e.createAttributeElement("a", { href: t }, { priority: 5 });
					return e.setCustomProperty("link", !0, n), n;
				}
				function Ef(t) {
					return (function (t) {
						return t.replace(_f, "").match(Cf);
					})((t = String(t)))
						? t
						: "#";
				}
				function Sf(t, e) {
					return !!t && e.checkAttribute(t.name, "linkHref");
				}
				function Bf(t, e) {
					const n = ((o = t), vf.test(o) ? "mailto:" : e);
					var o;
					const i = !!n && !Tf(t);
					return t && i ? n + t : t;
				}
				function Tf(t) {
					return yf.test(t);
				}
				function Pf(t) {
					window.open(t, "_blank", "noopener");
				}
				const Ff = new RegExp(
					"(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$",
					"i",
				);
				class If extends R {
					static get requires() {
						return [Ip];
					}
					static get pluginName() {
						return "AutoLink";
					}
					init() {
						const t = this.editor.model.document.selection;
						t.on("change:range", () => {
							this.isEnabled = !t.anchor.parent.is("element", "codeBlock");
						}),
							this._enableTypingHandling();
					}
					afterInit() {
						this._enableEnterHandling(), this._enableShiftEnterHandling();
					}
					_enableTypingHandling() {
						const t = this.editor,
							e = new Op(t.model, (t) => {
								if (
									!(function (t) {
										return (
											t.length > 4 &&
											" " === t[t.length - 1] &&
											" " !== t[t.length - 2]
										);
									})(t)
								)
									return;
								const e = zf(t.substr(0, t.length - 1));
								return e ? { url: e } : void 0;
							});
						e.on("matched:data", (e, n) => {
							const { batch: o, range: i, url: r } = n;
							if (!o.isTyping) return;
							const s = i.end.getShiftedBy(-1),
								a = s.getShiftedBy(-r.length),
								c = t.model.createRange(a, s);
							this._applyAutoLink(r, c);
						}),
							e.bind("isEnabled").to(this);
					}
					_enableEnterHandling() {
						const t = this.editor,
							e = t.model,
							n = t.commands.get("enter");
						n &&
							n.on("execute", () => {
								const t = e.document.selection.getFirstPosition();
								if (!t.parent.previousSibling) return;
								const n = e.createRangeIn(t.parent.previousSibling);
								this._checkAndApplyAutoLinkOnRange(n);
							});
					}
					_enableShiftEnterHandling() {
						const t = this.editor,
							e = t.model,
							n = t.commands.get("shiftEnter");
						n &&
							n.on("execute", () => {
								const t = e.document.selection.getFirstPosition(),
									n = e.createRange(
										e.createPositionAt(t.parent, 0),
										t.getShiftedBy(-1),
									);
								this._checkAndApplyAutoLinkOnRange(n);
							});
					}
					_checkAndApplyAutoLinkOnRange(t) {
						const e = this.editor.model,
							{ text: n, range: o } = Rp(t, e),
							i = zf(n);
						if (i) {
							const t = e.createRange(o.end.getShiftedBy(-i.length), o.end);
							this._applyAutoLink(i, t);
						}
					}
					_applyAutoLink(t, e) {
						const n = this.editor.model,
							o = Bf(t, this.editor.config.get("link.defaultProtocol"));
						this.isEnabled &&
							(function (t, e) {
								return e.schema.checkAttributeInSelection(
									e.createSelection(t),
									"linkHref",
								);
							})(e, n) &&
							Tf(o) &&
							!(function (t) {
								const e = t.start.nodeAfter;
								return e && e.hasAttribute("linkHref");
							})(e) &&
							this._persistAutoLink(o, e);
					}
					_persistAutoLink(t, e) {
						const n = this.editor.model,
							o = this.editor.plugins.get("Delete");
						n.enqueueChange((i) => {
							i.setAttribute("linkHref", t, e),
								n.enqueueChange(() => {
									o.requestUndoOnBackspace();
								});
						});
					}
				}
				function zf(t) {
					const e = Ff.exec(t);
					return e ? e[2] : null;
				}
				class Rf extends M {
					execute() {
						const t = this.editor.model,
							e = t.document;
						t.change((n) => {
							!(function (t, e, n) {
								const o = n.isCollapsed,
									i = n.getFirstRange(),
									r = i.start.parent,
									s = i.end.parent,
									a = r == s;
								if (o) {
									const o = lg(t.schema, n.getAttributes());
									Of(t, e, i.end),
										e.removeSelectionAttribute(n.getAttributeKeys()),
										e.setSelectionAttribute(o);
								} else {
									const o = !(i.start.isAtStart && i.end.isAtEnd);
									t.deleteContent(n, { leaveUnmerged: o }),
										a ? Of(t, e, n.focus) : o && e.setSelection(s, 0);
								}
							})(t, n, e.selection),
								this.fire("afterExecute", { writer: n });
						});
					}
					refresh() {
						const t = this.editor.model,
							e = t.document;
						this.isEnabled = (function (t, e) {
							if (e.rangeCount > 1) return !1;
							const n = e.anchor;
							if (!n || !t.checkChild(n, "softBreak")) return !1;
							const o = e.getFirstRange(),
								i = o.start.parent,
								r = o.end.parent;
							if ((Mf(i, t) || Mf(r, t)) && i !== r) return !1;
							return !0;
						})(t.schema, e.selection);
					}
				}
				function Of(t, e, n) {
					const o = e.createElement("softBreak");
					t.insertContent(o, n), e.setSelection(o, "after");
				}
				function Mf(t, e) {
					return !t.is("rootElement") && (e.isLimit(t) || Mf(t.parent, e));
				}
				class Nf extends R {
					static get pluginName() {
						return "ShiftEnter";
					}
					init() {
						const t = this.editor,
							e = t.model.schema,
							n = t.conversion,
							o = t.editing.view,
							i = o.document;
						e.register("softBreak", { allowWhere: "$text", isInline: !0 }),
							n
								.for("upcast")
								.elementToElement({ model: "softBreak", view: "br" }),
							n
								.for("downcast")
								.elementToElement({
									model: "softBreak",
									view: (t, { writer: e }) => e.createEmptyElement("br"),
								}),
							o.addObserver(pg),
							t.commands.add("shiftEnter", new Rf(t)),
							this.listenTo(
								i,
								"enter",
								(e, n) => {
									i.isComposing || n.preventDefault(),
										n.isSoft &&
											(t.execute("shiftEnter"), o.scrollToTheSelection());
								},
								{ priority: "low" },
							);
					}
				}
				var Vf = n(43),
					Lf = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Vf.a, Lf), Vf.a.locals;
				class jf extends M {
					constructor(t, e) {
						super(t), (this.attributeKey = e);
					}
					refresh() {
						const t = this.editor.model,
							e = t.document;
						(this.value = this._getValueFromFirstAllowedNode()),
							(this.isEnabled = t.schema.checkAttributeInSelection(
								e.selection,
								this.attributeKey,
							));
					}
					execute(t = {}) {
						const e = this.editor.model,
							n = e.document.selection,
							o = void 0 === t.forceValue ? !this.value : t.forceValue;
						e.change((t) => {
							if (n.isCollapsed)
								o
									? t.setSelectionAttribute(this.attributeKey, !0)
									: t.removeSelectionAttribute(this.attributeKey);
							else {
								const i = e.schema.getValidRanges(
									n.getRanges(),
									this.attributeKey,
								);
								for (const e of i)
									o
										? t.setAttribute(this.attributeKey, o, e)
										: t.removeAttribute(this.attributeKey, e);
							}
						});
					}
					_getValueFromFirstAllowedNode() {
						const t = this.editor.model,
							e = t.schema,
							n = t.document.selection;
						if (n.isCollapsed) return n.hasAttribute(this.attributeKey);
						for (const t of n.getRanges())
							for (const n of t.getItems())
								if (e.checkAttribute(n, this.attributeKey))
									return n.hasAttribute(this.attributeKey);
						return !1;
					}
				}
				const Hf = "bold";
				class $f extends R {
					static get pluginName() {
						return "BoldEditing";
					}
					init() {
						const t = this.editor;
						t.model.schema.extend("$text", { allowAttributes: Hf }),
							t.model.schema.setAttributeProperties(Hf, {
								isFormatting: !0,
								copyOnEnter: !0,
							}),
							t.conversion.attributeToElement({
								model: Hf,
								view: "strong",
								upcastAlso: [
									"b",
									(t) => {
										const e = t.getStyle("font-weight");
										return e
											? "bold" == e || Number(e) >= 600
												? { name: !0, styles: ["font-weight"] }
												: void 0
											: null;
									},
								],
							}),
							t.commands.add(Hf, new jf(t, Hf)),
							t.keystrokes.set("CTRL+B", Hf);
					}
				}
				const qf = "bold";
				class Uf extends R {
					static get pluginName() {
						return "BoldUI";
					}
					init() {
						const t = this.editor,
							e = t.t;
						t.ui.componentFactory.add(qf, (n) => {
							const o = t.commands.get(qf),
								i = new Ju(n);
							return (
								i.set({
									label: e("Bold"),
									icon: Nu.bold,
									keystroke: "CTRL+B",
									tooltip: !0,
									isToggleable: !0,
								}),
								i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"),
								this.listenTo(i, "execute", () => {
									t.execute(qf), t.editing.view.focus();
								}),
								i
							);
						});
					}
				}
				var Wf = n(44),
					Kf = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Wf.a, Kf), Wf.a.locals;
				var Gf = n(45),
					Jf = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Gf.a, Jf), Gf.a.locals;
				class Yf extends M {
					constructor(t) {
						super(t), (this.affectsData = !1);
					}
					execute() {
						const t = this.editor.model,
							e = t.document.selection;
						let n = t.schema.getLimitElement(e);
						if (e.containsEntireContent(n) || !Qf(t.schema, n))
							do {
								if (((n = n.parent), !n)) return;
							} while (!Qf(t.schema, n));
						t.change((t) => {
							t.setSelection(n, "in");
						});
					}
				}
				function Qf(t, e) {
					return (
						t.isLimit(e) &&
						(t.checkChild(e, "$text") || t.checkChild(e, "paragraph"))
					);
				}
				const Xf = Xi("Ctrl+A");
				class Zf extends R {
					static get pluginName() {
						return "SelectAllEditing";
					}
					init() {
						const t = this.editor,
							e = t.editing.view.document;
						t.commands.add("selectAll", new Yf(t)),
							this.listenTo(e, "keydown", (e, n) => {
								Qi(n) === Xf && (t.execute("selectAll"), n.preventDefault());
							});
					}
				}
				class tm extends R {
					static get pluginName() {
						return "SelectAllUI";
					}
					init() {
						const t = this.editor;
						t.ui.componentFactory.add("selectAll", (e) => {
							const n = t.commands.get("selectAll"),
								o = new Ju(e),
								i = e.t;
							return (
								o.set({
									label: i("Select all"),
									icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>',
									keystroke: "Ctrl+A",
									tooltip: !0,
								}),
								o.bind("isEnabled").to(n, "isEnabled"),
								this.listenTo(o, "execute", () => {
									t.execute("selectAll"), t.editing.view.focus();
								}),
								o
							);
						});
					}
				}
				class em extends R {
					static get requires() {
						return [Zf, tm];
					}
					static get pluginName() {
						return "SelectAll";
					}
				}
				class nm extends M {
					refresh() {
						const t = this.editor.model,
							e = ya(t.document.selection.getSelectedBlocks());
						(this.value = !!e && e.is("element", "paragraph")),
							(this.isEnabled = !!e && om(e, t.schema));
					}
					execute(t = {}) {
						const e = this.editor.model,
							n = e.document;
						e.change((o) => {
							const i = (t.selection || n.selection).getSelectedBlocks();
							for (const t of i)
								!t.is("element", "paragraph") &&
									om(t, e.schema) &&
									o.rename(t, "paragraph");
						});
					}
				}
				function om(t, e) {
					return e.checkChild(t.parent, "paragraph") && !e.isObject(t);
				}
				class im extends M {
					execute(t) {
						const e = this.editor.model,
							n = t.attributes;
						let o = t.position;
						e.change((t) => {
							const i = t.createElement("paragraph");
							if (
								(n && e.schema.setAllowedAttributes(i, n, t),
								!e.schema.checkChild(o.parent, i))
							) {
								const n = e.schema.findAllowedParent(o, i);
								if (!n) return;
								o = t.split(o, n).position;
							}
							e.insertContent(i, o), t.setSelection(i, "in");
						});
					}
				}
				class rm extends R {
					static get pluginName() {
						return "Paragraph";
					}
					init() {
						const t = this.editor,
							e = t.model;
						t.commands.add("paragraph", new nm(t)),
							t.commands.add("insertParagraph", new im(t)),
							e.schema.register("paragraph", { inheritAllFrom: "$block" }),
							t.conversion.elementToElement({ model: "paragraph", view: "p" }),
							t.conversion
								.for("upcast")
								.elementToElement({
									model: (t, { writer: e }) =>
										rm.paragraphLikeElements.has(t.name)
											? t.isEmpty
												? null
												: e.createElement("paragraph")
											: null,
									view: /.+/,
									converterPriority: "low",
								});
					}
				}
				rm.paragraphLikeElements = new Set([
					"blockquote",
					"dd",
					"div",
					"dt",
					"h1",
					"h2",
					"h3",
					"h4",
					"h5",
					"h6",
					"li",
					"p",
					"td",
					"th",
				]);
				class sm extends M {
					constructor(t, e) {
						super(t), (this.modelElements = e);
					}
					refresh() {
						const t = ya(
							this.editor.model.document.selection.getSelectedBlocks(),
						);
						(this.value = !!t && this.modelElements.includes(t.name) && t.name),
							(this.isEnabled =
								!!t &&
								this.modelElements.some((e) =>
									am(t, e, this.editor.model.schema),
								));
					}
					execute(t) {
						const e = this.editor.model,
							n = e.document,
							o = t.value;
						e.change((t) => {
							const i = Array.from(n.selection.getSelectedBlocks()).filter(
								(t) => am(t, o, e.schema),
							);
							for (const e of i) e.is("element", o) || t.rename(e, o);
						});
					}
				}
				function am(t, e, n) {
					return n.checkChild(t.parent, e) && !n.isObject(t);
				}
				const cm = "paragraph";
				class lm extends R {
					static get pluginName() {
						return "HeadingEditing";
					}
					constructor(t) {
						super(t),
							t.config.define("heading", {
								options: [
									{
										model: "paragraph",
										title: "Paragraph",
										class: "ck-heading_paragraph",
									},
									{
										model: "heading1",
										view: "h2",
										title: "Heading 1",
										class: "ck-heading_heading1",
									},
									{
										model: "heading2",
										view: "h3",
										title: "Heading 2",
										class: "ck-heading_heading2",
									},
									{
										model: "heading3",
										view: "h4",
										title: "Heading 3",
										class: "ck-heading_heading3",
									},
								],
							});
					}
					static get requires() {
						return [rm];
					}
					init() {
						const t = this.editor,
							e = t.config.get("heading.options"),
							n = [];
						for (const o of e)
							o.model !== cm &&
								(t.model.schema.register(o.model, { inheritAllFrom: "$block" }),
								t.conversion.elementToElement(o),
								n.push(o.model));
						this._addDefaultH1Conversion(t),
							t.commands.add("heading", new sm(t, n));
					}
					afterInit() {
						const t = this.editor,
							e = t.commands.get("enter"),
							n = t.config.get("heading.options");
						e &&
							this.listenTo(e, "afterExecute", (e, o) => {
								const i = t.model.document.selection.getFirstPosition().parent;
								n.some((t) => i.is("element", t.model)) &&
									!i.is("element", cm) &&
									0 === i.childCount &&
									o.writer.rename(i, cm);
							});
					}
					_addDefaultH1Conversion(t) {
						t.conversion
							.for("upcast")
							.elementToElement({
								model: "heading1",
								view: "h1",
								converterPriority: a.get("low") + 1,
							});
					}
				}
				var dm = n(46),
					um = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(dm.a, um), dm.a.locals;
				class hm extends R {
					static get pluginName() {
						return "HeadingUI";
					}
					init() {
						const t = this.editor,
							e = t.t,
							n = (function (t) {
								const e = t.t,
									n = {
										Paragraph: e("Paragraph"),
										"Heading 1": e("Heading 1"),
										"Heading 2": e("Heading 2"),
										"Heading 3": e("Heading 3"),
										"Heading 4": e("Heading 4"),
										"Heading 5": e("Heading 5"),
										"Heading 6": e("Heading 6"),
									};
								return t.config.get("heading.options").map((t) => {
									const e = n[t.title];
									return e && e != t.title && (t.title = e), t;
								});
							})(t),
							o = e("Choose heading"),
							i = e("Heading");
						t.ui.componentFactory.add("heading", (e) => {
							const r = {},
								s = new Xn(),
								a = t.commands.get("heading"),
								c = t.commands.get("paragraph"),
								l = [a];
							for (const t of n) {
								const e = {
									type: "button",
									model: new np({
										label: t.title,
										class: t.class,
										withText: !0,
									}),
								};
								"paragraph" === t.model
									? (e.model.bind("isOn").to(c, "value"),
										e.model.set("commandName", "paragraph"),
										l.push(c))
									: (e.model.bind("isOn").to(a, "value", (e) => e === t.model),
										e.model.set({
											commandName: "heading",
											commandValue: t.model,
										})),
									s.add(e),
									(r[t.model] = t.title);
							}
							const d = Fh(e);
							return (
								zh(d, s),
								d.buttonView.set({ isOn: !1, withText: !0, tooltip: i }),
								d.extendTemplate({
									attributes: { class: ["ck-heading-dropdown"] },
								}),
								d
									.bind("isEnabled")
									.toMany(l, "isEnabled", (...t) => t.some((t) => t)),
								d.buttonView
									.bind("label")
									.to(a, "value", c, "value", (t, e) => {
										const n = t || (e && "paragraph");
										return r[n] ? r[n] : o;
									}),
								this.listenTo(d, "execute", (e) => {
									t.execute(
										e.source.commandName,
										e.source.commandValue
											? { value: e.source.commandValue }
											: void 0,
									),
										t.editing.view.focus();
								}),
								d
							);
						});
					}
				}
				var pm = n(47),
					gm = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(pm.a, gm), pm.a.locals;
				var fm = n(48),
					mm = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					},
					km = (Or()(fm.a, mm), fm.a.locals, n(49)),
					bm = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(km.a, bm), km.a.locals;
				var wm = n(50),
					Am = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(wm.a, Am), wm.a.locals;
				var _m = n(51),
					Cm = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(_m.a, Cm), _m.a.locals;
				const vm = "italic";
				class ym extends R {
					static get pluginName() {
						return "ItalicEditing";
					}
					init() {
						const t = this.editor;
						t.model.schema.extend("$text", { allowAttributes: vm }),
							t.model.schema.setAttributeProperties(vm, {
								isFormatting: !0,
								copyOnEnter: !0,
							}),
							t.conversion.attributeToElement({
								model: vm,
								view: "i",
								upcastAlso: ["em", { styles: { "font-style": "italic" } }],
							}),
							t.commands.add(vm, new jf(t, vm)),
							t.keystrokes.set("CTRL+I", vm);
					}
				}
				const xm = "italic";
				class Dm extends R {
					static get pluginName() {
						return "ItalicUI";
					}
					init() {
						const t = this.editor,
							e = t.t;
						t.ui.componentFactory.add(xm, (n) => {
							const o = t.commands.get(xm),
								i = new Ju(n);
							return (
								i.set({
									label: e("Italic"),
									icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>',
									keystroke: "CTRL+I",
									tooltip: !0,
									isToggleable: !0,
								}),
								i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"),
								this.listenTo(i, "execute", () => {
									t.execute(xm), t.editing.view.focus();
								}),
								i
							);
						});
					}
				}
				class Em {
					constructor() {
						this._definitions = new Set();
					}
					get length() {
						return this._definitions.size;
					}
					add(t) {
						Array.isArray(t)
							? t.forEach((t) => this._definitions.add(t))
							: this._definitions.add(t);
					}
					getDispatcher() {
						return (t) => {
							t.on(
								"attribute:linkHref",
								(t, e, n) => {
									if (!n.consumable.test(e.item, "attribute:linkHref")) return;
									if (!e.item.is("selection") && !n.schema.isInline(e.item))
										return;
									const o = n.writer,
										i = o.document.selection;
									for (const t of this._definitions) {
										const r = o.createAttributeElement("a", t.attributes, {
											priority: 5,
										});
										t.classes && o.addClass(t.classes, r);
										for (const e in t.styles) o.setStyle(e, t.styles[e], r);
										o.setCustomProperty("link", !0, r),
											t.callback(e.attributeNewValue)
												? e.item.is("selection")
													? o.wrap(i.getFirstRange(), r)
													: o.wrap(n.mapper.toViewRange(e.range), r)
												: o.unwrap(n.mapper.toViewRange(e.range), r);
									}
								},
								{ priority: "high" },
							);
						};
					}
					getDispatcherForLinkedImage() {
						return (t) => {
							t.on(
								"attribute:linkHref:imageBlock",
								(t, e, { writer: n, mapper: o }) => {
									const i = o.toViewElement(e.item),
										r = Array.from(i.getChildren()).find((t) => "a" === t.name);
									for (const t of this._definitions) {
										const o = mo(t.attributes);
										if (t.callback(e.attributeNewValue)) {
											for (const [t, e] of o)
												"class" === t
													? n.addClass(e, r)
													: n.setAttribute(t, e, r);
											t.classes && n.addClass(t.classes, r);
											for (const e in t.styles) n.setStyle(e, t.styles[e], r);
										} else {
											for (const [t, e] of o)
												"class" === t
													? n.removeClass(e, r)
													: n.removeAttribute(t, r);
											t.classes && n.removeClass(t.classes, r);
											for (const e in t.styles) n.removeStyle(e, r);
										}
									}
								},
							);
						};
					}
				}
				class Sm extends M {
					constructor(t) {
						super(t),
							(this.manualDecorators = new Xn()),
							(this.automaticDecorators = new Em());
					}
					restoreManualDecoratorStates() {
						for (const t of this.manualDecorators)
							t.value = this._getDecoratorStateFromModel(t.id);
					}
					refresh() {
						const t = this.editor.model,
							e = t.document.selection,
							n = e.getSelectedElement() || ya(e.getSelectedBlocks());
						Sf(n, t.schema)
							? ((this.value = n.getAttribute("linkHref")),
								(this.isEnabled = t.schema.checkAttribute(n, "linkHref")))
							: ((this.value = e.getAttribute("linkHref")),
								(this.isEnabled = t.schema.checkAttributeInSelection(
									e,
									"linkHref",
								)));
						for (const t of this.manualDecorators)
							t.value = this._getDecoratorStateFromModel(t.id);
					}
					execute(t, e = {}) {
						const n = this.editor.model,
							o = n.document.selection,
							i = [],
							r = [];
						for (const t in e) e[t] ? i.push(t) : r.push(t);
						n.change((e) => {
							if (o.isCollapsed) {
								const s = o.getFirstPosition();
								if (o.hasAttribute("linkHref")) {
									const a = Xp(s, "linkHref", o.getAttribute("linkHref"), n);
									e.setAttribute("linkHref", t, a),
										i.forEach((t) => {
											e.setAttribute(t, !0, a);
										}),
										r.forEach((t) => {
											e.removeAttribute(t, a);
										}),
										e.setSelection(e.createPositionAfter(a.end.nodeBefore));
								} else if ("" !== t) {
									const r = mo(o.getAttributes());
									r.set("linkHref", t),
										i.forEach((t) => {
											r.set(t, !0);
										});
									const { end: a } = n.insertContent(e.createText(t, r), s);
									e.setSelection(a);
								}
								["linkHref", ...i, ...r].forEach((t) => {
									e.removeSelectionAttribute(t);
								});
							} else {
								const s = n.schema.getValidRanges(o.getRanges(), "linkHref"),
									a = [];
								for (const t of o.getSelectedBlocks())
									n.schema.checkAttribute(t, "linkHref") &&
										a.push(e.createRangeOn(t));
								const c = a.slice();
								for (const t of s) this._isRangeToUpdate(t, a) && c.push(t);
								for (const n of c)
									e.setAttribute("linkHref", t, n),
										i.forEach((t) => {
											e.setAttribute(t, !0, n);
										}),
										r.forEach((t) => {
											e.removeAttribute(t, n);
										});
							}
						});
					}
					_getDecoratorStateFromModel(t) {
						const e = this.editor.model,
							n = e.document.selection,
							o = n.getSelectedElement();
						return Sf(o, e.schema) ? o.getAttribute(t) : n.getAttribute(t);
					}
					_isRangeToUpdate(t, e) {
						for (const n of e) if (n.containsRange(t)) return !1;
						return !0;
					}
				}
				class Bm extends M {
					refresh() {
						const t = this.editor.model,
							e = t.document.selection,
							n = e.getSelectedElement();
						Sf(n, t.schema)
							? (this.isEnabled = t.schema.checkAttribute(n, "linkHref"))
							: (this.isEnabled = t.schema.checkAttributeInSelection(
									e,
									"linkHref",
								));
					}
					execute() {
						const t = this.editor,
							e = this.editor.model,
							n = e.document.selection,
							o = t.commands.get("link");
						e.change((t) => {
							const i = n.isCollapsed
								? [
										Xp(
											n.getFirstPosition(),
											"linkHref",
											n.getAttribute("linkHref"),
											e,
										),
									]
								: e.schema.getValidRanges(n.getRanges(), "linkHref");
							for (const e of i)
								if ((t.removeAttribute("linkHref", e), o))
									for (const n of o.manualDecorators)
										t.removeAttribute(n.id, e);
						});
					}
				}
				class Tm {
					constructor({
						id: t,
						label: e,
						attributes: n,
						classes: o,
						styles: i,
						defaultValue: r,
					}) {
						(this.id = t),
							this.set("value"),
							(this.defaultValue = r),
							(this.label = e),
							(this.attributes = n),
							(this.classes = o),
							(this.styles = i);
					}
					_createPattern() {
						return {
							attributes: this.attributes,
							classes: this.classes,
							styles: this.styles,
						};
					}
				}
				ta(Tm, S);
				var Pm = n(52),
					Fm = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Pm.a, Fm), Pm.a.locals;
				const Im = "automatic",
					zm = /^(https?:)?\/\//;
				class Rm extends R {
					static get pluginName() {
						return "LinkEditing";
					}
					static get requires() {
						return [Mp, yp, cg];
					}
					constructor(t) {
						super(t), t.config.define("link", { addTargetToExternalLinks: !1 });
					}
					init() {
						const t = this.editor;
						t.model.schema.extend("$text", { allowAttributes: "linkHref" }),
							t.conversion
								.for("dataDowncast")
								.attributeToElement({ model: "linkHref", view: Df }),
							t.conversion
								.for("editingDowncast")
								.attributeToElement({
									model: "linkHref",
									view: (t, e) => Df(Ef(t), e),
								}),
							t.conversion
								.for("upcast")
								.elementToAttribute({
									view: { name: "a", attributes: { href: !0 } },
									model: {
										key: "linkHref",
										value: (t) => t.getAttribute("href"),
									},
								}),
							t.commands.add("link", new Sm(t)),
							t.commands.add("unlink", new Bm(t));
						const e = (function (t, e) {
							const n = {
								"Open in a new tab": t("Open in a new tab"),
								Downloadable: t("Downloadable"),
							};
							return (
								e.forEach(
									(t) => (t.label && n[t.label] && (t.label = n[t.label]), t),
								),
								e
							);
						})(
							t.t,
							(function (t) {
								const e = [];
								if (t)
									for (const [n, o] of Object.entries(t)) {
										const t = Object.assign({}, o, { id: `link${Af(n)}` });
										e.push(t);
									}
								return e;
							})(t.config.get("link.decorators")),
						);
						this._enableAutomaticDecorators(e.filter((t) => t.mode === Im)),
							this._enableManualDecorators(
								e.filter((t) => "manual" === t.mode),
							);
						t.plugins.get(Mp).registerAttribute("linkHref"),
							tg(t, "linkHref", "a", "ck-link_selected"),
							this._enableLinkOpen(),
							this._enableInsertContentSelectionAttributesFixer(),
							this._enableClickingAfterLink(),
							this._enableTypingOverLink(),
							this._handleDeleteContentAfterLink();
					}
					_enableAutomaticDecorators(t) {
						const e = this.editor,
							n = e.commands.get("link").automaticDecorators;
						e.config.get("link.addTargetToExternalLinks") &&
							n.add({
								id: "linkIsExternal",
								mode: Im,
								callback: (t) => zm.test(t),
								attributes: { target: "_blank", rel: "noopener noreferrer" },
							}),
							n.add(t),
							n.length && e.conversion.for("downcast").add(n.getDispatcher());
					}
					_enableManualDecorators(t) {
						if (!t.length) return;
						const e = this.editor,
							n = e.commands.get("link").manualDecorators;
						t.forEach((t) => {
							e.model.schema.extend("$text", { allowAttributes: t.id }),
								(t = new Tm(t)),
								n.add(t),
								e.conversion.for("downcast").attributeToElement({
									model: t.id,
									view: (e, { writer: n, schema: o }, { item: i }) => {
										if ((i.is("selection") || o.isInline(i)) && e) {
											const e = n.createAttributeElement("a", t.attributes, {
												priority: 5,
											});
											t.classes && n.addClass(t.classes, e);
											for (const o in t.styles) n.setStyle(o, t.styles[o], e);
											return n.setCustomProperty("link", !0, e), e;
										}
									},
								}),
								e.conversion
									.for("upcast")
									.elementToAttribute({
										view: { name: "a", ...t._createPattern() },
										model: { key: t.id },
									});
						});
					}
					_enableLinkOpen() {
						const t = this.editor,
							e = t.editing.view.document;
						this.listenTo(
							e,
							"click",
							(t, e) => {
								if (!(Ui.isMac ? e.domEvent.metaKey : e.domEvent.ctrlKey))
									return;
								let n = e.domTarget;
								if (
									("a" != n.tagName.toLowerCase() && (n = n.closest("a")), !n)
								)
									return;
								const o = n.getAttribute("href");
								o && (t.stop(), e.preventDefault(), Pf(o));
							},
							{ context: "$capture" },
						),
							this.listenTo(e, "keydown", (e, n) => {
								const o = t.commands.get("link").value;
								o && n.keyCode === Ji.enter && n.altKey && (e.stop(), Pf(o));
							});
					}
					_enableInsertContentSelectionAttributesFixer() {
						const t = this.editor.model,
							e = t.document.selection;
						this.listenTo(
							t,
							"insertContent",
							() => {
								const n = e.anchor.nodeBefore,
									o = e.anchor.nodeAfter;
								e.hasAttribute("linkHref") &&
									n &&
									n.hasAttribute("linkHref") &&
									((o && o.hasAttribute("linkHref")) ||
										t.change((e) => {
											Om(e, Nm(t.schema));
										}));
							},
							{ priority: "low" },
						);
					}
					_enableClickingAfterLink() {
						const t = this.editor,
							e = t.model;
						t.editing.view.addObserver(Pd);
						let n = !1;
						this.listenTo(t.editing.view.document, "mousedown", () => {
							n = !0;
						}),
							this.listenTo(t.editing.view.document, "selectionChange", () => {
								if (!n) return;
								n = !1;
								const t = e.document.selection;
								if (!t.isCollapsed) return;
								if (!t.hasAttribute("linkHref")) return;
								const o = t.getFirstPosition(),
									i = Xp(o, "linkHref", t.getAttribute("linkHref"), e);
								(o.isTouching(i.start) || o.isTouching(i.end)) &&
									e.change((t) => {
										Om(t, Nm(e.schema));
									});
							});
					}
					_enableTypingOverLink() {
						const t = this.editor,
							e = t.editing.view;
						let n, o;
						this.listenTo(
							e.document,
							"delete",
							() => {
								o = !0;
							},
							{ priority: "high" },
						),
							this.listenTo(
								t.model,
								"deleteContent",
								() => {
									const e = t.model.document.selection;
									e.isCollapsed ||
										(o
											? (o = !1)
											: Mm(t) &&
												(function (t) {
													const e = t.document.selection,
														n = e.getFirstPosition(),
														o = e.getLastPosition(),
														i = n.nodeAfter;
													if (!i) return !1;
													if (!i.is("$text")) return !1;
													if (!i.hasAttribute("linkHref")) return !1;
													const r = o.textNode || o.nodeBefore;
													if (i === r) return !0;
													return Xp(
														n,
														"linkHref",
														i.getAttribute("linkHref"),
														t,
													).containsRange(t.createRange(n, o), !0);
												})(t.model) &&
												(n = e.getAttributes()));
								},
								{ priority: "high" },
							),
							this.listenTo(
								t.model,
								"insertContent",
								(e, [i]) => {
									(o = !1),
										Mm(t) &&
											n &&
											(t.model.change((t) => {
												for (const [e, o] of n) t.setAttribute(e, o, i);
											}),
											(n = null));
								},
								{ priority: "high" },
							);
					}
					_handleDeleteContentAfterLink() {
						const t = this.editor,
							e = t.model,
							n = e.document.selection,
							o = t.editing.view;
						let i = !1,
							r = !1;
						this.listenTo(
							o.document,
							"delete",
							(t, e) => {
								r = "backward" === e.direction;
							},
							{ priority: "high" },
						),
							this.listenTo(
								e,
								"deleteContent",
								() => {
									i = !1;
									const t = n.getFirstPosition(),
										o = n.getAttribute("linkHref");
									if (!o) return;
									const r = Xp(t, "linkHref", o, e);
									i = r.containsPosition(t) || r.end.isEqual(t);
								},
								{ priority: "high" },
							),
							this.listenTo(
								e,
								"deleteContent",
								() => {
									r &&
										((r = !1),
										i ||
											t.model.enqueueChange((t) => {
												Om(t, Nm(e.schema));
											}));
								},
								{ priority: "low" },
							);
					}
				}
				function Om(t, e) {
					t.removeSelectionAttribute("linkHref");
					for (const n of e) t.removeSelectionAttribute(n);
				}
				function Mm(t) {
					return t.model.change((t) => t.batch).isTyping;
				}
				function Nm(t) {
					return t
						.getDefinition("$text")
						.allowAttributes.filter((t) => t.startsWith("link"));
				}
				var Vm = n(53),
					Lm = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Vm.a, Lm), Vm.a.locals;
				class jm extends fu {
					constructor(t, e) {
						super(t);
						const n = t.t;
						(this.focusTracker = new xa()),
							(this.keystrokes = new Da()),
							(this.urlInputView = this._createUrlInput()),
							(this.saveButtonView = this._createButton(
								n("Save"),
								Nu.check,
								"ck-button-save",
							)),
							(this.saveButtonView.type = "submit"),
							(this.cancelButtonView = this._createButton(
								n("Cancel"),
								Nu.cancel,
								"ck-button-cancel",
								"cancel",
							)),
							(this._manualDecoratorSwitches =
								this._createManualDecoratorSwitches(e)),
							(this.children = this._createFormChildren(e.manualDecorators)),
							(this._focusables = new Ud()),
							(this._focusCycler = new dh({
								focusables: this._focusables,
								focusTracker: this.focusTracker,
								keystrokeHandler: this.keystrokes,
								actions: { focusPrevious: "shift + tab", focusNext: "tab" },
							}));
						const o = ["ck", "ck-link-form", "ck-responsive-form"];
						e.manualDecorators.length &&
							o.push("ck-link-form_layout-vertical", "ck-vertical-form"),
							this.setTemplate({
								tag: "form",
								attributes: { class: o, tabindex: "-1" },
								children: this.children,
							}),
							Lu(this);
					}
					getDecoratorSwitchesState() {
						return Array.from(this._manualDecoratorSwitches).reduce(
							(t, e) => ((t[e.name] = e.isOn), t),
							{},
						);
					}
					render() {
						super.render(), ju({ view: this });
						[
							this.urlInputView,
							...this._manualDecoratorSwitches,
							this.saveButtonView,
							this.cancelButtonView,
						].forEach((t) => {
							this._focusables.add(t), this.focusTracker.add(t.element);
						}),
							this.keystrokes.listenTo(this.element);
					}
					destroy() {
						super.destroy(),
							this.focusTracker.destroy(),
							this.keystrokes.destroy();
					}
					focus() {
						this._focusCycler.focusFirst();
					}
					_createUrlInput() {
						const t = this.locale.t,
							e = new Zh(this.locale, tp);
						return (e.label = t("Link URL")), e;
					}
					_createButton(t, e, n, o) {
						const i = new Ju(this.locale);
						return (
							i.set({ label: t, icon: e, tooltip: !0 }),
							i.extendTemplate({ attributes: { class: n } }),
							o && i.delegate("execute").to(this, o),
							i
						);
					}
					_createManualDecoratorSwitches(t) {
						const e = this.createCollection();
						for (const n of t.manualDecorators) {
							const o = new Xu(this.locale);
							o.set({ name: n.id, label: n.label, withText: !0 }),
								o
									.bind("isOn")
									.toMany([n, t], "value", (t, e) =>
										void 0 === e && void 0 === t ? n.defaultValue : t,
									),
								o.on("execute", () => {
									n.set("value", !o.isOn);
								}),
								e.add(o);
						}
						return e;
					}
					_createFormChildren(t) {
						const e = this.createCollection();
						if ((e.add(this.urlInputView), t.length)) {
							const t = new fu();
							t.setTemplate({
								tag: "ul",
								children: this._manualDecoratorSwitches.map((t) => ({
									tag: "li",
									children: [t],
									attributes: { class: ["ck", "ck-list__item"] },
								})),
								attributes: { class: ["ck", "ck-reset", "ck-list"] },
							}),
								e.add(t);
						}
						return e.add(this.saveButtonView), e.add(this.cancelButtonView), e;
					}
				}
				var Hm = n(54),
					$m = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Hm.a, $m), Hm.a.locals;
				class qm extends fu {
					constructor(t) {
						super(t);
						const e = t.t;
						(this.focusTracker = new xa()),
							(this.keystrokes = new Da()),
							(this.previewButtonView = this._createPreviewButton()),
							(this.unlinkButtonView = this._createButton(
								e("Unlink"),
								'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>',
								"unlink",
							)),
							(this.editButtonView = this._createButton(
								e("Edit link"),
								Nu.pencil,
								"edit",
							)),
							this.set("href"),
							(this._focusables = new Ud()),
							(this._focusCycler = new dh({
								focusables: this._focusables,
								focusTracker: this.focusTracker,
								keystrokeHandler: this.keystrokes,
								actions: { focusPrevious: "shift + tab", focusNext: "tab" },
							})),
							this.setTemplate({
								tag: "div",
								attributes: {
									class: ["ck", "ck-link-actions", "ck-responsive-form"],
									tabindex: "-1",
								},
								children: [
									this.previewButtonView,
									this.editButtonView,
									this.unlinkButtonView,
								],
							});
					}
					render() {
						super.render();
						[
							this.previewButtonView,
							this.editButtonView,
							this.unlinkButtonView,
						].forEach((t) => {
							this._focusables.add(t), this.focusTracker.add(t.element);
						}),
							this.keystrokes.listenTo(this.element);
					}
					destroy() {
						super.destroy(),
							this.focusTracker.destroy(),
							this.keystrokes.destroy();
					}
					focus() {
						this._focusCycler.focusFirst();
					}
					_createButton(t, e, n) {
						const o = new Ju(this.locale);
						return (
							o.set({ label: t, icon: e, tooltip: !0 }),
							o.delegate("execute").to(this, n),
							o
						);
					}
					_createPreviewButton() {
						const t = new Ju(this.locale),
							e = this.bindTemplate,
							n = this.t;
						return (
							t.set({ withText: !0, tooltip: n("Open link in new tab") }),
							t.extendTemplate({
								attributes: {
									class: ["ck", "ck-link-actions__preview"],
									href: e.to("href", (t) => t && Ef(t)),
									target: "_blank",
									rel: "noopener noreferrer",
								},
							}),
							t
								.bind("label")
								.to(this, "href", (t) => t || n("This link has no URL")),
							t.bind("isEnabled").to(this, "href", (t) => !!t),
							(t.template.tag = "a"),
							(t.template.eventListeners = {}),
							t
						);
					}
				}
				const Um = "link-ui";
				class Wm extends R {
					static get requires() {
						return [cp];
					}
					static get pluginName() {
						return "LinkUI";
					}
					init() {
						const t = this.editor;
						t.editing.view.addObserver(Td),
							(this.actionsView = this._createActionsView()),
							(this.formView = this._createFormView()),
							(this._balloon = t.plugins.get(cp)),
							this._createToolbarLinkButton(),
							this._enableUserBalloonInteractions(),
							t.conversion
								.for("editingDowncast")
								.markerToHighlight({
									model: Um,
									view: { classes: ["ck-fake-link-selection"] },
								}),
							t.conversion
								.for("editingDowncast")
								.markerToElement({
									model: Um,
									view: {
										name: "span",
										classes: [
											"ck-fake-link-selection",
											"ck-fake-link-selection_collapsed",
										],
									},
								});
					}
					destroy() {
						super.destroy(), this.formView.destroy();
					}
					_createActionsView() {
						const t = this.editor,
							e = new qm(t.locale),
							n = t.commands.get("link"),
							o = t.commands.get("unlink");
						return (
							e.bind("href").to(n, "value"),
							e.editButtonView.bind("isEnabled").to(n),
							e.unlinkButtonView.bind("isEnabled").to(o),
							this.listenTo(e, "edit", () => {
								this._addFormView();
							}),
							this.listenTo(e, "unlink", () => {
								t.execute("unlink"), this._hideUI();
							}),
							e.keystrokes.set("Esc", (t, e) => {
								this._hideUI(), e();
							}),
							e.keystrokes.set(xf, (t, e) => {
								this._addFormView(), e();
							}),
							e
						);
					}
					_createFormView() {
						const t = this.editor,
							e = t.commands.get("link"),
							n = t.config.get("link.defaultProtocol"),
							o = new jm(t.locale, e);
						return (
							o.urlInputView.fieldView.bind("value").to(e, "value"),
							o.urlInputView.bind("isReadOnly").to(e, "isEnabled", (t) => !t),
							o.saveButtonView.bind("isEnabled").to(e),
							this.listenTo(o, "submit", () => {
								const { value: e } = o.urlInputView.fieldView.element,
									i = Bf(e, n);
								t.execute("link", i, o.getDecoratorSwitchesState()),
									this._closeFormView();
							}),
							this.listenTo(o, "cancel", () => {
								this._closeFormView();
							}),
							o.keystrokes.set("Esc", (t, e) => {
								this._closeFormView(), e();
							}),
							o
						);
					}
					_createToolbarLinkButton() {
						const t = this.editor,
							e = t.commands.get("link"),
							n = t.t;
						t.keystrokes.set(xf, (t, n) => {
							n(), e.isEnabled && this._showUI(!0);
						}),
							t.ui.componentFactory.add("link", (t) => {
								const o = new Ju(t);
								return (
									(o.isEnabled = !0),
									(o.label = n("Link")),
									(o.icon =
										'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>'),
									(o.keystroke = xf),
									(o.tooltip = !0),
									(o.isToggleable = !0),
									o.bind("isEnabled").to(e, "isEnabled"),
									o.bind("isOn").to(e, "value", (t) => !!t),
									this.listenTo(o, "execute", () => this._showUI(!0)),
									o
								);
							});
					}
					_enableUserBalloonInteractions() {
						const t = this.editor.editing.view.document;
						this.listenTo(t, "click", () => {
							this._getSelectedLinkElement() && this._showUI();
						}),
							this.editor.keystrokes.set(
								"Tab",
								(t, e) => {
									this._areActionsVisible &&
										!this.actionsView.focusTracker.isFocused &&
										(this.actionsView.focus(), e());
								},
								{ priority: "high" },
							),
							this.editor.keystrokes.set("Esc", (t, e) => {
								this._isUIVisible && (this._hideUI(), e());
							}),
							Vu({
								emitter: this.formView,
								activator: () => this._isUIInPanel,
								contextElements: [this._balloon.view.element],
								callback: () => this._hideUI(),
							});
					}
					_addActionsView() {
						this._areActionsInPanel ||
							this._balloon.add({
								view: this.actionsView,
								position: this._getBalloonPositionData(),
							});
					}
					_addFormView() {
						if (this._isFormInPanel) return;
						const t = this.editor.commands.get("link");
						this.formView.disableCssTransitions(),
							this._balloon.add({
								view: this.formView,
								position: this._getBalloonPositionData(),
							}),
							this._balloon.visibleView === this.formView &&
								this.formView.urlInputView.fieldView.select(),
							this.formView.enableCssTransitions(),
							(this.formView.urlInputView.fieldView.element.value =
								t.value || "");
					}
					_closeFormView() {
						const t = this.editor.commands.get("link");
						t.restoreManualDecoratorStates(),
							void 0 !== t.value ? this._removeFormView() : this._hideUI();
					}
					_removeFormView() {
						this._isFormInPanel &&
							(this.formView.saveButtonView.focus(),
							this._balloon.remove(this.formView),
							this.editor.editing.view.focus(),
							this._hideFakeVisualSelection());
					}
					_showUI(t = !1) {
						this._getSelectedLinkElement()
							? (this._areActionsVisible
									? this._addFormView()
									: this._addActionsView(),
								t && this._balloon.showStack("main"))
							: (this._showFakeVisualSelection(),
								this._addActionsView(),
								t && this._balloon.showStack("main"),
								this._addFormView()),
							this._startUpdatingUI();
					}
					_hideUI() {
						if (!this._isUIInPanel) return;
						const t = this.editor;
						this.stopListening(t.ui, "update"),
							this.stopListening(this._balloon, "change:visibleView"),
							t.editing.view.focus(),
							this._removeFormView(),
							this._balloon.remove(this.actionsView),
							this._hideFakeVisualSelection();
					}
					_startUpdatingUI() {
						const t = this.editor,
							e = t.editing.view.document;
						let n = this._getSelectedLinkElement(),
							o = r();
						const i = () => {
							const t = this._getSelectedLinkElement(),
								e = r();
							(n && !t) || (!n && e !== o)
								? this._hideUI()
								: this._isUIVisible &&
									this._balloon.updatePosition(this._getBalloonPositionData()),
								(n = t),
								(o = e);
						};
						function r() {
							return e.selection.focus
								.getAncestors()
								.reverse()
								.find((t) => t.is("element"));
						}
						this.listenTo(t.ui, "update", i),
							this.listenTo(this._balloon, "change:visibleView", i);
					}
					get _isFormInPanel() {
						return this._balloon.hasView(this.formView);
					}
					get _areActionsInPanel() {
						return this._balloon.hasView(this.actionsView);
					}
					get _areActionsVisible() {
						return this._balloon.visibleView === this.actionsView;
					}
					get _isUIInPanel() {
						return this._isFormInPanel || this._areActionsInPanel;
					}
					get _isUIVisible() {
						return (
							this._balloon.visibleView == this.formView ||
							this._areActionsVisible
						);
					}
					_getBalloonPositionData() {
						const t = this.editor.editing.view,
							e = this.editor.model,
							n = t.document;
						let o = null;
						if (e.markers.has(Um)) {
							const e = Array.from(
									this.editor.editing.mapper.markerNameToElements(Um),
								),
								n = t.createRange(
									t.createPositionBefore(e[0]),
									t.createPositionAfter(e[e.length - 1]),
								);
							o = t.domConverter.viewRangeToDom(n);
						} else
							o = () => {
								const e = this._getSelectedLinkElement();
								return e
									? t.domConverter.mapViewToDom(e)
									: t.domConverter.viewRangeToDom(n.selection.getFirstRange());
							};
						return { target: o };
					}
					_getSelectedLinkElement() {
						const t = this.editor.editing.view,
							e = t.document.selection,
							n = e.getSelectedElement();
						if (e.isCollapsed || (n && mg(n))) return Km(e.getFirstPosition());
						{
							const n = e.getFirstRange().getTrimmed(),
								o = Km(n.start),
								i = Km(n.end);
							return o && o == i && t.createRangeIn(o).getTrimmed().isEqual(n)
								? o
								: null;
						}
					}
					_showFakeVisualSelection() {
						const t = this.editor.model;
						t.change((e) => {
							const n = t.document.selection.getFirstRange();
							if (t.markers.has(Um)) e.updateMarker(Um, { range: n });
							else if (n.start.isAtEnd) {
								const o = n.start.getLastMatchingPosition(
									({ item: e }) => !t.schema.isContent(e),
									{ boundaries: n },
								);
								e.addMarker(Um, {
									usingOperation: !1,
									affectsData: !1,
									range: e.createRange(o, n.end),
								});
							} else
								e.addMarker(Um, {
									usingOperation: !1,
									affectsData: !1,
									range: n,
								});
						});
					}
					_hideFakeVisualSelection() {
						const t = this.editor.model;
						t.markers.has(Um) &&
							t.change((t) => {
								t.removeMarker(Um);
							});
					}
				}
				function Km(t) {
					return t.getAncestors().find((t) => {
						return (
							(e = t).is("attributeElement") && !!e.getCustomProperty("link")
						);
						var e;
					});
				}
				class Gm extends M {
					constructor(t, e) {
						super(t), (this.type = e);
					}
					refresh() {
						(this.value = this._getValue()),
							(this.isEnabled = this._checkEnabled());
					}
					execute(t = {}) {
						const e = this.editor.model,
							n = e.document,
							o = Array.from(n.selection.getSelectedBlocks()).filter((t) =>
								Ym(t, e.schema),
							),
							i = void 0 !== t.forceValue ? !t.forceValue : this.value;
						e.change((t) => {
							if (i) {
								let e = o[o.length - 1].nextSibling,
									n = Number.POSITIVE_INFINITY,
									i = [];
								for (
									;
									e &&
									"listItem" == e.name &&
									0 !== e.getAttribute("listIndent");
								) {
									const t = e.getAttribute("listIndent");
									t < n && (n = t);
									const o = t - n;
									i.push({ element: e, listIndent: o }), (e = e.nextSibling);
								}
								i = i.reverse();
								for (const e of i)
									t.setAttribute("listIndent", e.listIndent, e.element);
							}
							if (!i) {
								let t = Number.POSITIVE_INFINITY;
								for (const e of o)
									e.is("element", "listItem") &&
										e.getAttribute("listIndent") < t &&
										(t = e.getAttribute("listIndent"));
								(t = 0 === t ? 1 : t), Jm(o, !0, t), Jm(o, !1, t);
							}
							for (const e of o.reverse())
								i && "listItem" == e.name
									? t.rename(e, "paragraph")
									: i || "listItem" == e.name
										? i ||
											"listItem" != e.name ||
											e.getAttribute("listType") == this.type ||
											t.setAttribute("listType", this.type, e)
										: (t.setAttributes(
												{ listType: this.type, listIndent: 0 },
												e,
											),
											t.rename(e, "listItem"));
							this.fire("_executeCleanup", o);
						});
					}
					_getValue() {
						const t = ya(
							this.editor.model.document.selection.getSelectedBlocks(),
						);
						return (
							!!t &&
							t.is("element", "listItem") &&
							t.getAttribute("listType") == this.type
						);
					}
					_checkEnabled() {
						if (this.value) return !0;
						const t = this.editor.model.document.selection,
							e = this.editor.model.schema,
							n = ya(t.getSelectedBlocks());
						return !!n && Ym(n, e);
					}
				}
				function Jm(t, e, n) {
					const o = e ? t[0] : t[t.length - 1];
					if (o.is("element", "listItem")) {
						let i = o[e ? "previousSibling" : "nextSibling"],
							r = o.getAttribute("listIndent");
						for (
							;
							i &&
							i.is("element", "listItem") &&
							i.getAttribute("listIndent") >= n;
						)
							r > i.getAttribute("listIndent") &&
								(r = i.getAttribute("listIndent")),
								i.getAttribute("listIndent") == r &&
									t[e ? "unshift" : "push"](i),
								(i = i[e ? "previousSibling" : "nextSibling"]);
					}
				}
				function Ym(t, e) {
					return e.checkChild(t.parent, "listItem") && !e.isObject(t);
				}
				class Qm extends M {
					constructor(t, e) {
						super(t), (this._indentBy = "forward" == e ? 1 : -1);
					}
					refresh() {
						this.isEnabled = this._checkEnabled();
					}
					execute() {
						const t = this.editor.model,
							e = t.document;
						let n = Array.from(e.selection.getSelectedBlocks());
						t.change((t) => {
							const e = n[n.length - 1];
							let o = e.nextSibling;
							for (
								;
								o &&
								"listItem" == o.name &&
								o.getAttribute("listIndent") > e.getAttribute("listIndent");
							)
								n.push(o), (o = o.nextSibling);
							this._indentBy < 0 && (n = n.reverse());
							for (const e of n) {
								const n = e.getAttribute("listIndent") + this._indentBy;
								n < 0
									? t.rename(e, "paragraph")
									: t.setAttribute("listIndent", n, e);
							}
							this.fire("_executeCleanup", n);
						});
					}
					_checkEnabled() {
						const t = ya(
							this.editor.model.document.selection.getSelectedBlocks(),
						);
						if (!t || !t.is("element", "listItem")) return !1;
						if (this._indentBy > 0) {
							const e = t.getAttribute("listIndent"),
								n = t.getAttribute("listType");
							let o = t.previousSibling;
							for (
								;
								o &&
								o.is("element", "listItem") &&
								o.getAttribute("listIndent") >= e;
							) {
								if (o.getAttribute("listIndent") == e)
									return o.getAttribute("listType") == n;
								o = o.previousSibling;
							}
							return !1;
						}
						return !0;
					}
				}
				function Xm(t, e) {
					const n = e.mapper,
						o = e.writer,
						i = "numbered" == t.getAttribute("listType") ? "ol" : "ul",
						r = (function (t) {
							const e = t.createContainerElement("li");
							return (e.getFillerOffset = lk), e;
						})(o),
						s = o.createContainerElement(i, null);
					return o.insert(o.createPositionAt(s, 0), r), n.bindElements(t, r), r;
				}
				function Zm(t, e, n, o) {
					const i = e.parent,
						r = n.mapper,
						s = n.writer;
					let a = r.toViewPosition(o.createPositionBefore(t));
					const c = nk(t.previousSibling, {
							sameIndent: !0,
							smallerIndent: !0,
							listIndent: t.getAttribute("listIndent"),
						}),
						l = t.previousSibling;
					if (
						c &&
						c.getAttribute("listIndent") == t.getAttribute("listIndent")
					) {
						const t = r.toViewElement(c);
						a = s.breakContainer(s.createPositionAfter(t));
					} else if (l && "listItem" == l.name) {
						a = r.toViewPosition(o.createPositionAt(l, "end"));
						const t = r.findMappedViewAncestor(a),
							e = ik(t);
						a = e ? s.createPositionBefore(e) : s.createPositionAt(t, "end");
					} else a = r.toViewPosition(o.createPositionBefore(t));
					if (((a = ek(a)), s.insert(a, i), l && "listItem" == l.name)) {
						const t = r.toViewElement(l),
							n = s
								.createRange(s.createPositionAt(t, 0), a)
								.getWalker({ ignoreElementEnd: !0 });
						for (const t of n)
							if (t.item.is("element", "li")) {
								const o = s.breakContainer(s.createPositionBefore(t.item)),
									i = t.item.parent,
									r = s.createPositionAt(e, "end");
								tk(s, r.nodeBefore, r.nodeAfter),
									s.move(s.createRangeOn(i), r),
									(n.position = o);
							}
					} else {
						const n = i.nextSibling;
						if (n && (n.is("element", "ul") || n.is("element", "ol"))) {
							let o = null;
							for (const e of n.getChildren()) {
								const n = r.toModelElement(e);
								if (
									!(
										n &&
										n.getAttribute("listIndent") > t.getAttribute("listIndent")
									)
								)
									break;
								o = e;
							}
							o &&
								(s.breakContainer(s.createPositionAfter(o)),
								s.move(
									s.createRangeOn(o.parent),
									s.createPositionAt(e, "end"),
								));
						}
					}
					tk(s, i, i.nextSibling), tk(s, i.previousSibling, i);
				}
				function tk(t, e, n) {
					return !e ||
						!n ||
						("ul" != e.name && "ol" != e.name) ||
						e.name != n.name ||
						e.getAttribute("class") !== n.getAttribute("class")
						? null
						: t.mergeContainers(t.createPositionAfter(e));
				}
				function ek(t) {
					return t.getLastMatchingPosition((t) => t.item.is("uiElement"));
				}
				function nk(t, e) {
					const n = !!e.sameIndent,
						o = !!e.smallerIndent,
						i = e.listIndent;
					let r = t;
					for (; r && "listItem" == r.name; ) {
						const t = r.getAttribute("listIndent");
						if ((n && i == t) || (o && i > t)) return r;
						r = "forward" === e.direction ? r.nextSibling : r.previousSibling;
					}
					return null;
				}
				function ok(t, e, n, o) {
					t.ui.componentFactory.add(e, (i) => {
						const r = t.commands.get(e),
							s = new Ju(i);
						return (
							s.set({ label: n, icon: o, tooltip: !0, isToggleable: !0 }),
							s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"),
							s.on("execute", () => {
								t.execute(e), t.editing.view.focus();
							}),
							s
						);
					});
				}
				function ik(t) {
					for (const e of t.getChildren())
						if ("ul" == e.name || "ol" == e.name) return e;
					return null;
				}
				function rk(t, e) {
					const n = [],
						o = t.parent,
						i = {
							ignoreElementEnd: !1,
							startPosition: t,
							shallow: !0,
							direction: e,
						},
						r = o.getAttribute("listIndent"),
						s = [...new Oa(i)]
							.filter((t) => t.item.is("element"))
							.map((t) => t.item);
					for (const t of s) {
						if (!t.is("element", "listItem")) break;
						if (t.getAttribute("listIndent") < r) break;
						if (!(t.getAttribute("listIndent") > r)) {
							if (t.getAttribute("listType") !== o.getAttribute("listType"))
								break;
							if (t.getAttribute("listStyle") !== o.getAttribute("listStyle"))
								break;
							if (
								t.getAttribute("listReversed") !==
								o.getAttribute("listReversed")
							)
								break;
							if (t.getAttribute("listStart") !== o.getAttribute("listStart"))
								break;
							"backward" === e ? n.unshift(t) : n.push(t);
						}
					}
					return n;
				}
				function sk(t) {
					let e = [...t.document.selection.getSelectedBlocks()]
						.filter((t) => t.is("element", "listItem"))
						.map((e) => {
							const n = t.change((t) => t.createPositionAt(e, 0));
							return [...rk(n, "backward"), ...rk(n, "forward")];
						})
						.flat();
					return (e = [...new Set(e)]), e;
				}
				const ak = ["disc", "circle", "square"],
					ck = [
						"decimal",
						"decimal-leading-zero",
						"lower-roman",
						"upper-roman",
						"lower-latin",
						"upper-latin",
					];
				function lk() {
					const t =
						!this.isEmpty &&
						("ul" == this.getChild(0).name || "ol" == this.getChild(0).name);
					return this.isEmpty || t ? 0 : wi.call(this);
				}
				function dk(t) {
					return (e, n, o) => {
						const i = o.consumable;
						if (
							!i.test(n.item, "insert") ||
							!i.test(n.item, "attribute:listType") ||
							!i.test(n.item, "attribute:listIndent")
						)
							return;
						i.consume(n.item, "insert"),
							i.consume(n.item, "attribute:listType"),
							i.consume(n.item, "attribute:listIndent");
						const r = n.item;
						Zm(r, Xm(r, o), o, t);
					};
				}
				function uk(t, e, n) {
					if (!n.consumable.test(e.item, t.name)) return;
					const o = n.mapper.toViewElement(e.item),
						i = n.writer;
					i.breakContainer(i.createPositionBefore(o)),
						i.breakContainer(i.createPositionAfter(o));
					const r = o.parent,
						s = "numbered" == e.attributeNewValue ? "ol" : "ul";
					i.rename(s, r);
				}
				function hk(t, e, n) {
					n.consumable.consume(e.item, t.name);
					const o = n.mapper.toViewElement(e.item).parent,
						i = n.writer;
					tk(i, o, o.nextSibling), tk(i, o.previousSibling, o);
				}
				function pk(t, e, n) {
					if (n.consumable.test(e.item, t.name) && "listItem" != e.item.name) {
						let t = n.mapper.toViewPosition(e.range.start);
						const o = n.writer,
							i = [];
						for (
							;
							("ul" == t.parent.name || "ol" == t.parent.name) &&
							((t = o.breakContainer(t)), "li" == t.parent.name);
						) {
							const e = t,
								n = o.createPositionAt(t.parent, "end");
							if (!e.isEqual(n)) {
								const t = o.remove(o.createRange(e, n));
								i.push(t);
							}
							t = o.createPositionAfter(t.parent);
						}
						if (i.length > 0) {
							for (let e = 0; e < i.length; e++) {
								const n = t.nodeBefore;
								if (((t = o.insert(t, i[e]).end), e > 0)) {
									const e = tk(o, n, n.nextSibling);
									e && e.parent == n && t.offset--;
								}
							}
							tk(o, t.nodeBefore, t.nodeAfter);
						}
					}
				}
				function gk(t, e, n) {
					const o = n.mapper.toViewPosition(e.position),
						i = o.nodeBefore,
						r = o.nodeAfter;
					tk(n.writer, i, r);
				}
				function fk(t, e, n) {
					if (n.consumable.consume(e.viewItem, { name: !0 })) {
						const t = n.writer,
							o = t.createElement("listItem"),
							i = (function (t) {
								let e = 0,
									n = t.parent;
								for (; n; ) {
									if (n.is("element", "li")) e++;
									else {
										const t = n.previousSibling;
										t && t.is("element", "li") && e++;
									}
									n = n.parent;
								}
								return e;
							})(e.viewItem);
						t.setAttribute("listIndent", i, o);
						const r =
							e.viewItem.parent && "ol" == e.viewItem.parent.name
								? "numbered"
								: "bulleted";
						if (
							(t.setAttribute("listType", r, o),
							!n.safeInsert(o, e.modelCursor))
						)
							return;
						const s = (function (t, e, n) {
							const { writer: o, schema: i } = n;
							let r = o.createPositionAfter(t);
							for (const s of e)
								if ("ul" == s.name || "ol" == s.name)
									r = n.convertItem(s, r).modelCursor;
								else {
									const e = n.convertItem(s, o.createPositionAt(t, "end")),
										a = e.modelRange.start.nodeAfter;
									a &&
										a.is("element") &&
										!i.checkChild(t, a.name) &&
										((t = e.modelCursor.parent.is("element", "listItem")
											? e.modelCursor.parent
											: Ak(e.modelCursor)),
										(r = o.createPositionAfter(t)));
								}
							return r;
						})(o, e.viewItem.getChildren(), n);
						(e.modelRange = t.createRange(e.modelCursor, s)),
							n.updateConversionResult(o, e);
					}
				}
				function mk(t, e, n) {
					if (n.consumable.test(e.viewItem, { name: !0 })) {
						const t = Array.from(e.viewItem.getChildren());
						for (const e of t) {
							!(e.is("element", "li") || Ck(e)) && e._remove();
						}
					}
				}
				function kk(t, e, n) {
					if (n.consumable.test(e.viewItem, { name: !0 })) {
						if (0 === e.viewItem.childCount) return;
						const t = [...e.viewItem.getChildren()];
						let n = !1;
						for (const e of t) n && !Ck(e) && e._remove(), Ck(e) && (n = !0);
					}
				}
				function bk(t) {
					return (e, n) => {
						if (n.isPhantom) return;
						const o = n.modelPosition.nodeBefore;
						if (o && o.is("element", "listItem")) {
							const e = n.mapper.toViewElement(o),
								i = e.getAncestors().find(Ck),
								r = t.createPositionAt(e, 0).getWalker();
							for (const t of r) {
								if ("elementStart" == t.type && t.item.is("element", "li")) {
									n.viewPosition = t.previousPosition;
									break;
								}
								if ("elementEnd" == t.type && t.item == i) {
									n.viewPosition = t.nextPosition;
									break;
								}
							}
						}
					};
				}
				function wk(t, [e, n, o]) {
					let i,
						r = e.is("documentFragment") ? e.getChild(0) : e;
					if (
						((i = n ? this.createSelection(n, o) : this.document.selection),
						r && r.is("element", "listItem"))
					) {
						const t = i.getFirstPosition();
						let e = null;
						if (
							(t.parent.is("element", "listItem")
								? (e = t.parent)
								: t.nodeBefore &&
									t.nodeBefore.is("element", "listItem") &&
									(e = t.nodeBefore),
							e)
						) {
							const t = e.getAttribute("listIndent");
							if (t > 0)
								for (; r && r.is("element", "listItem"); )
									r._setAttribute(
										"listIndent",
										r.getAttribute("listIndent") + t,
									),
										(r = r.nextSibling);
						}
					}
				}
				function Ak(t) {
					const e = new Oa({ startPosition: t });
					let n;
					do {
						n = e.next();
					} while (!n.value.item.is("element", "listItem"));
					return n.value.item;
				}
				function _k(t, e, n, o, i, r) {
					const s = nk(e.nodeBefore, {
							sameIndent: !0,
							smallerIndent: !0,
							listIndent: t,
							foo: "b",
						}),
						a = i.mapper,
						c = i.writer,
						l = s ? s.getAttribute("listIndent") : null;
					let d;
					if (s)
						if (l == t) {
							const t = a.toViewElement(s).parent;
							d = c.createPositionAfter(t);
						} else {
							const t = r.createPositionAt(s, "end");
							d = a.toViewPosition(t);
						}
					else d = n;
					d = ek(d);
					for (const t of [...o.getChildren()])
						Ck(t) &&
							((d = c.move(c.createRangeOn(t), d).end),
							tk(c, t, t.nextSibling),
							tk(c, t.previousSibling, t));
				}
				function Ck(t) {
					return t.is("element", "ol") || t.is("element", "ul");
				}
				class vk extends R {
					static get pluginName() {
						return "ListEditing";
					}
					static get requires() {
						return [gg, Ip];
					}
					init() {
						const t = this.editor;
						t.model.schema.register("listItem", {
							inheritAllFrom: "$block",
							allowAttributes: ["listType", "listIndent"],
						});
						const e = t.data,
							n = t.editing;
						var o;
						t.model.document.registerPostFixer((e) =>
							(function (t, e) {
								const n = t.document.differ.getChanges(),
									o = new Map();
								let i = !1;
								for (const o of n)
									if ("insert" == o.type && "listItem" == o.name) r(o.position);
									else if ("insert" == o.type && "listItem" != o.name) {
										if ("$text" != o.name) {
											const n = o.position.nodeAfter;
											n.hasAttribute("listIndent") &&
												(e.removeAttribute("listIndent", n), (i = !0)),
												n.hasAttribute("listType") &&
													(e.removeAttribute("listType", n), (i = !0)),
												n.hasAttribute("listStyle") &&
													(e.removeAttribute("listStyle", n), (i = !0)),
												n.hasAttribute("listReversed") &&
													(e.removeAttribute("listReversed", n), (i = !0)),
												n.hasAttribute("listStart") &&
													(e.removeAttribute("listStart", n), (i = !0));
											for (const e of Array.from(t.createRangeIn(n)).filter(
												(t) => t.item.is("element", "listItem"),
											))
												r(e.previousPosition);
										}
										r(o.position.getShiftedBy(o.length));
									} else
										"remove" == o.type && "listItem" == o.name
											? r(o.position)
											: (("attribute" == o.type &&
													"listIndent" == o.attributeKey) ||
													("attribute" == o.type &&
														"listType" == o.attributeKey)) &&
												r(o.range.start);
								for (const t of o.values()) s(t), a(t);
								return i;
								function r(t) {
									const e = t.nodeBefore;
									if (e && e.is("element", "listItem")) {
										let t = e;
										if (o.has(t)) return;
										for (
											let e = t.previousSibling;
											e && e.is("element", "listItem");
											e = t.previousSibling
										)
											if (((t = e), o.has(t))) return;
										o.set(e, t);
									} else {
										const e = t.nodeAfter;
										e && e.is("element", "listItem") && o.set(e, e);
									}
								}
								function s(t) {
									let n = 0,
										o = null;
									for (; t && t.is("element", "listItem"); ) {
										const r = t.getAttribute("listIndent");
										if (r > n) {
											let s;
											null === o
												? ((o = r - n), (s = n))
												: (o > r && (o = r), (s = r - o)),
												e.setAttribute("listIndent", s, t),
												(i = !0);
										} else (o = null), (n = t.getAttribute("listIndent") + 1);
										t = t.nextSibling;
									}
								}
								function a(t) {
									let n = [],
										o = null;
									for (; t && t.is("element", "listItem"); ) {
										const r = t.getAttribute("listIndent");
										if (
											(o &&
												o.getAttribute("listIndent") > r &&
												(n = n.slice(0, r + 1)),
											0 != r)
										)
											if (n[r]) {
												const o = n[r];
												t.getAttribute("listType") != o &&
													(e.setAttribute("listType", o, t), (i = !0));
											} else n[r] = t.getAttribute("listType");
										(o = t), (t = t.nextSibling);
									}
								}
							})(t.model, e),
						),
							n.mapper.registerViewToModelLength("li", yk),
							e.mapper.registerViewToModelLength("li", yk),
							n.mapper.on("modelToViewPosition", bk(n.view)),
							n.mapper.on(
								"viewToModelPosition",
								((o = t.model),
								(t, e) => {
									const n = e.viewPosition,
										i = n.parent,
										r = e.mapper;
									if ("ul" == i.name || "ol" == i.name) {
										if (n.isAtEnd) {
											const t = r.toModelElement(n.nodeBefore),
												i = r.getModelLength(n.nodeBefore);
											e.modelPosition = o
												.createPositionBefore(t)
												.getShiftedBy(i);
										} else {
											const t = r.toModelElement(n.nodeAfter);
											e.modelPosition = o.createPositionBefore(t);
										}
										t.stop();
									} else if (
										"li" == i.name &&
										n.nodeBefore &&
										("ul" == n.nodeBefore.name || "ol" == n.nodeBefore.name)
									) {
										const s = r.toModelElement(i);
										let a = 1,
											c = n.nodeBefore;
										for (; c && Ck(c); )
											(a += r.getModelLength(c)), (c = c.previousSibling);
										(e.modelPosition = o
											.createPositionBefore(s)
											.getShiftedBy(a)),
											t.stop();
									}
								}),
							),
							e.mapper.on("modelToViewPosition", bk(n.view)),
							t.conversion.for("editingDowncast").add((e) => {
								e.on("insert", pk, { priority: "high" }),
									e.on("insert:listItem", dk(t.model)),
									e.on("attribute:listType:listItem", uk, { priority: "high" }),
									e.on("attribute:listType:listItem", hk, { priority: "low" }),
									e.on(
										"attribute:listIndent:listItem",
										(function (t) {
											return (e, n, o) => {
												if (
													!o.consumable.consume(n.item, "attribute:listIndent")
												)
													return;
												const i = o.mapper.toViewElement(n.item),
													r = o.writer;
												r.breakContainer(r.createPositionBefore(i)),
													r.breakContainer(r.createPositionAfter(i));
												const s = i.parent,
													a = s.previousSibling,
													c = r.createRangeOn(s);
												r.remove(c),
													a && a.nextSibling && tk(r, a, a.nextSibling),
													_k(
														n.attributeOldValue + 1,
														n.range.start,
														c.start,
														i,
														o,
														t,
													),
													Zm(n.item, i, o, t);
												for (const t of n.item.getChildren())
													o.consumable.consume(t, "insert");
											};
										})(t.model),
									),
									e.on(
										"remove:listItem",
										(function (t) {
											return (e, n, o) => {
												const i = o.mapper
														.toViewPosition(n.position)
														.getLastMatchingPosition(
															(t) => !t.item.is("element", "li"),
														).nodeAfter,
													r = o.writer;
												r.breakContainer(r.createPositionBefore(i)),
													r.breakContainer(r.createPositionAfter(i));
												const s = i.parent,
													a = s.previousSibling,
													c = r.createRangeOn(s),
													l = r.remove(c);
												a && a.nextSibling && tk(r, a, a.nextSibling),
													_k(
														o.mapper
															.toModelElement(i)
															.getAttribute("listIndent") + 1,
														n.position,
														c.start,
														i,
														o,
														t,
													);
												for (const t of r.createRangeIn(l).getItems())
													o.mapper.unbindViewElement(t);
												e.stop();
											};
										})(t.model),
									),
									e.on("remove", gk, { priority: "low" });
							}),
							t.conversion.for("dataDowncast").add((e) => {
								e.on("insert", pk, { priority: "high" }),
									e.on("insert:listItem", dk(t.model));
							}),
							t.conversion.for("upcast").add((t) => {
								t.on("element:ul", mk, { priority: "high" }),
									t.on("element:ol", mk, { priority: "high" }),
									t.on("element:li", kk, { priority: "high" }),
									t.on("element:li", fk);
							}),
							t.model.on("insertContent", wk, { priority: "high" }),
							t.commands.add("numberedList", new Gm(t, "numbered")),
							t.commands.add("bulletedList", new Gm(t, "bulleted")),
							t.commands.add("indentList", new Qm(t, "forward")),
							t.commands.add("outdentList", new Qm(t, "backward"));
						const i = n.view.document;
						this.listenTo(
							i,
							"enter",
							(t, e) => {
								const n = this.editor.model.document,
									o = n.selection.getLastPosition().parent;
								n.selection.isCollapsed &&
									"listItem" == o.name &&
									o.isEmpty &&
									(this.editor.execute("outdentList"),
									e.preventDefault(),
									t.stop());
							},
							{ context: "li" },
						),
							this.listenTo(
								i,
								"delete",
								(t, e) => {
									if ("backward" !== e.direction) return;
									const n = this.editor.model.document.selection;
									if (!n.isCollapsed) return;
									const o = n.getFirstPosition();
									if (!o.isAtStart) return;
									const i = o.parent;
									if ("listItem" !== i.name) return;
									(i.previousSibling &&
										"listItem" === i.previousSibling.name) ||
										(this.editor.execute("outdentList"),
										e.preventDefault(),
										t.stop());
								},
								{ context: "li" },
							),
							this.listenTo(
								t.editing.view.document,
								"tab",
								(e, n) => {
									const o = n.shiftKey ? "outdentList" : "indentList";
									this.editor.commands.get(o).isEnabled &&
										(t.execute(o),
										n.stopPropagation(),
										n.preventDefault(),
										e.stop());
								},
								{ context: "li" },
							);
					}
					afterInit() {
						const t = this.editor.commands,
							e = t.get("indent"),
							n = t.get("outdent");
						e && e.registerChildCommand(t.get("indentList")),
							n && n.registerChildCommand(t.get("outdentList"));
					}
				}
				function yk(t) {
					let e = 1;
					for (const n of t.getChildren())
						if ("ul" == n.name || "ol" == n.name)
							for (const t of n.getChildren()) e += yk(t);
					return e;
				}
				var xk =
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>',
					Dk =
						'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>';
				class Ek extends R {
					static get pluginName() {
						return "ListUI";
					}
					init() {
						const t = this.editor.t;
						ok(this.editor, "numberedList", t("Numbered List"), xk),
							ok(this.editor, "bulletedList", t("Bulleted List"), Dk);
					}
				}
				class Sk extends M {
					constructor(t, e) {
						super(t), (this._defaultType = e);
					}
					refresh() {
						(this.value = this._getValue()),
							(this.isEnabled = this._checkEnabled());
					}
					execute(t = {}) {
						this._tryToConvertItemsToList(t);
						const e = this.editor.model,
							n = sk(e);
						n.length &&
							e.change((e) => {
								for (const o of n)
									e.setAttribute("listStyle", t.type || this._defaultType, o);
							});
					}
					_getValue() {
						const t =
							this.editor.model.document.selection.getFirstPosition().parent;
						return t && t.is("element", "listItem")
							? t.getAttribute("listStyle")
							: null;
					}
					_checkEnabled() {
						const t = this.editor,
							e = t.commands.get("numberedList"),
							n = t.commands.get("bulletedList");
						return e.isEnabled || n.isEnabled;
					}
					_tryToConvertItemsToList(t) {
						if (!t.type) return;
						const e =
							((n = t.type),
							ak.includes(n) ? "bulleted" : ck.includes(n) ? "numbered" : null);
						var n;
						if (!e) return;
						const o = this.editor,
							i = e + "List";
						o.commands.get(i).value || o.execute(i);
					}
				}
				class Bk extends M {
					refresh() {
						const t = this._getValue();
						(this.value = t), (this.isEnabled = null != t);
					}
					execute(t = {}) {
						const e = this.editor.model,
							n = sk(e).filter((t) => "numbered" == t.getAttribute("listType"));
						e.change((e) => {
							for (const o of n)
								e.setAttribute("listReversed", !!t.reversed, o);
						});
					}
					_getValue() {
						const t =
							this.editor.model.document.selection.getFirstPosition().parent;
						return t &&
							t.is("element", "listItem") &&
							"numbered" == t.getAttribute("listType")
							? t.getAttribute("listReversed")
							: null;
					}
				}
				class Tk extends M {
					refresh() {
						const t = this._getValue();
						(this.value = t), (this.isEnabled = null != t);
					}
					execute(t = {}) {
						const e = this.editor.model,
							n = sk(e).filter((t) => "numbered" == t.getAttribute("listType"));
						e.change((e) => {
							for (const o of n)
								e.setAttribute("listStart", t.startIndex || 1, o);
						});
					}
					_getValue() {
						const t =
							this.editor.model.document.selection.getFirstPosition().parent;
						return t &&
							t.is("element", "listItem") &&
							"numbered" == t.getAttribute("listType")
							? t.getAttribute("listStart")
							: null;
					}
				}
				const Pk = "default";
				class Fk extends R {
					static get requires() {
						return [vk];
					}
					static get pluginName() {
						return "ListPropertiesEditing";
					}
					constructor(t) {
						super(t),
							t.config.define("list", {
								properties: { styles: !0, startIndex: !1, reversed: !1 },
							});
					}
					init() {
						const t = this.editor,
							e = t.model,
							n = (function (t) {
								const e = [];
								t.styles &&
									e.push({
										attributeName: "listStyle",
										defaultValue: Pk,
										addCommand(t) {
											t.commands.add("listStyle", new Sk(t, Pk));
										},
										appliesToListItem: () => !0,
										setAttributeOnDowncast(t, e, n) {
											e && e !== Pk
												? t.setStyle("list-style-type", e, n)
												: t.removeStyle("list-style-type", n);
										},
										getAttributeOnUpcast: (t) =>
											t.getStyle("list-style-type") || Pk,
									});
								t.reversed &&
									e.push({
										attributeName: "listReversed",
										defaultValue: !1,
										addCommand(t) {
											t.commands.add("listReversed", new Bk(t));
										},
										appliesToListItem: (t) =>
											"numbered" == t.getAttribute("listType"),
										setAttributeOnDowncast(t, e, n) {
											e
												? t.setAttribute("reversed", "reversed", n)
												: t.removeAttribute("reversed", n);
										},
										getAttributeOnUpcast: (t) => t.hasAttribute("reversed"),
									});
								t.startIndex &&
									e.push({
										attributeName: "listStart",
										defaultValue: 1,
										addCommand(t) {
											t.commands.add("listStart", new Tk(t));
										},
										appliesToListItem: (t) =>
											"numbered" == t.getAttribute("listType"),
										setAttributeOnDowncast(t, e, n) {
											1 != e
												? t.setAttribute("start", e, n)
												: t.removeAttribute("start", n);
										},
										getAttributeOnUpcast: (t) => t.getAttribute("start") || 1,
									});
								return e;
							})(t.config.get("list.properties"));
						e.schema.extend("listItem", {
							allowAttributes: n.map((t) => t.attributeName),
						});
						for (const e of n) e.addCommand(t);
						var o;
						this.listenTo(
							t.commands.get("indentList"),
							"_executeCleanup",
							(function (t, e) {
								return (n, o) => {
									const i = o[0],
										r = i.getAttribute("listIndent"),
										s = o.filter((t) => t.getAttribute("listIndent") === r);
									let a = null;
									i.previousSibling.getAttribute("listIndent") + 1 !== r &&
										(a = nk(i.previousSibling, {
											sameIndent: !0,
											direction: "backward",
											listIndent: r,
										})),
										t.model.change((t) => {
											for (const n of s)
												for (const o of e)
													if (o.appliesToListItem(n)) {
														const e =
															null == a
																? o.defaultValue
																: a.getAttribute(o.attributeName);
														t.setAttribute(o.attributeName, e, n);
													}
										});
								};
							})(t, n),
						),
							this.listenTo(
								t.commands.get("outdentList"),
								"_executeCleanup",
								(function (t, e) {
									return (n, o) => {
										if (
											!(o = o
												.reverse()
												.filter((t) => t.is("element", "listItem"))).length
										)
											return;
										const i = o[0].getAttribute("listIndent"),
											r = o[0].getAttribute("listType");
										let s = o[0].previousSibling;
										if (s.is("element", "listItem"))
											for (; s.getAttribute("listIndent") !== i; )
												s = s.previousSibling;
										else s = null;
										s || (s = o[o.length - 1].nextSibling),
											s &&
												s.is("element", "listItem") &&
												s.getAttribute("listType") === r &&
												t.model.change((t) => {
													const n = o.filter(
														(t) => t.getAttribute("listIndent") === i,
													);
													for (const o of n)
														for (const n of e)
															if (n.appliesToListItem(o)) {
																const e = n.attributeName,
																	i = s.getAttribute(e);
																t.setAttribute(e, i, o);
															}
												});
									};
								})(t, n),
							),
							this.listenTo(
								t.commands.get("bulletedList"),
								"_executeCleanup",
								Rk(t),
							),
							this.listenTo(
								t.commands.get("numberedList"),
								"_executeCleanup",
								Rk(t),
							),
							e.document.registerPostFixer(
								(function (t, e) {
									return (n) => {
										let o = !1;
										const i = Ok(t.model.document.differ.getChanges()).filter(
											(t) => "todo" !== t.getAttribute("listType"),
										);
										if (!i.length) return o;
										let r = i[i.length - 1].nextSibling;
										if (
											(!r || !r.is("element", "listItem")) &&
											((r = i[0].previousSibling), r)
										) {
											const t = i[0].getAttribute("listIndent");
											for (
												;
												r.is("element", "listItem") &&
												r.getAttribute("listIndent") !== t &&
												((r = r.previousSibling), r);
											);
										}
										for (const t of e) {
											const e = t.attributeName;
											for (const s of i)
												if (t.appliesToListItem(s))
													if (s.hasAttribute(e)) {
														const i = s.previousSibling;
														zk(i, s, t.attributeName) &&
															(n.setAttribute(e, i.getAttribute(e), s),
															(o = !0));
													} else
														Ik(r, s, t)
															? n.setAttribute(e, r.getAttribute(e), s)
															: n.setAttribute(e, t.defaultValue, s),
															(o = !0);
												else n.removeAttribute(e, s);
										}
										return o;
									};
								})(t, n),
							),
							t.conversion.for("upcast").add(
								((o = n),
								(t) => {
									t.on(
										"element:li",
										(t, e, n) => {
											const i = e.viewItem.parent,
												r =
													e.modelRange.start.nodeAfter ||
													e.modelRange.end.nodeBefore;
											for (const t of o)
												if (t.appliesToListItem(r)) {
													const e = t.getAttributeOnUpcast(i);
													n.writer.setAttribute(t.attributeName, e, r);
												}
										},
										{ priority: "low" },
									);
								}),
							),
							t.conversion.for("downcast").add(
								(function (t) {
									return (n) => {
										for (const o of t)
											n.on(
												`attribute:${o.attributeName}:listItem`,
												(t, n, i) => {
													const r = i.writer,
														s = n.item,
														a = nk(s.previousSibling, {
															sameIndent: !0,
															listIndent: s.getAttribute("listIndent"),
															direction: "backward",
														}),
														c = i.mapper.toViewElement(s);
													e(s, a) ||
														r.breakContainer(r.createPositionBefore(c)),
														o.setAttributeOnDowncast(
															r,
															n.attributeNewValue,
															c.parent,
														);
												},
												{ priority: "low" },
											);
									};
									function e(t, e) {
										return (
											e &&
											t.getAttribute("listType") ===
												e.getAttribute("listType") &&
											t.getAttribute("listIndent") ===
												e.getAttribute("listIndent") &&
											t.getAttribute("listStyle") ===
												e.getAttribute("listStyle") &&
											t.getAttribute("listReversed") ===
												e.getAttribute("listReversed") &&
											t.getAttribute("listStart") ===
												e.getAttribute("listStart")
										);
									}
								})(n),
							),
							this._mergeListAttributesWhileMergingLists(n);
					}
					afterInit() {
						const t = this.editor;
						t.commands.get("todoList") &&
							t.model.document.registerPostFixer(
								(function (t) {
									return (e) => {
										const n = Ok(t.model.document.differ.getChanges()).filter(
											(t) =>
												"todo" === t.getAttribute("listType") &&
												(t.hasAttribute("listStyle") ||
													t.hasAttribute("listReversed") ||
													t.hasAttribute("listStart")),
										);
										if (!n.length) return !1;
										for (const t of n)
											e.removeAttribute("listStyle", t),
												e.removeAttribute("listReversed", t),
												e.removeAttribute("listStart", t);
										return !0;
									};
								})(t),
							);
					}
					_mergeListAttributesWhileMergingLists(t) {
						const e = this.editor.model;
						let n;
						this.listenTo(
							e,
							"deleteContent",
							(t, [e]) => {
								const o = e.getFirstPosition(),
									i = e.getLastPosition();
								if (o.parent === i.parent) return;
								if (!o.parent.is("element", "listItem")) return;
								const r = i.parent.nextSibling;
								if (!r || !r.is("element", "listItem")) return;
								const s = nk(o.parent, {
									sameIndent: !0,
									listIndent: r.getAttribute("listIndent"),
								});
								s &&
									s.getAttribute("listType") === r.getAttribute("listType") &&
									(n = s);
							},
							{ priority: "high" },
						),
							this.listenTo(
								e,
								"deleteContent",
								() => {
									n &&
										(e.change((e) => {
											const o = nk(n.nextSibling, {
												sameIndent: !0,
												listIndent: n.getAttribute("listIndent"),
												direction: "forward",
											});
											if (!o) return void (n = null);
											const i = [o, ...rk(e.createPositionAt(o, 0), "forward")];
											for (const o of i)
												for (const i of t)
													if (i.appliesToListItem(o)) {
														const t = i.attributeName,
															r = n.getAttribute(t);
														e.setAttribute(t, r, o);
													}
										}),
										(n = null));
								},
								{ priority: "low" },
							);
					}
				}
				function Ik(t, e, n) {
					if (!t) return !1;
					const o = t.getAttribute(n.attributeName);
					return (
						!!o &&
						o != n.defaultValue &&
						t.getAttribute("listType") === e.getAttribute("listType")
					);
				}
				function zk(t, e, n) {
					if (!t || !t.is("element", "listItem")) return !1;
					if (e.getAttribute("listType") !== t.getAttribute("listType"))
						return !1;
					const o = t.getAttribute("listIndent");
					if (o < 1 || o !== e.getAttribute("listIndent")) return !1;
					const i = t.getAttribute(n);
					return !(!i || i === e.getAttribute(n));
				}
				function Rk(t) {
					return (e, n) => {
						(n = n.filter((t) => t.is("element", "listItem"))),
							t.model.change((t) => {
								for (const e of n) t.removeAttribute("listStyle", e);
							});
					};
				}
				function Ok(t) {
					const e = [];
					for (const n of t) {
						const t = Mk(n);
						t && t.is("element", "listItem") && e.push(t);
					}
					return e;
				}
				function Mk(t) {
					return "attribute" === t.type
						? t.range.start.nodeAfter
						: "insert" === t.type
							? t.position.nodeAfter
							: null;
				}
				var Nk = n(55),
					Vk = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Nk.a, Vk), Nk.a.locals;
				class Lk extends fu {
					constructor(t, e) {
						super(t);
						const n = this.bindTemplate;
						this.set("isCollapsed", !1),
							this.set("label", ""),
							(this.buttonView = this._createButtonView()),
							(this.children = this.createCollection()),
							this.set("_collapsibleAriaLabelUid"),
							e && this.children.addMany(e),
							this.setTemplate({
								tag: "div",
								attributes: {
									class: [
										"ck",
										"ck-collapsible",
										n.if("isCollapsed", "ck-collapsible_collapsed"),
									],
								},
								children: [
									this.buttonView,
									{
										tag: "div",
										attributes: {
											class: ["ck", "ck-collapsible__children"],
											role: "region",
											hidden: n.if("isCollapsed", "hidden"),
											"aria-labelledby": n.to("_collapsibleAriaLabelUid"),
										},
										children: this.children,
									},
								],
							});
					}
					render() {
						super.render(),
							(this._collapsibleAriaLabelUid =
								this.buttonView.labelView.element.id);
					}
					_createButtonView() {
						const t = new Ju(this.locale),
							e = t.bindTemplate;
						return (
							t.set({ withText: !0, icon: eh }),
							t.extendTemplate({
								attributes: { "aria-expanded": e.to("isOn", (t) => String(t)) },
							}),
							t.bind("label").to(this),
							t.bind("isOn").to(this, "isCollapsed", (t) => !t),
							t.on("execute", () => {
								this.isCollapsed = !this.isCollapsed;
							}),
							t
						);
					}
				}
				var jk = n(56),
					Hk = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(jk.a, Hk), jk.a.locals;
				class $k extends fu {
					constructor(
						t,
						{
							enabledProperties: e,
							styleButtonViews: n,
							styleGridAriaLabel: o,
						},
					) {
						super(t);
						const i = ["ck", "ck-list-properties"];
						(this.children = this.createCollection()),
							(this.stylesView = null),
							(this.additionalPropertiesCollapsibleView = null),
							(this.startIndexFieldView = null),
							(this.reversedSwitchButtonView = null),
							(this.focusTracker = new xa()),
							(this.keystrokes = new Da()),
							(this.focusables = new Ud()),
							(this.focusCycler = new dh({
								focusables: this.focusables,
								focusTracker: this.focusTracker,
								keystrokeHandler: this.keystrokes,
								actions: { focusPrevious: "shift + tab", focusNext: "tab" },
							})),
							e.styles
								? ((this.stylesView = this._createStylesView(n, o)),
									this.children.add(this.stylesView))
								: i.push("ck-list-properties_without-styles"),
							(e.startIndex || e.reversed) &&
								(this._addNumberedListPropertyViews(e, n),
								i.push("ck-list-properties_with-numbered-properties")),
							this.setTemplate({
								tag: "div",
								attributes: { class: i },
								children: this.children,
							});
					}
					render() {
						if ((super.render(), this.stylesView)) {
							this.focusables.add(this.stylesView),
								this.focusTracker.add(this.stylesView.element),
								(this.startIndexFieldView || this.reversedSwitchButtonView) &&
									(this.focusables.add(this.children.last.buttonView),
									this.focusTracker.add(this.children.last.buttonView.element));
							for (const t of this.stylesView.children)
								this.stylesView.focusTracker.add(t.element);
							Hu({
								keystrokeHandler: this.stylesView.keystrokes,
								focusTracker: this.stylesView.focusTracker,
								gridItems: this.stylesView.children,
								numberOfColumns: () =>
									no.window
										.getComputedStyle(this.stylesView.element)
										.getPropertyValue("grid-template-columns")
										.split(" ").length,
							});
						}
						if (this.startIndexFieldView) {
							this.focusables.add(this.startIndexFieldView),
								this.focusTracker.add(this.startIndexFieldView.element),
								this.listenTo(
									this.startIndexFieldView.element,
									"selectstart",
									(t, e) => {
										e.stopPropagation();
									},
									{ priority: "high" },
								);
							const t = (t) => t.stopPropagation();
							this.keystrokes.set("arrowright", t),
								this.keystrokes.set("arrowleft", t),
								this.keystrokes.set("arrowup", t),
								this.keystrokes.set("arrowdown", t);
						}
						this.reversedSwitchButtonView &&
							(this.focusables.add(this.reversedSwitchButtonView),
							this.focusTracker.add(this.reversedSwitchButtonView.element)),
							this.keystrokes.listenTo(this.element);
					}
					focus() {
						this.focusCycler.focusFirst();
					}
					focusLast() {
						this.focusCycler.focusLast();
					}
					destroy() {
						super.destroy(),
							this.focusTracker.destroy(),
							this.keystrokes.destroy();
					}
					_createStylesView(t, e) {
						const n = new fu(this.locale);
						return (
							(n.children = n.createCollection(this.locale)),
							n.children.addMany(t),
							n.setTemplate({
								tag: "div",
								attributes: {
									"aria-label": e,
									class: ["ck", "ck-list-styles-list"],
								},
								children: n.children,
							}),
							n.children.delegate("execute").to(this),
							(n.focus = function () {
								this.children.first.focus();
							}),
							(n.focusTracker = new xa()),
							(n.keystrokes = new Da()),
							n.render(),
							n.keystrokes.listenTo(n.element),
							n
						);
					}
					_addNumberedListPropertyViews(t) {
						const e = this.locale.t,
							n = [];
						t.startIndex &&
							((this.startIndexFieldView = this._createStartIndexField()),
							n.push(this.startIndexFieldView)),
							t.reversed &&
								((this.reversedSwitchButtonView =
									this._createReversedSwitchButton()),
								n.push(this.reversedSwitchButtonView)),
							t.styles
								? ((this.additionalPropertiesCollapsibleView = new Lk(
										this.locale,
										n,
									)),
									this.additionalPropertiesCollapsibleView.set({
										label: e("List properties"),
										isCollapsed: !0,
									}),
									this.additionalPropertiesCollapsibleView.buttonView
										.bind("isEnabled")
										.toMany(n, "isEnabled", (...t) => t.some((t) => t)),
									this.additionalPropertiesCollapsibleView.buttonView.on(
										"change:isEnabled",
										(t, e, n) => {
											n ||
												(this.additionalPropertiesCollapsibleView.isCollapsed =
													!0);
										},
									),
									this.children.add(this.additionalPropertiesCollapsibleView))
								: this.children.addMany(n);
					}
					_createStartIndexField() {
						const t = this.locale.t,
							e = new Zh(this.locale, ep);
						return (
							e.set({
								label: t("Start at"),
								class: "ck-numbered-list-properties__start-index",
							}),
							e.fieldView.set({
								min: 1,
								step: 1,
								value: 1,
								inputMode: "numeric",
							}),
							e.fieldView.on("input", () => {
								const n = e.fieldView.element,
									o = n.valueAsNumber;
								Number.isNaN(o) ||
									(n.checkValidity()
										? this.fire("listStart", { startIndex: o })
										: (e.errorText = t("Start index must be greater than 0.")));
							}),
							e
						);
					}
					_createReversedSwitchButton() {
						const t = this.locale.t,
							e = new Xu(this.locale);
						return (
							e.set({
								withText: !0,
								label: t("Reversed order"),
								class: "ck-numbered-list-properties__reversed-order",
							}),
							e.delegate("execute").to(this, "listReversed"),
							e
						);
					}
				}
				var qk = n(57),
					Uk = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(qk.a, Uk), qk.a.locals;
				class Wk extends R {
					static get pluginName() {
						return "ListPropertiesUI";
					}
					init() {
						const t = this.editor,
							e = t.locale.t,
							n = t.config.get("list.properties");
						n.styles &&
							t.ui.componentFactory.add(
								"bulletedList",
								Kk({
									editor: t,
									parentCommandName: "bulletedList",
									buttonLabel: e("Bulleted List"),
									buttonIcon: Dk,
									styleGridAriaLabel: e("Bulleted list styles toolbar"),
									styleDefinitions: [
										{
											label: e("Toggle the disc list style"),
											tooltip: e("Disc"),
											type: "disc",
											icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6z"/></svg>',
										},
										{
											label: e("Toggle the circle list style"),
											tooltip: e("Circle"),
											type: "circle",
											icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4z"/></svg>',
										},
										{
											label: e("Toggle the square list style"),
											tooltip: e("Square"),
											type: "square",
											icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M14 27v6H8v-6h6zm0-9v6H8v-6h6zm0-9v6H8V9h6z"/></svg>',
										},
									],
								}),
							),
							(n.styles || n.startIndex || n.reversed) &&
								t.ui.componentFactory.add(
									"numberedList",
									Kk({
										editor: t,
										parentCommandName: "numberedList",
										buttonLabel: e("Numbered List"),
										buttonIcon: xk,
										styleGridAriaLabel: e("Numbered list styles toolbar"),
										styleDefinitions: [
											{
												label: e("Toggle the decimal list style"),
												tooltip: e("Decimal"),
												type: "decimal",
												icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M10.29 15V8.531H9.286c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.343 0v-1.235h-1.235V15h1.235zM11.3 24v-1.147H8.848c.064-.111.148-.226.252-.343.104-.117.351-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.494-.824.104-.263.156-.539.156-.829 0-.51-.182-.936-.545-1.279-.363-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.153-.155.358-.233.616-.233.26 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.468.536-1.024 1.055-.692.641-1.155 1.156-1.389 1.544-.234.389-.375.8-.422 1.233H11.3zm2.333 0v-1.235h-1.235V24h1.235zM9.204 34.11c.615 0 1.129-.2 1.542-.598.413-.398.62-.88.62-1.446 0-.39-.11-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.619-.337.928-.788.928-1.353 0-.399-.151-.756-.453-1.073-.366-.386-.852-.58-1.459-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.668.55c-.16.232-.28.544-.358.933l1.138.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.215 0 .386.065.515.194s.193.302.193.518c0 .255-.087.46-.263.613-.176.154-.43.227-.765.218l-.136 1.006c.22-.061.409-.092.567-.092.24 0 .444.09.61.272.168.182.251.428.251.739 0 .328-.087.589-.261.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.307-.698l-1.196.145c.062.542.285.98.668 1.316.384.335.868.503 1.45.503zm4.43-.11v-1.235h-1.236V34h1.235z"/></svg>',
											},
											{
												label: e(
													"Toggle the decimal with leading zero list style",
												),
												tooltip: e("Decimal with leading zero"),
												type: "decimal-leading-zero",
												icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M5.714 15.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm6.078.914V8.531H10.79c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.344 0v-1.235h-1.235V15h1.235zm-9.422 9.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm7.088.914v-1.147H10.35c.065-.111.149-.226.253-.343.104-.117.35-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.493-.824.104-.263.156-.539.156-.829 0-.51-.181-.936-.544-1.279-.364-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.152-.155.357-.233.615-.233.261 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.467.536-1.024 1.055-.691.641-1.154 1.156-1.388 1.544-.235.389-.375.8-.422 1.233h4.328zm2.334 0v-1.235h-1.235V24h1.235zM5.714 34.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm4.992 1.024c.616 0 1.13-.2 1.543-.598.413-.398.62-.88.62-1.446 0-.39-.111-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.618-.337.927-.788.927-1.353 0-.399-.15-.756-.452-1.073-.366-.386-.853-.58-1.46-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.667.55c-.16.232-.28.544-.359.933l1.139.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.214 0 .386.065.515.194s.193.302.193.518c0 .255-.088.46-.264.613-.175.154-.43.227-.764.218l-.136 1.006c.22-.061.408-.092.566-.092.24 0 .444.09.611.272.167.182.25.428.25.739 0 .328-.086.589-.26.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.308-.698l-1.195.145c.062.542.284.98.668 1.316.384.335.867.503 1.45.503zm4.43-.11v-1.235h-1.235V34h1.235z"/></svg>',
											},
											{
												label: e("Toggle the lower–roman list style"),
												tooltip: e("Lower–roman"),
												type: "lower-roman",
												icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.88 8.7V7.558h-1.234V8.7h1.234zm0 5.3V9.333h-1.234V14h1.234zm2.5 0v-1.235h-1.234V14h1.235zm-4.75 4.7v-1.142H8.395V18.7H9.63zm0 5.3v-4.667H8.395V24H9.63zm2.5-5.3v-1.142h-1.234V18.7h1.235zm0 5.3v-4.667h-1.234V24h1.235zm2.501 0v-1.235h-1.235V24h1.235zM7.38 28.7v-1.142H6.145V28.7H7.38zm0 5.3v-4.667H6.145V34H7.38zm2.5-5.3v-1.142H8.646V28.7H9.88zm0 5.3v-4.667H8.646V34H9.88zm2.5-5.3v-1.142h-1.234V28.7h1.235zm0 5.3v-4.667h-1.234V34h1.235zm2.501 0v-1.235h-1.235V34h1.235z"/></svg>',
											},
											{
												label: e("Toggle the upper–roman list style"),
												tooltip: e("Upper-roman"),
												type: "upper-roman",
												icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.916 15V8.558h-1.301V15h1.3zm2.465 0v-1.235h-1.235V15h1.235zM9.665 25v-6.442h-1.3V25h1.3zm2.5 0v-6.442h-1.3V25h1.3zm2.466 0v-1.235h-1.235V25h1.235zm-7.216 9v-6.442h-1.3V34h1.3zm2.5 0v-6.442h-1.3V34h1.3zm2.501 0v-6.442h-1.3V34h1.3zm2.465 0v-1.235h-1.235V34h1.235z"/></svg>',
											},
											{
												label: e("Toggle the lower–latin list style"),
												tooltip: e("Lower-latin"),
												type: "lower-latin",
												icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M9.62 14.105c.272 0 .528-.05.768-.153s.466-.257.677-.462c.009.024.023.072.044.145.047.161.086.283.119.365h1.221a2.649 2.649 0 0 1-.222-.626c-.04-.195-.059-.498-.059-.908l.013-1.441c0-.536-.055-.905-.165-1.105-.11-.201-.3-.367-.569-.497-.27-.13-.68-.195-1.23-.195-.607 0-1.064.108-1.371.325-.308.217-.525.55-.65 1.002l1.12.202c.076-.217.176-.369.299-.455.123-.086.294-.13.514-.13.325 0 .546.05.663.152.118.101.176.27.176.508v.123c-.222.093-.622.194-1.2.303-.427.082-.755.178-.982.288-.227.11-.403.268-.53.474a1.327 1.327 0 0 0-.188.706c0 .398.138.728.415.988.277.261.656.391 1.136.391zm.368-.87a.675.675 0 0 1-.492-.189.606.606 0 0 1-.193-.448c0-.176.08-.32.241-.435.106-.07.33-.142.673-.215a7.19 7.19 0 0 0 .751-.19v.247c0 .296-.016.496-.048.602a.773.773 0 0 1-.295.409 1.07 1.07 0 0 1-.637.22zm4.645.765v-1.235h-1.235V14h1.235zM10.2 25.105c.542 0 1.003-.215 1.382-.646.38-.43.57-1.044.57-1.84 0-.771-.187-1.362-.559-1.774a1.82 1.82 0 0 0-1.41-.617c-.522 0-.973.216-1.354.65v-2.32H7.594V25h1.147v-.686a1.9 1.9 0 0 0 .67.592c.26.133.523.2.79.2zm-.299-.975c-.354 0-.638-.164-.852-.492-.153-.232-.229-.59-.229-1.073 0-.468.098-.818.295-1.048a.93.93 0 0 1 .738-.345c.302 0 .55.118.743.354.193.236.29.62.29 1.154 0 .5-.096.868-.288 1.1-.192.233-.424.35-.697.35zm4.478.87v-1.235h-1.234V25h1.234zm-4.017 9.105c.6 0 1.08-.142 1.437-.426.357-.284.599-.704.725-1.261l-1.213-.207c-.061.326-.167.555-.316.688a.832.832 0 0 1-.576.2.916.916 0 0 1-.75-.343c-.185-.228-.278-.62-.278-1.173 0-.498.091-.853.274-1.066.183-.212.429-.318.736-.318.232 0 .42.061.565.184.145.123.238.306.28.55l1.216-.22c-.146-.501-.387-.874-.722-1.119-.336-.244-.788-.366-1.356-.366-.695 0-1.245.214-1.653.643-.407.43-.61 1.03-.61 1.8 0 .762.202 1.358.608 1.788.406.431.95.646 1.633.646zM14.633 34v-1.235h-1.235V34h1.235z"/></svg>',
											},
											{
												label: e("Toggle the upper–latin list style"),
												tooltip: e("Upper-latin"),
												type: "upper-latin",
												icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="m7.88 15 .532-1.463h2.575L11.549 15h1.415l-2.58-6.442H9.01L6.5 15h1.38zm2.69-2.549H8.811l.87-2.39.887 2.39zM14.88 15v-1.235h-1.234V15h1.234zM9.352 25c.83-.006 1.352-.02 1.569-.044.346-.038.636-.14.872-.305.236-.166.422-.387.558-.664.137-.277.205-.562.205-.855 0-.372-.106-.695-.317-.97-.21-.276-.512-.471-.905-.585a1.51 1.51 0 0 0 .661-.567 1.5 1.5 0 0 0 .244-.83c0-.28-.066-.53-.197-.754a1.654 1.654 0 0 0-.495-.539 1.676 1.676 0 0 0-.672-.266c-.25-.042-.63-.063-1.14-.063H7.158V25h2.193zm.142-3.88H8.46v-1.49h.747c.612 0 .983.007 1.112.022.217.026.38.102.49.226.11.125.165.287.165.486a.68.68 0 0 1-.192.503.86.86 0 0 1-.525.23 11.47 11.47 0 0 1-.944.023h.18zm.17 2.795H8.46v-1.723h1.05c.592 0 .977.03 1.154.092.177.062.313.16.406.295a.84.84 0 0 1 .14.492c0 .228-.06.41-.181.547a.806.806 0 0 1-.473.257c-.126.026-.423.04-.892.04zM14.88 25v-1.235h-1.234V25h1.234zm-5.018 9.11c.691 0 1.262-.17 1.711-.512.45-.341.772-.864.965-1.567l-1.261-.4c-.109.472-.287.818-.536 1.037-.25.22-.547.33-.892.33-.47 0-.85-.173-1.143-.519-.293-.345-.44-.925-.44-1.74 0-.767.15-1.322.447-1.665.297-.343.684-.514 1.162-.514.346 0 .64.096.881.29.242.193.4.457.477.79l1.288-.307c-.147-.516-.367-.911-.66-1.187-.492-.465-1.132-.698-1.92-.698-.902 0-1.63.296-2.184.89-.554.593-.83 1.426-.83 2.498 0 1.014.275 1.813.825 2.397.551.585 1.254.877 2.11.877zM14.88 34v-1.235h-1.234V34h1.234z"/></svg>',
											},
										],
									}),
								);
					}
				}
				function Kk({
					editor: t,
					parentCommandName: e,
					buttonLabel: n,
					buttonIcon: o,
					styleGridAriaLabel: i,
					styleDefinitions: r,
				}) {
					const s = t.commands.get(e);
					return (a) => {
						const c = Fh(a, rh),
							l = c.buttonView;
						c.bind("isEnabled").to(s),
							(c.class = "ck-list-styles-dropdown"),
							l.on("execute", () => {
								t.execute(e), t.editing.view.focus();
							}),
							l.set({ label: n, icon: o, tooltip: !0, isToggleable: !0 }),
							l.bind("isOn").to(s, "value", (t) => !!t);
						const d = (function ({
							editor: t,
							dropdownView: e,
							parentCommandName: n,
							styleDefinitions: o,
							styleGridAriaLabel: i,
						}) {
							const r = t.locale,
								s = t.config.get("list.properties");
							let a;
							"numberedList" != n && ((s.startIndex = !1), (s.reversed = !1));
							if (s.styles) {
								const e = t.commands.get("listStyle"),
									i = (function ({
										editor: t,
										listStyleCommand: e,
										parentCommandName: n,
									}) {
										const o = t.locale,
											i = t.commands.get(n);
										return ({ label: n, type: r, icon: s, tooltip: a }) => {
											const c = new Ju(o);
											return (
												c.set({ label: n, icon: s, tooltip: a }),
												e.on("change:value", () => {
													c.isOn = e.value === r;
												}),
												c.on("execute", () => {
													i.value
														? e.value !== r
															? t.execute("listStyle", { type: r })
															: t.execute("listStyle", { type: e._defaultType })
														: t.model.change(() => {
																t.execute("listStyle", { type: r });
															});
												}),
												c
											);
										};
									})({ editor: t, parentCommandName: n, listStyleCommand: e }),
									r =
										"function" == typeof e.isStyleTypeSupported
											? (t) => e.isStyleTypeSupported(t.type)
											: () => !0;
								a = o.filter(r).map(i);
							}
							const c = new $k(r, {
								styleGridAriaLabel: i,
								enabledProperties: s,
								styleButtonViews: a,
							});
							s.styles &&
								Rh(e, () => c.stylesView.children.find((t) => t.isOn));
							if (s.startIndex) {
								const e = t.commands.get("listStart");
								c.startIndexFieldView.bind("isEnabled").to(e),
									c.startIndexFieldView.fieldView.bind("value").to(e),
									c.on("listStart", (e, n) => t.execute("listStart", n));
							}
							if (s.reversed) {
								const e = t.commands.get("listReversed");
								c.reversedSwitchButtonView.bind("isEnabled").to(e),
									c.reversedSwitchButtonView.bind("isOn").to(e, "value"),
									c.on("listReversed", () => {
										const n = e.value;
										t.execute("listReversed", { reversed: !n });
									});
							}
							return c.delegate("execute").to(e), c;
						})({
							editor: t,
							dropdownView: c,
							parentCommandName: e,
							styleGridAriaLabel: i,
							styleDefinitions: r,
						});
						return (
							c.panelView.children.add(d),
							c.on("execute", () => {
								t.editing.view.focus();
							}),
							c
						);
					};
				}
				class Gk extends R {
					static get requires() {
						return [Fk, Wk];
					}
					static get pluginName() {
						return "ListProperties";
					}
				}
				var Jk = n(12);
				function Yk(t, e) {
					return Array(e + 1).join(t);
				}
				Jk.marked.use({
					tokenizer: { autolink: () => null, url: () => null },
					renderer: {
						checkbox(...t) {
							return Object.getPrototypeOf(this)
								.checkbox.call(this, ...t)
								.trimRight();
						},
						code(...t) {
							return Object.getPrototypeOf(this)
								.code.call(this, ...t)
								.replace("\n</code>", "</code>");
						},
					},
				});
				var Qk = [
					"address",
					"article",
					"aside",
					"audio",
					"blockquote",
					"body",
					"canvas",
					"center",
					"dd",
					"dir",
					"div",
					"dl",
					"dt",
					"fieldset",
					"figcaption",
					"figure",
					"footer",
					"form",
					"frameset",
					"h1",
					"h2",
					"h3",
					"h4",
					"h5",
					"h6",
					"header",
					"hgroup",
					"hr",
					"html",
					"isindex",
					"li",
					"main",
					"menu",
					"nav",
					"noframes",
					"noscript",
					"ol",
					"output",
					"p",
					"pre",
					"section",
					"table",
					"tbody",
					"td",
					"tfoot",
					"th",
					"thead",
					"tr",
					"ul",
				];
				function Xk(t) {
					return -1 !== Qk.indexOf(t.nodeName.toLowerCase());
				}
				var Zk = [
					"area",
					"base",
					"br",
					"col",
					"command",
					"embed",
					"hr",
					"img",
					"input",
					"keygen",
					"link",
					"meta",
					"param",
					"source",
					"track",
					"wbr",
				];
				function tb(t) {
					return -1 !== Zk.indexOf(t.nodeName.toLowerCase());
				}
				var eb = Zk.join();
				var nb = {};
				function ob(t) {
					for (var e in ((this.options = t),
					(this._keep = []),
					(this._remove = []),
					(this.blankRule = { replacement: t.blankReplacement }),
					(this.keepReplacement = t.keepReplacement),
					(this.defaultRule = { replacement: t.defaultReplacement }),
					(this.array = []),
					t.rules))
						this.array.push(t.rules[e]);
				}
				function ib(t, e, n) {
					for (var o = 0; o < t.length; o++) {
						var i = t[o];
						if (rb(i, e, n)) return i;
					}
				}
				function rb(t, e, n) {
					var o = t.filter;
					if ("string" == typeof o) {
						if (o === e.nodeName.toLowerCase()) return !0;
					} else if (Array.isArray(o)) {
						if (o.indexOf(e.nodeName.toLowerCase()) > -1) return !0;
					} else {
						if ("function" != typeof o)
							throw new TypeError(
								"`filter` needs to be a string, array, or function",
							);
						if (o.call(t, e, n)) return !0;
					}
				}
				function sb(t) {
					var e = t.nextSibling || t.parentNode;
					return t.parentNode.removeChild(t), e;
				}
				function ab(t, e, n) {
					return (t && t.parentNode === e) || n(e)
						? e.nextSibling || e.parentNode
						: e.firstChild || e.nextSibling || e.parentNode;
				}
				(nb.paragraph = {
					filter: "p",
					replacement: function (t) {
						return "\n\n" + t + "\n\n";
					},
				}),
					(nb.lineBreak = {
						filter: "br",
						replacement: function (t, e, n) {
							return n.br + "\n";
						},
					}),
					(nb.heading = {
						filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
						replacement: function (t, e, n) {
							var o = Number(e.nodeName.charAt(1));
							return "setext" === n.headingStyle && o < 3
								? "\n\n" + t + "\n" + Yk(1 === o ? "=" : "-", t.length) + "\n\n"
								: "\n\n" + Yk("#", o) + " " + t + "\n\n";
						},
					}),
					(nb.blockquote = {
						filter: "blockquote",
						replacement: function (t) {
							return (
								"\n\n" +
								(t = (t = t.replace(/^\n+|\n+$/g, "")).replace(/^/gm, "> ")) +
								"\n\n"
							);
						},
					}),
					(nb.list = {
						filter: ["ul", "ol"],
						replacement: function (t, e) {
							var n = e.parentNode;
							return "LI" === n.nodeName && n.lastElementChild === e
								? "\n" + t
								: "\n\n" + t + "\n\n";
						},
					}),
					(nb.listItem = {
						filter: "li",
						replacement: function (t, e, n) {
							t = t
								.replace(/^\n+/, "")
								.replace(/\n+$/, "\n")
								.replace(/\n/gm, "\n    ");
							var o = n.bulletListMarker + "   ",
								i = e.parentNode;
							if ("OL" === i.nodeName) {
								var r = i.getAttribute("start"),
									s = Array.prototype.indexOf.call(i.children, e);
								o = (r ? Number(r) + s : s + 1) + ".  ";
							}
							return o + t + (e.nextSibling && !/\n$/.test(t) ? "\n" : "");
						},
					}),
					(nb.indentedCodeBlock = {
						filter: function (t, e) {
							return (
								"indented" === e.codeBlockStyle &&
								"PRE" === t.nodeName &&
								t.firstChild &&
								"CODE" === t.firstChild.nodeName
							);
						},
						replacement: function (t, e, n) {
							return (
								"\n\n    " +
								e.firstChild.textContent.replace(/\n/g, "\n    ") +
								"\n\n"
							);
						},
					}),
					(nb.fencedCodeBlock = {
						filter: function (t, e) {
							return (
								"fenced" === e.codeBlockStyle &&
								"PRE" === t.nodeName &&
								t.firstChild &&
								"CODE" === t.firstChild.nodeName
							);
						},
						replacement: function (t, e, n) {
							for (
								var o,
									i = ((e.firstChild.className || "").match(
										/language-(\S+)/,
									) || [null, ""])[1],
									r = e.firstChild.textContent,
									s = n.fence.charAt(0),
									a = 3,
									c = new RegExp("^" + s + "{3,}", "gm");
								(o = c.exec(r));
							)
								o[0].length >= a && (a = o[0].length + 1);
							var l = Yk(s, a);
							return (
								"\n\n" + l + i + "\n" + r.replace(/\n$/, "") + "\n" + l + "\n\n"
							);
						},
					}),
					(nb.horizontalRule = {
						filter: "hr",
						replacement: function (t, e, n) {
							return "\n\n" + n.hr + "\n\n";
						},
					}),
					(nb.inlineLink = {
						filter: function (t, e) {
							return (
								"inlined" === e.linkStyle &&
								"A" === t.nodeName &&
								t.getAttribute("href")
							);
						},
						replacement: function (t, e) {
							return (
								"[" +
								t +
								"](" +
								e.getAttribute("href") +
								(e.title ? ' "' + e.title + '"' : "") +
								")"
							);
						},
					}),
					(nb.referenceLink = {
						filter: function (t, e) {
							return (
								"referenced" === e.linkStyle &&
								"A" === t.nodeName &&
								t.getAttribute("href")
							);
						},
						replacement: function (t, e, n) {
							var o,
								i,
								r = e.getAttribute("href"),
								s = e.title ? ' "' + e.title + '"' : "";
							switch (n.linkReferenceStyle) {
								case "collapsed":
									(o = "[" + t + "][]"), (i = "[" + t + "]: " + r + s);
									break;
								case "shortcut":
									(o = "[" + t + "]"), (i = "[" + t + "]: " + r + s);
									break;
								default:
									var a = this.references.length + 1;
									(o = "[" + t + "][" + a + "]"), (i = "[" + a + "]: " + r + s);
							}
							return this.references.push(i), o;
						},
						references: [],
						append: function (t) {
							var e = "";
							return (
								this.references.length &&
									((e = "\n\n" + this.references.join("\n") + "\n\n"),
									(this.references = [])),
								e
							);
						},
					}),
					(nb.emphasis = {
						filter: ["em", "i"],
						replacement: function (t, e, n) {
							return t.trim() ? n.emDelimiter + t + n.emDelimiter : "";
						},
					}),
					(nb.strong = {
						filter: ["strong", "b"],
						replacement: function (t, e, n) {
							return t.trim() ? n.strongDelimiter + t + n.strongDelimiter : "";
						},
					}),
					(nb.code = {
						filter: function (t) {
							var e = t.previousSibling || t.nextSibling,
								n = "PRE" === t.parentNode.nodeName && !e;
							return "CODE" === t.nodeName && !n;
						},
						replacement: function (t) {
							if (!t.trim()) return "";
							var e = "`",
								n = "",
								o = "",
								i = t.match(/`+/gm);
							if (i)
								for (
									/^`/.test(t) && (n = " "), /`$/.test(t) && (o = " ");
									-1 !== i.indexOf(e);
								)
									e += "`";
							return e + n + t + o + e;
						},
					}),
					(nb.image = {
						filter: "img",
						replacement: function (t, e) {
							var n = e.alt || "",
								o = e.getAttribute("src") || "",
								i = e.title || "";
							return o
								? "![" + n + "](" + o + (i ? ' "' + i + '"' : "") + ")"
								: "";
						},
					}),
					(ob.prototype = {
						add: function (t, e) {
							this.array.unshift(e);
						},
						keep: function (t) {
							this._keep.unshift({
								filter: t,
								replacement: this.keepReplacement,
							});
						},
						remove: function (t) {
							this._remove.unshift({
								filter: t,
								replacement: function () {
									return "";
								},
							});
						},
						forNode: function (t) {
							return t.isBlank
								? this.blankRule
								: (e = ib(this.array, t, this.options)) ||
										(e = ib(this._keep, t, this.options)) ||
										(e = ib(this._remove, t, this.options))
									? e
									: this.defaultRule;
							var e;
						},
						forEach: function (t) {
							for (var e = 0; e < this.array.length; e++) t(this.array[e], e);
						},
					});
				var cb = "undefined" != typeof window ? window : {};
				var lb,
					db,
					ub,
					hb = (function () {
						var t = cb.DOMParser,
							e = !1;
						try {
							new t().parseFromString("", "text/html") && (e = !0);
						} catch (t) {}
						return e;
					})()
						? cb.DOMParser
						: ((lb = function () {}),
							(db = n(64).JSDOM),
							(lb.prototype.parseFromString = function (t) {
								return new db(t).window.document;
							}),
							lb);
				function pb(t) {
					var e;
					"string" == typeof t
						? (e = (ub = ub || new hb())
								.parseFromString(
									'<x-turndown id="turndown-root">' + t + "</x-turndown>",
									"text/html",
								)
								.getElementById("turndown-root"))
						: (e = t.cloneNode(!0));
					return (
						(function (t) {
							var e = t.element,
								n = t.isBlock,
								o = t.isVoid,
								i =
									t.isPre ||
									function (t) {
										return "PRE" === t.nodeName;
									};
							if (e.firstChild && !i(e)) {
								for (
									var r = null, s = !1, a = null, c = ab(a, e, i);
									c !== e;
								) {
									if (3 === c.nodeType || 4 === c.nodeType) {
										var l = c.data.replace(/[ \r\n\t]+/g, " ");
										if (
											((r && !/ $/.test(r.data)) ||
												s ||
												" " !== l[0] ||
												(l = l.substr(1)),
											!l)
										) {
											c = sb(c);
											continue;
										}
										(c.data = l), (r = c);
									} else {
										if (1 !== c.nodeType) {
											c = sb(c);
											continue;
										}
										n(c) || "BR" === c.nodeName
											? (r && (r.data = r.data.replace(/ $/, "")),
												(r = null),
												(s = !1))
											: o(c) && ((r = null), (s = !0));
									}
									var d = ab(a, c, i);
									(a = c), (c = d);
								}
								r && ((r.data = r.data.replace(/ $/, "")), r.data || sb(r));
							}
						})({ element: e, isBlock: Xk, isVoid: tb }),
						e
					);
				}
				function gb(t) {
					return (
						(t.isBlock = Xk(t)),
						(t.isCode =
							"code" === t.nodeName.toLowerCase() || t.parentNode.isCode),
						(t.isBlank = (function (t) {
							return (
								-1 ===
									[
										"A",
										"TH",
										"TD",
										"IFRAME",
										"SCRIPT",
										"AUDIO",
										"VIDEO",
									].indexOf(t.nodeName) &&
								/^\s*$/i.test(t.textContent) &&
								!tb(t) &&
								!(function (t) {
									return t.querySelector && t.querySelector(eb);
								})(t)
							);
						})(t)),
						(t.flankingWhitespace = (function (t) {
							var e = "",
								n = "";
							if (!t.isBlock) {
								var o = /^\s/.test(t.textContent),
									i = /\s$/.test(t.textContent),
									r = t.isBlank && o && i;
								o && !fb("left", t) && (e = " "),
									r || !i || fb("right", t) || (n = " ");
							}
							return { leading: e, trailing: n };
						})(t)),
						t
					);
				}
				function fb(t, e) {
					var n, o, i;
					return (
						"left" === t
							? ((n = e.previousSibling), (o = / $/))
							: ((n = e.nextSibling), (o = /^ /)),
						n &&
							(3 === n.nodeType
								? (i = o.test(n.nodeValue))
								: 1 !== n.nodeType || Xk(n) || (i = o.test(n.textContent))),
						i
					);
				}
				var mb = Array.prototype.reduce,
					kb = /^\n*/,
					bb = /\n*$/,
					wb = [
						[/\\/g, "\\\\"],
						[/\*/g, "\\*"],
						[/^-/g, "\\-"],
						[/^\+ /g, "\\+ "],
						[/^(=+)/g, "\\$1"],
						[/^(#{1,6}) /g, "\\$1 "],
						[/`/g, "\\`"],
						[/^~~~/g, "\\~~~"],
						[/\[/g, "\\["],
						[/\]/g, "\\]"],
						[/^>/g, "\\>"],
						[/_/g, "\\_"],
						[/^(\d+)\. /g, "$1\\. "],
					];
				function Ab(t) {
					if (!(this instanceof Ab)) return new Ab(t);
					var e = {
						rules: nb,
						headingStyle: "setext",
						hr: "* * *",
						bulletListMarker: "*",
						codeBlockStyle: "indented",
						fence: "```",
						emDelimiter: "_",
						strongDelimiter: "**",
						linkStyle: "inlined",
						linkReferenceStyle: "full",
						br: "  ",
						blankReplacement: function (t, e) {
							return e.isBlock ? "\n\n" : "";
						},
						keepReplacement: function (t, e) {
							return e.isBlock ? "\n\n" + e.outerHTML + "\n\n" : e.outerHTML;
						},
						defaultReplacement: function (t, e) {
							return e.isBlock ? "\n\n" + t + "\n\n" : t;
						},
					};
					(this.options = (function (t) {
						for (var e = 1; e < arguments.length; e++) {
							var n = arguments[e];
							for (var o in n) n.hasOwnProperty(o) && (t[o] = n[o]);
						}
						return t;
					})({}, e, t)),
						(this.rules = new ob(this.options));
				}
				function _b(t) {
					var e = this;
					return mb.call(
						t.childNodes,
						function (t, n) {
							var o = "";
							return (
								3 === (n = new gb(n)).nodeType
									? (o = n.isCode ? n.nodeValue : e.escape(n.nodeValue))
									: 1 === n.nodeType && (o = vb.call(e, n)),
								yb(t, o)
							);
						},
						"",
					);
				}
				function Cb(t) {
					var e = this;
					return (
						this.rules.forEach(function (n) {
							"function" == typeof n.append && (t = yb(t, n.append(e.options)));
						}),
						t.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "")
					);
				}
				function vb(t) {
					var e = this.rules.forNode(t),
						n = _b.call(this, t),
						o = t.flankingWhitespace;
					return (
						(o.leading || o.trailing) && (n = n.trim()),
						o.leading + e.replacement(n, t, this.options) + o.trailing
					);
				}
				function yb(t, e) {
					var n,
						o,
						i,
						r =
							((n = e),
							(o = [t.match(bb)[0], n.match(kb)[0]].sort()),
							(i = o[o.length - 1]).length < 2 ? i : "\n\n");
					return (t = t.replace(bb, "")) + r + (e = e.replace(kb, ""));
				}
				Ab.prototype = {
					turndown: function (t) {
						if (
							!(function (t) {
								return (
									null != t &&
									("string" == typeof t ||
										(t.nodeType &&
											(1 === t.nodeType ||
												9 === t.nodeType ||
												11 === t.nodeType)))
								);
							})(t)
						)
							throw new TypeError(
								t + " is not a string, or an element/document/fragment node.",
							);
						if ("" === t) return "";
						var e = _b.call(this, new pb(t));
						return Cb.call(this, e);
					},
					use: function (t) {
						if (Array.isArray(t))
							for (var e = 0; e < t.length; e++) this.use(t[e]);
						else {
							if ("function" != typeof t)
								throw new TypeError(
									"plugin must be a Function or an Array of Functions",
								);
							t(this);
						}
						return this;
					},
					addRule: function (t, e) {
						return this.rules.add(t, e), this;
					},
					keep: function (t) {
						return this.rules.keep(t), this;
					},
					remove: function (t) {
						return this.rules.remove(t), this;
					},
					escape: function (t) {
						return wb.reduce(function (t, e) {
							return t.replace(e[0], e[1]);
						}, t);
					},
				};
				var xb = Ab,
					Db = /highlight-(?:text|source)-([a-z0-9]+)/;
				function Eb(t) {
					t.addRule("highlightedCodeBlock", {
						filter: function (t) {
							var e = t.firstChild;
							return (
								"DIV" === t.nodeName &&
								Db.test(t.className) &&
								e &&
								"PRE" === e.nodeName
							);
						},
						replacement: function (t, e, n) {
							var o = ((e.className || "").match(Db) || [null, ""])[1];
							return (
								"\n\n" +
								n.fence +
								o +
								"\n" +
								e.firstChild.textContent +
								"\n" +
								n.fence +
								"\n\n"
							);
						},
					});
				}
				function Sb(t) {
					t.addRule("strikethrough", {
						filter: ["del", "s", "strike"],
						replacement: function (t) {
							return "~" + t + "~";
						},
					});
				}
				var Bb = Array.prototype.indexOf,
					Tb = Array.prototype.every,
					Pb = {};
				function Fb(t) {
					var e,
						n,
						o = t.parentNode;
					return (
						"THEAD" === o.nodeName ||
						(o.firstChild === t &&
							("TABLE" === o.nodeName ||
								((n = (e = o).previousSibling),
								"TBODY" === e.nodeName &&
									(!n ||
										("THEAD" === n.nodeName &&
											/^\s*$/i.test(n.textContent))))) &&
							Tb.call(t.childNodes, function (t) {
								return "TH" === t.nodeName;
							}))
					);
				}
				function Ib(t, e) {
					var n = " ";
					return (
						0 === Bb.call(e.parentNode.childNodes, e) && (n = "| "),
						n + t + " |"
					);
				}
				function zb(t) {
					for (var e in (t.keep(function (t) {
						return "TABLE" === t.nodeName && !Fb(t.rows[0]);
					}),
					Pb))
						t.addRule(e, Pb[e]);
				}
				function Rb(t) {
					t.addRule("taskListItems", {
						filter: function (t) {
							return "checkbox" === t.type && "LI" === t.parentNode.nodeName;
						},
						replacement: function (t, e) {
							return (e.checked ? "[x]" : "[ ]") + " ";
						},
					});
				}
				(Pb.tableCell = {
					filter: ["th", "td"],
					replacement: function (t, e) {
						return Ib(t, e);
					},
				}),
					(Pb.tableRow = {
						filter: "tr",
						replacement: function (t, e) {
							var n = "",
								o = { left: ":--", right: "--:", center: ":-:" };
							if (Fb(e))
								for (var i = 0; i < e.childNodes.length; i++) {
									var r = "---",
										s = (
											e.childNodes[i].getAttribute("align") || ""
										).toLowerCase();
									s && (r = o[s] || r), (n += Ib(r, e.childNodes[i]));
								}
							return "\n" + t + (n ? "\n" + n : "");
						},
					}),
					(Pb.table = {
						filter: function (t) {
							return "TABLE" === t.nodeName && Fb(t.rows[0]);
						},
						replacement: function (t) {
							return "\n\n" + (t = t.replace("\n\n", "\n")) + "\n\n";
						},
					}),
					(Pb.tableSection = {
						filter: ["thead", "tbody", "tfoot"],
						replacement: function (t) {
							return t;
						},
					});
				const Ob = xb.prototype.escape;
				function Mb(t) {
					return (t = (t = Ob(t)).replace(/</g, "\\<"));
				}
				xb.prototype.escape = function (t) {
					let e = "",
						n = 0;
					for (const o of (function* (t) {
						for (const e of t.matchAll(Vb)) {
							const t = e[0],
								n = Lb(t);
							yield Object.assign([t.substring(0, n)], { index: e.index });
						}
					})(t)) {
						const i = o.index;
						i > n && (e += Mb(t.substring(n, i)));
						const r = o[0];
						(e += r), (n = i + r.length);
					}
					return n < t.length && (e += Mb(t.substring(n, t.length))), e;
				};
				const Nb = new xb({
					codeBlockStyle: "fenced",
					hr: "---",
					headingStyle: "atx",
				});
				Nb.use([
					function (t) {
						t.use([Eb, Sb, zb, Rb]);
					},
					function (t) {
						t.addRule("taskListItems", {
							filter: (t) =>
								"checkbox" === t.type &&
								("LI" === t.parentNode.nodeName ||
									"LI" === t.parentNode.parentNode.nodeName),
							replacement: (t, e) => (e.checked ? "[x]" : "[ ]") + " ",
						});
					},
				]);
				const Vb = new RegExp(
					/\b(?:(?:https?|ftp):\/\/|www\.)/.source +
						/(?![-_])(?:[-_a-z0-9\u00a1-\uffff]{1,63}\.)+(?:[a-z\u00a1-\uffff]{2,63})/
							.source +
						/(?:[^\s<>]*)/.source,
					"gi",
				);
				function Lb(t) {
					let e = t.length;
					for (; e > 0; ) {
						const n = t[e - 1];
						if ("?!.,:*_~'\"".includes(n)) e--;
						else {
							if (")" != n) break;
							{
								let n = 0;
								for (let o = 0; o < e; o++)
									"(" == t[o] ? n++ : ")" == t[o] && n--;
								if (!(n < 0)) break;
								e--;
							}
						}
					}
					return e;
				}
				class jb {
					constructor(t) {
						this._htmlDP = new nl(t);
					}
					keepHtml(t) {
						Nb.keep([t]);
					}
					toView(t) {
						const e =
							((n = t),
							Jk.marked.parse(n, {
								gfm: !0,
								breaks: !0,
								tables: !0,
								xhtml: !0,
								headerIds: !1,
							}));
						var n;
						return this._htmlDP.toView(e);
					}
					toData(t) {
						return (function (t) {
							return Nb.turndown(t);
						})(this._htmlDP.toData(t));
					}
					registerRawContentMatcher(t) {
						this._htmlDP.registerRawContentMatcher(t);
					}
					useFillerType() {}
				}
				class Hb extends M {
					refresh() {
						const t = this.editor.model,
							e = t.document;
						this.isEnabled = t.schema.checkAttributeInSelection(
							e.selection,
							"mention",
						);
					}
					execute(t) {
						const e = this.editor.model,
							n = e.document.selection,
							o = "string" == typeof t.mention ? { id: t.mention } : t.mention,
							i = o.id,
							r = t.range || n.getFirstRange(),
							s = t.text || i,
							a = qb({ _text: s, id: i }, o);
						if (1 != t.marker.length)
							throw new l.a("mentioncommand-incorrect-marker", this);
						if (i.charAt(0) != t.marker)
							throw new l.a("mentioncommand-incorrect-id", this);
						e.change((t) => {
							const o = mo(n.getAttributes()),
								i = new Map(o.entries());
							i.set("mention", a),
								e.insertContent(t.createText(s, i), r),
								e.insertContent(
									t.createText(" ", o),
									r.start.getShiftedBy(s.length),
								);
						});
					}
				}
				class $b extends R {
					static get pluginName() {
						return "MentionEditing";
					}
					init() {
						const t = this.editor,
							e = t.model,
							n = e.document;
						e.schema.extend("$text", { allowAttributes: "mention" }),
							t.conversion
								.for("upcast")
								.elementToAttribute({
									view: {
										name: "span",
										key: "data-mention",
										classes: "mention",
									},
									model: { key: "mention", value: (t) => Ub(t) },
								}),
							t.conversion
								.for("downcast")
								.attributeToElement({ model: "mention", view: Kb }),
							t.conversion.for("downcast").add(Wb),
							n.registerPostFixer((t) =>
								(function (t, e, n) {
									const o = e.differ.getChanges();
									let i = !1;
									for (const e of o) {
										const o = e.position;
										if ("$text" == e.name) {
											const e = o.textNode && o.textNode.nextSibling;
											(i = Jb(o.textNode, t) || i),
												(i = Jb(e, t) || i),
												(i = Jb(o.nodeBefore, t) || i),
												(i = Jb(o.nodeAfter, t) || i);
										}
										if ("$text" != e.name && "insert" == e.type) {
											const e = o.nodeAfter;
											for (const n of t.createRangeIn(e).getItems())
												i = Jb(n, t) || i;
										}
										if ("insert" == e.type && n.isInline(e.name)) {
											const e = o.nodeAfter && o.nodeAfter.nextSibling;
											(i = Jb(o.nodeBefore, t) || i), (i = Jb(e, t) || i);
										}
									}
									return i;
								})(t, n, e.schema),
							),
							n.registerPostFixer((t) =>
								(function (t, e) {
									const n = e.differ.getChanges();
									let o = !1;
									for (const e of n)
										if ("attribute" === e.type && "mention" != e.attributeKey) {
											const n = e.range.start.nodeBefore,
												i = e.range.end.nodeAfter;
											for (const r of [n, i])
												Gb(r) &&
													r.getAttribute(e.attributeKey) !=
														e.attributeNewValue &&
													(t.setAttribute(
														e.attributeKey,
														e.attributeNewValue,
														r,
													),
													(o = !0));
										}
									return o;
								})(t, n),
							),
							n.registerPostFixer((t) =>
								(function (t, e) {
									const n = e.selection,
										o = n.focus;
									if (
										n.isCollapsed &&
										n.hasAttribute("mention") &&
										(function (t) {
											const e = t.isAtStart;
											return (t.nodeBefore && t.nodeBefore.is("$text")) || e;
										})(o)
									)
										return t.removeSelectionAttribute("mention"), !0;
								})(t, n),
							),
							t.commands.add("mention", new Hb(t));
					}
				}
				function qb(t, e) {
					return Object.assign({ uid: s() }, t, e || {});
				}
				function Ub(t, e) {
					const n = t.getAttribute("data-mention"),
						o = t.getChild(0);
					if (!o) return;
					return qb({ id: n, _text: o.data }, e);
				}
				function Wb(t) {
					t.on(
						"attribute:mention",
						(t, e, n) => {
							const o = e.attributeNewValue;
							if (!e.item.is("$textProxy") || !o) return;
							const i = e.range.start;
							(i.textNode || i.nodeAfter).data != o._text &&
								n.consumable.consume(e.item, t.name);
						},
						{ priority: "highest" },
					);
				}
				function Kb(t, { writer: e }) {
					if (!t) return;
					const n = { class: "mention", "data-mention": t.id },
						o = { id: t.uid, priority: 20 };
					return e.createAttributeElement("span", n, o);
				}
				function Gb(t) {
					if (
						!t ||
						(!t.is("$text") && !t.is("$textProxy")) ||
						!t.hasAttribute("mention")
					)
						return !1;
					return t.data != t.getAttribute("mention")._text;
				}
				function Jb(t, e) {
					return !!Gb(t) && (e.removeAttribute("mention", t), !0);
				}
				var Yb = n(58),
					Qb = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Yb.a, Qb), Yb.a.locals;
				class Xb extends xh {
					constructor(t) {
						super(t),
							this.extendTemplate({
								attributes: { class: ["ck-mentions"], tabindex: "-1" },
							});
					}
					selectFirst() {
						this.select(0);
					}
					selectNext() {
						const t = this.selected,
							e = this.items.getIndex(t);
						this.select(e + 1);
					}
					selectPrevious() {
						const t = this.selected,
							e = this.items.getIndex(t);
						this.select(e - 1);
					}
					select(t) {
						let e = 0;
						t > 0 && t < this.items.length
							? (e = t)
							: t < 0 && (e = this.items.length - 1);
						const n = this.items.get(e);
						this.selected !== n &&
							(this.selected && this.selected.removeHighlight(),
							n.highlight(),
							(this.selected = n),
							this._isItemVisibleInScrolledArea(n) ||
								(this.element.scrollTop = n.element.offsetTop));
					}
					executeSelected() {
						this.selected.fire("execute");
					}
					_isItemVisibleInScrolledArea(t) {
						return new aa(this.element).contains(new aa(t.element));
					}
				}
				class Zb extends fu {
					constructor(t, e) {
						super(t),
							(this.template = !1),
							(this.domElement = e),
							this.domElement.classList.add("ck-button"),
							this.set("isOn", !1),
							this.on("change:isOn", (t, e, n) => {
								n
									? (this.domElement.classList.add("ck-on"),
										this.domElement.classList.remove("ck-off"))
									: (this.domElement.classList.add("ck-off"),
										this.domElement.classList.remove("ck-on"));
							}),
							this.listenTo(this.domElement, "click", () => {
								this.fire("execute");
							});
					}
					render() {
						super.render(), (this.element = this.domElement);
					}
				}
				class tw extends Dh {
					highlight() {
						this.children.first.isOn = !0;
					}
					removeHighlight() {
						this.children.first.isOn = !1;
					}
				}
				const ew = [Ji.arrowup, Ji.arrowdown, Ji.esc],
					nw = [Ji.enter, Ji.tab];
				class ow extends R {
					static get pluginName() {
						return "MentionUI";
					}
					static get requires() {
						return [cp];
					}
					constructor(t) {
						super(t),
							(this._mentionsView = this._createMentionView()),
							(this._mentionsConfigurations = new Map()),
							(this._requestFeedDebounced = ys(this._requestFeed, 100)),
							t.config.define("mention", { feeds: [] });
					}
					init() {
						const t = this.editor,
							e = t.config.get("mention.commitKeys") || nw,
							n = ew.concat(e);
						(this._balloon = t.plugins.get(cp)),
							t.editing.view.document.on(
								"keydown",
								(t, o) => {
									var i;
									(i = o.keyCode),
										n.includes(i) &&
											this._isUIVisible &&
											(o.preventDefault(),
											t.stop(),
											o.keyCode == Ji.arrowdown &&
												this._mentionsView.selectNext(),
											o.keyCode == Ji.arrowup &&
												this._mentionsView.selectPrevious(),
											e.includes(o.keyCode) &&
												this._mentionsView.executeSelected(),
											o.keyCode == Ji.esc && this._hideUIAndRemoveMarker());
								},
								{ priority: "highest" },
							),
							Vu({
								emitter: this._mentionsView,
								activator: () => this._isUIVisible,
								contextElements: [this._balloon.view.element],
								callback: () => this._hideUIAndRemoveMarker(),
							});
						const o = t.config.get("mention.feeds");
						for (const t of o) {
							const e = t.feed,
								n = t.marker;
							if (!cw(n))
								throw new l.a("mentionconfig-incorrect-marker", null, {
									marker: n,
								});
							const o = {
								marker: n,
								feedCallback:
									"function" == typeof e ? e.bind(this.editor) : aw(e),
								itemRenderer: t.itemRenderer,
							};
							this._mentionsConfigurations.set(n, o);
						}
						this._setupTextWatcher(o),
							this.listenTo(t, "change:isReadOnly", () => {
								this._hideUIAndRemoveMarker();
							}),
							this.on("requestFeed:response", (t, e) =>
								this._handleFeedResponse(e),
							),
							this.on("requestFeed:error", () => this._hideUIAndRemoveMarker());
					}
					destroy() {
						super.destroy(), this._mentionsView.destroy();
					}
					get _isUIVisible() {
						return this._balloon.visibleView === this._mentionsView;
					}
					_createMentionView() {
						const t = this.editor.locale,
							e = new Xb(t);
						return (
							(this._items = new Xn()),
							e.items.bindTo(this._items).using((n) => {
								const { item: o, marker: i } = n,
									r = this.editor.config.get("mention.dropdownLimit") || 10;
								if (e.items.length >= r) return;
								const s = new tw(t),
									a = this._renderItem(o, i);
								return (
									a.delegate("execute").to(s),
									s.children.add(a),
									(s.item = o),
									(s.marker = i),
									s.on("execute", () => {
										e.fire("execute", { item: o, marker: i });
									}),
									s
								);
							}),
							e.on("execute", (t, e) => {
								const n = this.editor,
									o = n.model,
									i = e.item,
									r = e.marker,
									s = n.model.markers.get("mention"),
									a = o.createPositionAt(o.document.selection.focus),
									c = o.createPositionAt(s.getStart()),
									l = o.createRange(c, a);
								this._hideUIAndRemoveMarker(),
									n.execute("mention", {
										mention: i,
										text: i.text,
										marker: r,
										range: l,
									}),
									n.editing.view.focus();
							}),
							e
						);
					}
					_getItemRenderer(t) {
						const { itemRenderer: e } = this._mentionsConfigurations.get(t);
						return e;
					}
					_requestFeed(t, e) {
						this._lastRequested = e;
						const { feedCallback: n } = this._mentionsConfigurations.get(t),
							o = n(e);
						o instanceof Promise
							? o
									.then((n) => {
										this._lastRequested == e
											? this.fire("requestFeed:response", {
													feed: n,
													marker: t,
													feedText: e,
												})
											: this.fire("requestFeed:discarded", {
													feed: n,
													marker: t,
													feedText: e,
												});
									})
									.catch((e) => {
										this.fire("requestFeed:error", { error: e }),
											Object(l.b)("mention-feed-callback-error", { marker: t });
									})
							: this.fire("requestFeed:response", {
									feed: o,
									marker: t,
									feedText: e,
								});
					}
					_setupTextWatcher(t) {
						const e = this.editor,
							n = t.map((t) => ({
								...t,
								pattern: sw(t.marker, t.minimumCharacters || 0),
							})),
							o = new Op(
								e.model,
								(function (t) {
									return (e) => {
										const n = rw(t, e);
										if (!n) return !1;
										let o = 0;
										0 !== n.position && (o = n.position - 1);
										const i = e.substring(o);
										return n.pattern.test(i);
									};
								})(n),
							);
						o.on("matched", (t, o) => {
							const i = rw(n, o.text),
								r = e.model.document.selection.focus,
								s = e.model.createPositionAt(r.parent, i.position);
							if (
								(function (t) {
									const e = t.textNode && t.textNode.hasAttribute("mention"),
										n = t.nodeBefore;
									return e || (n && n.is("$text") && n.hasAttribute("mention"));
								})(r) ||
								(function (t) {
									const e = t.nodeAfter;
									return e && e.is("$text") && e.hasAttribute("mention");
								})(s)
							)
								return void this._hideUIAndRemoveMarker();
							const a = (function (t, e) {
									let n = 0;
									0 !== t.position && (n = t.position - 1);
									const o = sw(t.marker, 0),
										i = e.substring(n);
									return i.match(o)[2];
								})(i, o.text),
								c = i.marker.length + a.length,
								l = r.getShiftedBy(-c),
								d = r.getShiftedBy(-a.length),
								u = e.model.createRange(l, d);
							if (lw(e)) {
								const t = e.model.markers.get("mention");
								e.model.change((e) => {
									e.updateMarker(t, { range: u });
								});
							} else
								e.model.change((t) => {
									t.addMarker("mention", {
										range: u,
										usingOperation: !1,
										affectsData: !1,
									});
								});
							this._requestFeedDebounced(i.marker, a);
						}),
							o.on("unmatched", () => {
								this._hideUIAndRemoveMarker();
							});
						const i = e.commands.get("mention");
						return o.bind("isEnabled").to(i), o;
					}
					_handleFeedResponse(t) {
						const { feed: e, marker: n } = t;
						if (!lw(this.editor)) return;
						this._items.clear();
						for (const t of e) {
							const e = "object" != typeof t ? { id: t, text: t } : t;
							this._items.add({ item: e, marker: n });
						}
						const o = this.editor.model.markers.get("mention");
						this._items.length
							? this._showOrUpdateUI(o)
							: this._hideUIAndRemoveMarker();
					}
					_showOrUpdateUI(t) {
						this._isUIVisible
							? this._balloon.updatePosition(
									this._getBalloonPanelPositionData(
										t,
										this._mentionsView.position,
									),
								)
							: this._balloon.add({
									view: this._mentionsView,
									position: this._getBalloonPanelPositionData(
										t,
										this._mentionsView.position,
									),
									singleViewMode: !0,
								}),
							(this._mentionsView.position = this._balloon.view.position),
							this._mentionsView.selectFirst();
					}
					_hideUIAndRemoveMarker() {
						this._balloon.hasView(this._mentionsView) &&
							this._balloon.remove(this._mentionsView),
							lw(this.editor) &&
								this.editor.model.change((t) => t.removeMarker("mention")),
							(this._mentionsView.position = void 0);
					}
					_renderItem(t, e) {
						const n = this.editor;
						let o,
							i = t.id;
						const r = this._getItemRenderer(e);
						if (r) {
							const e = r(t);
							"string" != typeof e ? (o = new Zb(n.locale, e)) : (i = e);
						}
						if (!o) {
							const t = new Ju(n.locale);
							(t.label = i), (t.withText = !0), (o = t);
						}
						return o;
					}
					_getBalloonPanelPositionData(t, e) {
						const n = this.editor,
							o = n.editing,
							i = o.view.domConverter,
							r = o.mapper;
						return {
							target: () => {
								let e = t.getRange();
								"$graveyard" == e.start.root.rootName &&
									(e = n.model.document.selection.getFirstRange());
								const o = r.toViewRange(e);
								return aa.getDomRangeRects(i.viewRangeToDom(o)).pop();
							},
							limiter: () => {
								const t = this.editor.editing.view,
									e = t.document.selection.editableElement;
								return e ? t.domConverter.mapViewToDom(e.root) : null;
							},
							positions: iw(e),
						};
					}
				}
				function iw(t) {
					const e = {
						caret_se: (t) => ({
							top: t.bottom + 3,
							left: t.right,
							name: "caret_se",
							config: { withArrow: !1 },
						}),
						caret_ne: (t, e) => ({
							top: t.top - e.height - 3,
							left: t.right,
							name: "caret_ne",
							config: { withArrow: !1 },
						}),
						caret_sw: (t, e) => ({
							top: t.bottom + 3,
							left: t.right - e.width,
							name: "caret_sw",
							config: { withArrow: !1 },
						}),
						caret_nw: (t, e) => ({
							top: t.top - e.height - 3,
							left: t.right - e.width,
							name: "caret_nw",
							config: { withArrow: !1 },
						}),
					};
					return Object.prototype.hasOwnProperty.call(e, t)
						? [e[t]]
						: [e.caret_se, e.caret_sw, e.caret_ne, e.caret_nw];
				}
				function rw(t, e) {
					let n;
					for (const o of t) {
						const t = e.lastIndexOf(o.marker);
						(t > 0 && !e.substring(t - 1).match(o.pattern)) ||
							((!n || t >= n.position) &&
								(n = {
									marker: o.marker,
									position: t,
									minimumCharacters: o.minimumCharacters,
									pattern: o.pattern,
								}));
					}
					return n;
				}
				function sw(t, e) {
					const n = 0 == e ? "*" : `{${e},}`,
						o = Ui.features.isRegExpUnicodePropertySupported
							? "\\p{Ps}\\p{Pi}\"'"
							: "\\(\\[{\"'";
					return new RegExp(`(?:^|[ ${o}])([${t}])(.${n})$`, "u");
				}
				function aw(t) {
					return (e) =>
						t.filter((t) =>
							("string" == typeof t ? t : String(t.id))
								.toLowerCase()
								.includes(e.toLowerCase()),
						);
				}
				function cw(t) {
					return t && 1 == t.length;
				}
				function lw(t) {
					return t.model.markers.has("mention");
				}
				var dw = n(59),
					uw = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(dw.a, uw), dw.a.locals;
				function hw(t, e, n, { blockElements: o, inlineObjectElements: i }) {
					let r = n.createPositionAt(t, "forward" == e ? "after" : "before");
					return (
						(r = r.getLastMatchingPosition(
							({ item: t }) =>
								t.is("element") && !o.includes(t.name) && !i.includes(t.name),
							{ direction: e },
						)),
						"forward" == e ? r.nodeAfter : r.nodeBefore
					);
				}
				function pw(t, e) {
					return !!t && t.is("element") && e.includes(t.name);
				}
				function gw(t, e) {
					if (!t.childCount) return;
					const n = new Fd(t.document),
						o = (function (t, e) {
							const n = e.createRangeIn(t),
								o = new ko({ name: /^p|h\d+$/, styles: { "mso-list": /.*/ } }),
								i = [];
							for (const t of n)
								if ("elementStart" === t.type && o.match(t.item)) {
									const e = kw(t.item);
									i.push({
										element: t.item,
										id: e.id,
										order: e.order,
										indent: e.indent,
									});
								}
							return i;
						})(t, n);
					if (!o.length) return;
					let i = null,
						r = 1;
					o.forEach((t, s) => {
						const a = (function (t, e) {
								if (!t) return !0;
								if (t.id !== e.id) return e.indent - t.indent != 1;
								const n = e.element.previousSibling;
								if (!n) return !0;
								return (
									(o = n), !(o.is("element", "ol") || o.is("element", "ul"))
								);
								var o;
							})(o[s - 1], t),
							c = a ? null : o[s - 1],
							l = ((u = t), (d = c) ? u.indent - d.indent : u.indent - 1);
						var d, u;
						if ((a && ((i = null), (r = 1)), !i || 0 !== l)) {
							const o = (function (t, e) {
								const n = new RegExp(
										`@list l${t.id}:level${t.indent}\\s*({[^}]*)`,
										"gi",
									),
									o = /mso-level-number-format:([^;]{0,100});/gi,
									i = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi,
									r = n.exec(e);
								let s = "decimal",
									a = "ol",
									c = null;
								if (r && r[1]) {
									const e = o.exec(r[1]);
									if (
										(e &&
											e[1] &&
											((s = e[1].trim()),
											(a = "bullet" !== s && "image" !== s ? "ol" : "ul")),
										"bullet" === s)
									) {
										const e = (function (t) {
											const e = (function (t) {
												if (t.getChild(0).is("$text")) return null;
												for (const e of t.getChildren()) {
													if (!e.is("element", "span")) continue;
													const t = e.getChild(0);
													return t.is("$text") ? t : t.getChild(0);
												}
											})(t);
											if (!e) return null;
											const n = e._data;
											if ("o" === n) return "circle";
											if ("·" === n) return "disc";
											if ("§" === n) return "square";
											return null;
										})(t.element);
										e && (s = e);
									} else {
										const t = i.exec(r[1]);
										t && t[1] && (c = parseInt(t[1]));
									}
								}
								return { type: a, startIndex: c, style: fw(s) };
							})(t, e);
							if (i) {
								if (t.indent > r) {
									const t = i.getChild(i.childCount - 1),
										e = t.getChild(t.childCount - 1);
									(i = mw(o, e, n)), (r += 1);
								} else if (t.indent < r) {
									const e = r - t.indent;
									(i = (function (t, e) {
										const n = t.getAncestors({ parentFirst: !0 });
										let o = null,
											i = 0;
										for (const t of n)
											if (
												(("ul" !== t.name && "ol" !== t.name) || i++, i === e)
											) {
												o = t;
												break;
											}
										return o;
									})(i, e)),
										(r = parseInt(t.indent));
								}
							} else i = mw(o, t.element, n);
							t.indent <= r &&
								(i.is("element", o.type) || (i = n.rename(o.type, i)));
						}
						const h = (function (t, e) {
							return (
								(function (t, e) {
									const n = new ko({
											name: "span",
											styles: { "mso-list": "Ignore" },
										}),
										o = e.createRangeIn(t);
									for (const t of o)
										"elementStart" === t.type &&
											n.match(t.item) &&
											e.remove(t.item);
								})(t, e),
								e.rename("li", t)
							);
						})(t.element, n);
						n.appendChild(h, i);
					});
				}
				function fw(t) {
					if (t.startsWith("arabic-leading-zero"))
						return "decimal-leading-zero";
					switch (t) {
						case "alpha-upper":
							return "upper-alpha";
						case "alpha-lower":
							return "lower-alpha";
						case "roman-upper":
							return "upper-roman";
						case "roman-lower":
							return "lower-roman";
						case "circle":
						case "disc":
						case "square":
							return t;
						default:
							return null;
					}
				}
				function mw(t, e, n) {
					const o = e.parent,
						i = n.createElement(t.type),
						r = o.getChildIndex(e) + 1;
					return (
						n.insertChild(r, i, o),
						t.style && n.setStyle("list-style-type", t.style, i),
						t.startIndex &&
							t.startIndex > 1 &&
							n.setAttribute("start", t.startIndex, i),
						i
					);
				}
				function kw(t) {
					const e = {},
						n = t.getStyle("mso-list");
					if (n) {
						const t = n.match(/(^|\s{1,100})l(\d+)/i),
							o = n.match(/\s{0,100}lfo(\d+)/i),
							i = n.match(/\s{0,100}level(\d+)/i);
						t && o && i && ((e.id = t[2]), (e.order = o[1]), (e.indent = i[1]));
					}
					return e;
				}
				const bw = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
				class ww {
					constructor(t) {
						this.document = t;
					}
					isActive(t) {
						return bw.test(t);
					}
					execute(t) {
						const e = new Fd(this.document),
							{ body: n } = t._parsedData;
						!(function (t, e) {
							for (const n of t.getChildren())
								if (
									n.is("element", "b") &&
									"normal" === n.getStyle("font-weight")
								) {
									const o = t.getChildIndex(n);
									e.remove(n), e.insertChild(o, n.getChildren(), t);
								}
						})(n, e),
							(function (t, e) {
								for (const n of e.createRangeIn(t)) {
									const t = n.item;
									if (t.is("element", "li")) {
										const n = t.getChild(0);
										n && n.is("element", "p") && e.unwrapElement(n);
									}
								}
							})(n, e),
							(function (t, e) {
								const n = new Mi(e.document.stylesProcessor),
									o = new Xr(n, { renderingMode: "data" }),
									i = o.blockElements,
									r = o.inlineObjectElements,
									s = [];
								for (const n of e.createRangeIn(t)) {
									const t = n.item;
									if (t.is("element", "br")) {
										const n = hw(t, "forward", e, {
												blockElements: i,
												inlineObjectElements: r,
											}),
											o = hw(t, "backward", e, {
												blockElements: i,
												inlineObjectElements: r,
											}),
											a = pw(n, i);
										(pw(o, i) || a) && s.push(t);
									}
								}
								for (const t of s)
									t.hasClass("Apple-interchange-newline")
										? e.remove(t)
										: e.replace(t, e.createElement("p"));
							})(n, e),
							(t.content = n);
					}
				}
				function Aw(t, e) {
					if (!t.childCount) return;
					const n = new Fd(),
						o = (function (t, e) {
							const n = e.createRangeIn(t),
								o = new ko({ name: /v:(.+)/ }),
								i = [];
							for (const t of n) {
								if ("elementStart" != t.type) continue;
								const e = t.item,
									n = (e.previousSibling && e.previousSibling.name) || null;
								o.match(e) &&
									e.getAttribute("o:gfxdata") &&
									"v:shapetype" !== n &&
									i.push(t.item.getAttribute("id"));
							}
							return i;
						})(t, n);
					!(function (t, e, n) {
						const o = n.createRangeIn(e),
							i = new ko({ name: "img" }),
							r = [];
						for (const e of o)
							if (i.match(e.item)) {
								const n = e.item,
									o = n.getAttribute("v:shapes")
										? n.getAttribute("v:shapes").split(" ")
										: [];
								o.length && o.every((e) => t.indexOf(e) > -1)
									? r.push(n)
									: n.getAttribute("src") || r.push(n);
							}
						for (const t of r) n.remove(t);
					})(o, t, n),
						(function (t, e) {
							const n = e.createRangeIn(t),
								o = new ko({ name: /v:(.+)/ }),
								i = [];
							for (const t of n)
								"elementStart" == t.type && o.match(t.item) && i.push(t.item);
							for (const t of i) e.remove(t);
						})(t, n);
					const i = (function (t, e) {
						const n = e.createRangeIn(t),
							o = new ko({ name: "img" }),
							i = [];
						for (const t of n)
							o.match(t.item) &&
								t.item.getAttribute("src").startsWith("file://") &&
								i.push(t.item);
						return i;
					})(t, n);
					i.length &&
						(function (t, e, n) {
							if (t.length === e.length)
								for (let o = 0; o < t.length; o++) {
									const i = `data:${e[o].type};base64,${_w(e[o].hex)}`;
									n.setAttribute("src", i, t[o]);
								}
						})(
							i,
							(function (t) {
								if (!t) return [];
								const e =
										/{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/,
									n = new RegExp(
										"(?:(" + e.source + "))([\\da-fA-F\\s]+)\\}",
										"g",
									),
									o = t.match(n),
									i = [];
								if (o)
									for (const t of o) {
										let n = !1;
										t.includes("\\pngblip")
											? (n = "image/png")
											: t.includes("\\jpegblip") && (n = "image/jpeg"),
											n &&
												i.push({
													hex: t.replace(e, "").replace(/[^\da-fA-F]/g, ""),
													type: n,
												});
									}
								return i;
							})(e),
							n,
						);
				}
				function _w(t) {
					return btoa(
						t
							.match(/\w{2}/g)
							.map((t) => String.fromCharCode(parseInt(t, 16)))
							.join(""),
					);
				}
				const Cw =
						/<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i,
					vw = /xmlns:o="urn:schemas-microsoft-com/i;
				class yw {
					constructor(t) {
						this.document = t;
					}
					isActive(t) {
						return Cw.test(t) || vw.test(t);
					}
					execute(t) {
						const { body: e, stylesString: n } = t._parsedData;
						gw(e, n),
							Aw(e, t.dataTransfer.getData("text/rtf")),
							(t.content = e);
					}
				}
				function xw(t) {
					return t.replace(
						/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g,
						(t, e) =>
							1 === e.length
								? " "
								: Array(e.length + 1)
										.join("  ")
										.substr(0, e.length),
					);
				}
				function Dw(t, e) {
					const n = new DOMParser(),
						o = (function (t) {
							return xw(xw(t))
								.replace(
									/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g,
									"$1$2",
								)
								.replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "")
								.replace(/ <\//g, " </")
								.replace(/ <o:p><\/o:p>/g, " <o:p></o:p>")
								.replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "")
								.replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><");
						})(
							(function (t) {
								const e = "</body>",
									n = "</html>",
									o = t.indexOf(e);
								if (o < 0) return t;
								const i = t.indexOf(n, o + e.length);
								return (
									t.substring(0, o + e.length) + (i >= 0 ? t.substring(i) : "")
								);
							})((t = t.replace(/<!--\[if gte vml 1]>/g, ""))),
						),
						i = n.parseFromString(o, "text/html");
					!(function (t) {
						t.querySelectorAll("span[style*=spacerun]").forEach((t) => {
							const e = t.innerText.length || 0;
							t.innerText = Array(e + 1)
								.join("  ")
								.substr(0, e);
						});
					})(i);
					const r = i.body.innerHTML,
						s = (function (t, e) {
							const n = new Mi(e),
								o = new Xr(n, { renderingMode: "data" }),
								i = t.createDocumentFragment(),
								r = t.body.childNodes;
							for (; r.length > 0; ) i.appendChild(r[0]);
							return o.domToView(i, { skipComments: !0 });
						})(i, e),
						a = (function (t) {
							const e = [],
								n = [],
								o = Array.from(t.getElementsByTagName("style"));
							for (const t of o)
								t.sheet &&
									t.sheet.cssRules &&
									t.sheet.cssRules.length &&
									(e.push(t.sheet), n.push(t.innerHTML));
							return { styles: e, stylesString: n.join(" ") };
						})(i);
					return {
						body: s,
						bodyString: r,
						styles: a.styles,
						stylesString: a.stylesString,
					};
				}
				function Ew(t) {
					const e = [
							{ name: "address", isVoid: !1 },
							{ name: "article", isVoid: !1 },
							{ name: "aside", isVoid: !1 },
							{ name: "blockquote", isVoid: !1 },
							{ name: "br", isVoid: !0 },
							{ name: "details", isVoid: !1 },
							{ name: "dialog", isVoid: !1 },
							{ name: "dd", isVoid: !1 },
							{ name: "div", isVoid: !1 },
							{ name: "dl", isVoid: !1 },
							{ name: "dt", isVoid: !1 },
							{ name: "fieldset", isVoid: !1 },
							{ name: "figcaption", isVoid: !1 },
							{ name: "figure", isVoid: !1 },
							{ name: "footer", isVoid: !1 },
							{ name: "form", isVoid: !1 },
							{ name: "h1", isVoid: !1 },
							{ name: "h2", isVoid: !1 },
							{ name: "h3", isVoid: !1 },
							{ name: "h4", isVoid: !1 },
							{ name: "h5", isVoid: !1 },
							{ name: "h6", isVoid: !1 },
							{ name: "header", isVoid: !1 },
							{ name: "hgroup", isVoid: !1 },
							{ name: "hr", isVoid: !0 },
							{ name: "input", isVoid: !0 },
							{ name: "li", isVoid: !1 },
							{ name: "main", isVoid: !1 },
							{ name: "nav", isVoid: !1 },
							{ name: "ol", isVoid: !1 },
							{ name: "p", isVoid: !1 },
							{ name: "section", isVoid: !1 },
							{ name: "table", isVoid: !1 },
							{ name: "tbody", isVoid: !1 },
							{ name: "td", isVoid: !1 },
							{ name: "textarea", isVoid: !1 },
							{ name: "th", isVoid: !1 },
							{ name: "thead", isVoid: !1 },
							{ name: "tr", isVoid: !1 },
							{ name: "ul", isVoid: !1 },
						],
						n = e.map((t) => t.name).join("|"),
						o = t
							.replace(new RegExp(`</?(${n})( .*?)?>`, "g"), "\n$&\n")
							.split("\n");
					let i = 0;
					return o
						.filter((t) => t.length)
						.map((t) =>
							(function (t, e) {
								return e.some(
									(e) =>
										!e.isVoid && !!new RegExp(`<${e.name}( .*?)?>`).test(t),
								);
							})(t, e)
								? Sw(t, i++)
								: (function (t, e) {
											return e.some((e) => new RegExp(`</${e.name}>`).test(t));
										})(t, e)
									? Sw(t, --i)
									: Sw(t, i),
						)
						.join("\n");
				}
				function Sw(t, e, n = "    ") {
					return `${n.repeat(Math.max(0, e))}${t}`;
				}
				var Bw = n(60),
					Tw = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Bw.a, Tw), Bw.a.locals;
				const Pw = "SourceEditingMode";
				function Fw(t) {
					return (function (t) {
						return t.startsWith("<");
					})(t)
						? Ew(t)
						: t;
				}
				const Iw = "strikethrough";
				class zw extends R {
					static get pluginName() {
						return "StrikethroughEditing";
					}
					init() {
						const t = this.editor;
						t.model.schema.extend("$text", { allowAttributes: Iw }),
							t.model.schema.setAttributeProperties(Iw, {
								isFormatting: !0,
								copyOnEnter: !0,
							}),
							t.conversion.attributeToElement({
								model: Iw,
								view: "s",
								upcastAlso: [
									"del",
									"strike",
									{ styles: { "text-decoration": "line-through" } },
								],
							}),
							t.commands.add(Iw, new jf(t, Iw)),
							t.keystrokes.set("CTRL+SHIFT+X", "strikethrough");
					}
				}
				const Rw = "strikethrough";
				class Ow extends R {
					static get pluginName() {
						return "StrikethroughUI";
					}
					init() {
						const t = this.editor,
							e = t.t;
						t.ui.componentFactory.add(Rw, (n) => {
							const o = t.commands.get(Rw),
								i = new Ju(n);
							return (
								i.set({
									label: e("Strikethrough"),
									icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>',
									keystroke: "CTRL+SHIFT+X",
									tooltip: !0,
									isToggleable: !0,
								}),
								i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"),
								this.listenTo(i, "execute", () => {
									t.execute(Rw), t.editing.view.focus();
								}),
								i
							);
						});
					}
				}
				const Mw = "todoListChecked";
				class Nw extends M {
					constructor(t) {
						super(t),
							(this._selectedElements = []),
							this.on(
								"execute",
								() => {
									this.refresh();
								},
								{ priority: "highest" },
							);
					}
					refresh() {
						(this._selectedElements = this._getSelectedItems()),
							(this.value = this._selectedElements.every(
								(t) => !!t.getAttribute("todoListChecked"),
							)),
							(this.isEnabled = !!this._selectedElements.length);
					}
					_getSelectedItems() {
						const t = this.editor.model,
							e = t.schema,
							n = t.document.selection.getFirstRange(),
							o = n.start.parent,
							i = [];
						e.checkAttribute(o, Mw) && i.push(o);
						for (const t of n.getItems())
							e.checkAttribute(t, Mw) && !i.includes(t) && i.push(t);
						return i;
					}
					execute(t = {}) {
						this.editor.model.change((e) => {
							for (const n of this._selectedElements) {
								(void 0 === t.forceValue ? !this.value : t.forceValue)
									? e.setAttribute(Mw, !0, n)
									: e.removeAttribute(Mw, n);
							}
						});
					}
				}
				function Vw(t, e, n) {
					const o = e.modelCursor,
						i = o.parent,
						r = e.viewItem;
					if (
						"checkbox" != r.getAttribute("type") ||
						"listItem" != i.name ||
						!o.isAtStart
					)
						return;
					if (!n.consumable.consume(r, { name: !0 })) return;
					const s = n.writer;
					s.setAttribute("listType", "todo", i),
						e.viewItem.hasAttribute("checked") &&
							s.setAttribute("todoListChecked", !0, i),
						(e.modelRange = s.createRange(o));
				}
				function Lw(t) {
					return (e, n) => {
						const o = n.modelPosition,
							i = o.parent;
						if (
							!i.is("element", "listItem") ||
							"todo" != i.getAttribute("listType")
						)
							return;
						const r = Hw(n.mapper.toViewElement(i), t);
						r && (n.viewPosition = n.mapper.findPositionIn(r, o.offset));
					};
				}
				function jw(t, e, n, o) {
					return e.createUIElement(
						"label",
						{ class: "todo-list__label", contenteditable: !1 },
						function (e) {
							const i = oa(document, "input", {
								type: "checkbox",
								tabindex: -1,
							});
							n && i.setAttribute("checked", "checked"),
								i.addEventListener("change", () => o(t));
							const r = this.toDomElement(e);
							return r.appendChild(i), r;
						},
					);
				}
				function Hw(t, e) {
					const n = e.createRangeIn(t);
					for (const t of n)
						if (
							t.item.is("containerElement", "span") &&
							t.item.hasClass("todo-list__label__description")
						)
							return t.item;
				}
				const $w = Xi("Ctrl+Enter");
				class qw extends R {
					static get pluginName() {
						return "TodoListEditing";
					}
					static get requires() {
						return [vk];
					}
					init() {
						const t = this.editor,
							{ editing: e, data: n, model: o } = t;
						o.schema.extend("listItem", {
							allowAttributes: ["todoListChecked"],
						}),
							o.schema.addAttributeCheck((t, e) => {
								const n = t.last;
								if (
									"todoListChecked" == e &&
									"listItem" == n.name &&
									"todo" != n.getAttribute("listType")
								)
									return !1;
							}),
							t.commands.add("todoList", new Gm(t, "todo"));
						const i = new Nw(t);
						var r, s;
						t.commands.add("checkTodoList", i),
							t.commands.add("todoListCheck", i),
							n.downcastDispatcher.on(
								"insert:listItem",
								(function (t) {
									return (e, n, o) => {
										const i = o.consumable;
										if (
											!i.test(n.item, "insert") ||
											!i.test(n.item, "attribute:listType") ||
											!i.test(n.item, "attribute:listIndent")
										)
											return;
										if ("todo" != n.item.getAttribute("listType")) return;
										const r = n.item;
										i.consume(r, "insert"),
											i.consume(r, "attribute:listType"),
											i.consume(r, "attribute:listIndent"),
											i.consume(r, "attribute:todoListChecked");
										const s = o.writer,
											a = Xm(r, o);
										s.addClass("todo-list", a.parent);
										const c = s.createContainerElement("label", {
												class: "todo-list__label",
											}),
											l = s.createEmptyElement("input", {
												type: "checkbox",
												disabled: "disabled",
											}),
											d = s.createContainerElement("span", {
												class: "todo-list__label__description",
											});
										r.getAttribute("todoListChecked") &&
											s.setAttribute("checked", "checked", l),
											s.insert(s.createPositionAt(a, 0), c),
											s.insert(s.createPositionAt(c, 0), l),
											s.insert(s.createPositionAfter(l), d),
											Zm(r, a, o, t);
									};
								})(o),
								{ priority: "high" },
							),
							n.upcastDispatcher.on("element:input", Vw, { priority: "high" }),
							e.downcastDispatcher.on(
								"insert:listItem",
								(function (t, e) {
									return (n, o, i) => {
										const r = i.consumable;
										if (
											!r.test(o.item, "insert") ||
											!r.test(o.item, "attribute:listType") ||
											!r.test(o.item, "attribute:listIndent")
										)
											return;
										if ("todo" != o.item.getAttribute("listType")) return;
										const s = o.item;
										r.consume(s, "insert"),
											r.consume(s, "attribute:listType"),
											r.consume(s, "attribute:listIndent"),
											r.consume(s, "attribute:todoListChecked");
										const a = i.writer,
											c = Xm(s, i),
											l = !!s.getAttribute("todoListChecked"),
											d = jw(s, a, l, e),
											u = a.createContainerElement("span", {
												class: "todo-list__label__description",
											});
										a.addClass("todo-list", c.parent),
											a.insert(a.createPositionAt(c, 0), d),
											a.insert(a.createPositionAfter(d), u),
											Zm(s, c, i, t);
									};
								})(o, (t) => this._handleCheckmarkChange(t)),
								{ priority: "high" },
							),
							e.downcastDispatcher.on(
								"attribute:listType:listItem",
								((r = (t) => this._handleCheckmarkChange(t)),
								(s = e.view),
								(t, e, n) => {
									if (!n.consumable.consume(e.item, t.name)) return;
									const o = n.mapper.toViewElement(e.item),
										i = n.writer,
										a = (function (t, e) {
											const n = e.createRangeIn(t);
											for (const t of n)
												if (t.item.is("uiElement", "label")) return t.item;
										})(o, s);
									if ("todo" == e.attributeNewValue) {
										const t = !!e.item.getAttribute("todoListChecked"),
											n = jw(e.item, i, t, r),
											s = i.createContainerElement("span", {
												class: "todo-list__label__description",
											}),
											a = i.createRangeIn(o),
											c = ik(o),
											l = ek(a.start),
											d = c ? i.createPositionBefore(c) : a.end,
											u = i.createRange(l, d);
										i.addClass("todo-list", o.parent),
											i.move(u, i.createPositionAt(s, 0)),
											i.insert(i.createPositionAt(o, 0), n),
											i.insert(i.createPositionAfter(n), s);
									} else if ("todo" == e.attributeOldValue) {
										const t = Hw(o, s);
										i.removeClass("todo-list", o.parent),
											i.remove(a),
											i.move(i.createRangeIn(t), i.createPositionBefore(t)),
											i.remove(t);
									}
								}),
							),
							e.downcastDispatcher.on(
								"attribute:todoListChecked:listItem",
								(function (t) {
									return (e, n, o) => {
										if ("todo" != n.item.getAttribute("listType")) return;
										if (
											!o.consumable.consume(n.item, "attribute:todoListChecked")
										)
											return;
										const { mapper: i, writer: r } = o,
											s = !!n.item.getAttribute("todoListChecked"),
											a = i.toViewElement(n.item).getChild(0),
											c = jw(n.item, r, s, t);
										r.insert(r.createPositionAfter(a), c), r.remove(a);
									};
								})((t) => this._handleCheckmarkChange(t)),
							),
							e.mapper.on("modelToViewPosition", Lw(e.view)),
							n.mapper.on("modelToViewPosition", Lw(e.view)),
							this.listenTo(
								e.view.document,
								"arrowKey",
								(function (t, e) {
									return (n, o) => {
										if ("left" != tr(o.keyCode, e.contentLanguageDirection))
											return;
										const i = t.schema,
											r = t.document.selection;
										if (!r.isCollapsed) return;
										const s = r.getFirstPosition(),
											a = s.parent;
										if (
											"listItem" === a.name &&
											"todo" == a.getAttribute("listType") &&
											s.isAtStart
										) {
											const e = i.getNearestSelectionRange(
												t.createPositionBefore(a),
												"backward",
											);
											e && t.change((t) => t.setSelection(e)),
												o.preventDefault(),
												o.stopPropagation(),
												n.stop();
										}
									};
								})(o, t.locale),
								{ context: "li" },
							),
							this.listenTo(
								e.view.document,
								"keydown",
								(e, n) => {
									Qi(n) === $w && (t.execute("checkTodoList"), e.stop());
								},
								{ priority: "high" },
							);
						const a = new Set();
						this.listenTo(o, "applyOperation", (t, e) => {
							const n = e[0];
							if ("rename" == n.type && "listItem" == n.oldName) {
								const t = n.position.nodeAfter;
								t.hasAttribute("todoListChecked") && a.add(t);
							} else if (
								"changeAttribute" == n.type &&
								"listType" == n.key &&
								"todo" === n.oldValue
							)
								for (const t of n.range.getItems())
									t.hasAttribute("todoListChecked") &&
										"todo" !== t.getAttribute("listType") &&
										a.add(t);
						}),
							o.document.registerPostFixer((t) => {
								let e = !1;
								for (const n of a)
									t.removeAttribute("todoListChecked", n), (e = !0);
								return a.clear(), e;
							});
					}
					_handleCheckmarkChange(t) {
						const e = this.editor,
							n = e.model,
							o = Array.from(n.document.selection.getRanges());
						n.change((n) => {
							n.setSelection(t, "end"),
								e.execute("checkTodoList"),
								n.setSelection(o);
						});
					}
				}
				class Uw extends R {
					static get pluginName() {
						return "TodoListUI";
					}
					init() {
						const t = this.editor.t;
						ok(
							this.editor,
							"todoList",
							t("To-do List"),
							'<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m2.315 14.705 2.224-2.24a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .949L2.865 16.07a.682.682 0 0 1-.112.089.647.647 0 0 1-.852-.051L.688 14.886a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.717.722zm5.185.045a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75zM2.329 5.745l2.21-2.226a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .95L2.865 7.125a.685.685 0 0 1-.496.196.644.644 0 0 1-.468-.187L.688 5.912a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.73.736zM7.5 5.75A.75.75 0 0 1 8.25 5h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>',
						);
					}
				}
				var Ww = n(61),
					Kw = {
						injectType: "singletonStyleTag",
						attributes: { "data-cke": !0 },
						insert: "head",
						singleton: !0,
					};
				Or()(Ww.a, Kw), Ww.a.locals;
				const Gw = "underline";
				class Jw extends R {
					static get pluginName() {
						return "UnderlineEditing";
					}
					init() {
						const t = this.editor;
						t.model.schema.extend("$text", { allowAttributes: Gw }),
							t.model.schema.setAttributeProperties(Gw, {
								isFormatting: !0,
								copyOnEnter: !0,
							}),
							t.conversion.attributeToElement({
								model: Gw,
								view: "u",
								upcastAlso: { styles: { "text-decoration": "underline" } },
							}),
							t.commands.add(Gw, new jf(t, Gw)),
							t.keystrokes.set("CTRL+U", "underline");
					}
				}
				const Yw = "underline";
				class Qw extends R {
					static get pluginName() {
						return "UnderlineUI";
					}
					init() {
						const t = this.editor,
							e = t.t;
						t.ui.componentFactory.add(Yw, (n) => {
							const o = t.commands.get(Yw),
								i = new Ju(n);
							return (
								i.set({
									label: e("Underline"),
									icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>',
									keystroke: "CTRL+U",
									tooltip: !0,
									isToggleable: !0,
								}),
								i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"),
								this.listenTo(i, "execute", () => {
									t.execute(Yw), t.editing.view.focus();
								}),
								i
							);
						});
					}
				}
				n(62), n(9);
				class Xw extends wp {}
				(Xw.builtinPlugins = [
					class extends R {
						static get requires() {
							return [Ip];
						}
						static get pluginName() {
							return "Autoformat";
						}
						afterInit() {
							this._addListAutoformats(),
								this._addBasicStylesAutoformats(),
								this._addHeadingAutoformats(),
								this._addBlockQuoteAutoformats(),
								this._addCodeBlockAutoformats(),
								this._addHorizontalLineAutoformats();
						}
						_addListAutoformats() {
							const t = this.editor.commands;
							t.get("bulletedList") &&
								eg(this.editor, this, /^[*-]\s$/, "bulletedList"),
								t.get("numberedList") &&
									eg(this.editor, this, /^1[.|)]\s$/, "numberedList"),
								t.get("todoList") &&
									eg(this.editor, this, /^\[\s?\]\s$/, "todoList"),
								t.get("checkTodoList") &&
									eg(this.editor, this, /^\[\s?x\s?\]\s$/, () => {
										this.editor.execute("todoList"),
											this.editor.execute("checkTodoList");
									});
						}
						_addBasicStylesAutoformats() {
							const t = this.editor.commands;
							if (t.get("bold")) {
								const t = ig(this.editor, "bold");
								ng(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, t),
									ng(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, t);
							}
							if (t.get("italic")) {
								const t = ig(this.editor, "italic");
								ng(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, t),
									ng(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, t);
							}
							if (t.get("code")) {
								const t = ig(this.editor, "code");
								ng(this.editor, this, /(`)([^`]+)(`)$/g, t);
							}
							if (t.get("strikethrough")) {
								const t = ig(this.editor, "strikethrough");
								ng(this.editor, this, /(~~)([^~]+)(~~)$/g, t);
							}
						}
						_addHeadingAutoformats() {
							const t = this.editor.commands.get("heading");
							t &&
								t.modelElements
									.filter((t) => t.match(/^heading[1-6]$/))
									.forEach((e) => {
										const n = e[7],
											o = new RegExp(`^(#{${n}})\\s$`);
										eg(this.editor, this, o, () => {
											if (!t.isEnabled || t.value === e) return !1;
											this.editor.execute("heading", { value: e });
										});
									});
						}
						_addBlockQuoteAutoformats() {
							this.editor.commands.get("blockQuote") &&
								eg(this.editor, this, /^>\s$/, "blockQuote");
						}
						_addCodeBlockAutoformats() {
							const t = this.editor,
								e = t.model.document.selection;
							t.commands.get("codeBlock") &&
								eg(t, this, /^```$/, () => {
									if (e.getFirstPosition().parent.is("element", "listItem"))
										return !1;
									this.editor.execute("codeBlock", {
										usePreviousLanguageChoice: !0,
									});
								});
						}
						_addHorizontalLineAutoformats() {
							this.editor.commands.get("horizontalLine") &&
								eg(this.editor, this, /^---$/, "horizontalLine");
						}
					},
					If,
					class extends R {
						static get requires() {
							return [$f, Uf];
						}
						static get pluginName() {
							return "Bold";
						}
					},
					class extends R {
						static get requires() {
							return [$g, gg, em, Nf, zp, Zg];
						}
						static get pluginName() {
							return "Essentials";
						}
					},
					class extends R {
						static get requires() {
							return [lm, hm];
						}
						static get pluginName() {
							return "Heading";
						}
					},
					class extends R {
						static get requires() {
							return [ym, Dm];
						}
						static get pluginName() {
							return "Italic";
						}
					},
					class extends R {
						static get requires() {
							return [Rm, Wm, If];
						}
						static get pluginName() {
							return "Link";
						}
					},
					class extends R {
						static get requires() {
							return [vk, Ek];
						}
						static get pluginName() {
							return "List";
						}
					},
					class extends R {
						static get requires() {
							return [Gk];
						}
						static get pluginName() {
							return "ListStyle";
						}
						constructor(t) {
							super(t),
								Object(l.b)(
									"The `ListStyle` plugin is obsolete. Use `ListProperties` instead.",
								);
						}
					},
					class extends R {
						constructor(t) {
							super(t), (t.data.processor = new jb(t.data.viewDocument));
						}
						static get pluginName() {
							return "Markdown";
						}
					},
					class extends R {
						toMentionAttribute(t, e) {
							return Ub(t, e);
						}
						static get pluginName() {
							return "Mention";
						}
						static get requires() {
							return [$b, ow];
						}
					},
					class extends R {
						static get pluginName() {
							return "PasteFromOffice";
						}
						static get requires() {
							return [cg];
						}
						init() {
							const t = this.editor,
								e = t.editing.view.document,
								n = [];
							n.push(new yw(e)),
								n.push(new ww(e)),
								t.plugins.get("ClipboardPipeline").on(
									"inputTransformation",
									(o, i) => {
										if (i._isTransformedWithPasteFromOffice) return;
										if (
											t.model.document.selection
												.getFirstPosition()
												.parent.is("element", "codeBlock")
										)
											return;
										const r = i.dataTransfer.getData("text/html"),
											s = n.find((t) => t.isActive(r));
										s &&
											((i._parsedData = Dw(r, e.stylesProcessor)),
											s.execute(i),
											(i._isTransformedWithPasteFromOffice = !0));
									},
									{ priority: "high" },
								);
						}
					},
					class extends R {
						static get pluginName() {
							return "SourceEditing";
						}
						static get requires() {
							return [Ru];
						}
						constructor(t) {
							super(t),
								this.set("isSourceEditingMode", !1),
								(this._elementReplacer = new ea()),
								(this._replacedRoots = new Map()),
								(this._dataFromRoots = new Map());
						}
						init() {
							const t = this.editor,
								e = t.t;
							t.ui.componentFactory.add("sourceEditing", (n) => {
								const o = new Ju(n);
								return (
									o.set({
										label: e("Source"),
										icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 0 5 4.5v15.003h-16V0h11zM3 1.5v3.25l-1.497 1-.003 8 1.5 1v3.254L7.685 18l-.001 1.504H17.5V8.002L16 9.428l-.004-4.22-4.222-3.692L3 1.5z"/><path d="M4.06 6.64a.75.75 0 0 1 .958 1.15l-.085.07L2.29 9.75l2.646 1.89c.302.216.4.62.232.951l-.058.095a.75.75 0 0 1-.951.232l-.095-.058-3.5-2.5V9.14l3.496-2.5zm4.194 6.22a.75.75 0 0 1-.958-1.149l.085-.07 2.643-1.89-2.646-1.89a.75.75 0 0 1-.232-.952l.058-.095a.75.75 0 0 1 .95-.232l.096.058 3.5 2.5v1.22l-3.496 2.5zm7.644-.836 2.122 2.122-5.825 5.809-2.125-.005.003-2.116zm2.539-1.847 1.414 1.414a.5.5 0 0 1 0 .707l-1.06 1.06-2.122-2.12 1.061-1.061a.5.5 0 0 1 .707 0z"/></svg>',
										tooltip: !0,
										withText: !0,
										class: "ck-source-editing-button",
									}),
									o.bind("isOn").to(this, "isSourceEditingMode"),
									o
										.bind("isEnabled")
										.to(
											this,
											"isEnabled",
											t,
											"isReadOnly",
											t.plugins.get(Ru),
											"hasAny",
											(t, e, n) => !!t && !e && !n,
										),
									this.listenTo(o, "execute", () => {
										this.isSourceEditingMode = !this.isSourceEditingMode;
									}),
									o
								);
							}),
								this._isAllowedToHandleSourceEditingMode() &&
									(this.on("change:isSourceEditingMode", (t, e, n) => {
										n
											? (this._showSourceEditing(), this._disableCommands())
											: (this._hideSourceEditing(), this._enableCommands());
									}),
									this.on("change:isEnabled", (t, e, n) =>
										this._handleReadOnlyMode(!n),
									),
									this.listenTo(t, "change:isReadOnly", (t, e, n) =>
										this._handleReadOnlyMode(n),
									)),
								t.data.on(
									"get",
									() => {
										this.isSourceEditingMode && this._updateEditorData();
									},
									{ priority: "high" },
								);
						}
						afterInit() {
							const t = this.editor;
							[
								"RealTimeCollaborativeEditing",
								"CommentsEditing",
								"TrackChangesEditing",
								"RevisionHistory",
							].some((e) => t.plugins.has(e)) &&
								console.warn(
									"You initialized the editor with the source editing feature and at least one of the collaboration features. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the collaboration features.",
								),
								t.plugins.has("RestrictedEditingModeEditing") &&
									console.warn(
										"You initialized the editor with the source editing feature and restricted editing feature. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the restricted editing feature.",
									);
						}
						_showSourceEditing() {
							const t = this.editor,
								e = t.editing.view,
								n = t.model;
							n.change((t) => {
								t.setSelection(null),
									t.removeSelectionAttribute(
										n.document.selection.getAttributeKeys(),
									);
							});
							for (const [n, o] of e.domRoots) {
								const i = Fw(t.data.get({ rootName: n })),
									r = oa(o.ownerDocument, "textarea", {
										rows: "1",
										"aria-label": "Source code editing area",
									}),
									s = oa(
										o.ownerDocument,
										"div",
										{ class: "ck-source-editing-area", "data-value": i },
										[r],
									);
								(r.value = i),
									r.setSelectionRange(0, 0),
									r.addEventListener("input", () => {
										s.dataset.value = r.value;
									}),
									e.change((t) => {
										const o = e.document.getRoot(n);
										t.addClass("ck-hidden", o);
									}),
									t.ui.setEditableElement("sourceEditing:" + n, r),
									this._replacedRoots.set(n, s),
									this._elementReplacer.replace(o, s),
									this._dataFromRoots.set(n, i);
							}
							this._focusSourceEditing();
						}
						_hideSourceEditing() {
							const t = this.editor.editing.view;
							this._updateEditorData(),
								t.change((e) => {
									for (const [n] of this._replacedRoots)
										e.removeClass("ck-hidden", t.document.getRoot(n));
								}),
								this._elementReplacer.restore(),
								this._replacedRoots.clear(),
								this._dataFromRoots.clear(),
								t.focus();
						}
						_updateEditorData() {
							const t = this.editor,
								e = {};
							for (const [t, n] of this._replacedRoots) {
								const o = this._dataFromRoots.get(t),
									i = n.dataset.value;
								o !== i && (e[t] = i);
							}
							Object.keys(e).length &&
								t.data.set(e, { batchType: { isUndoable: !0 } });
						}
						_focusSourceEditing() {
							const t = this.editor,
								[e] = this._replacedRoots.values(),
								n = e.querySelector("textarea");
							(t.editing.view.document.isFocused = !1), n.focus();
						}
						_disableCommands() {
							const t = this.editor;
							for (const e of t.commands.commands()) e.forceDisabled(Pw);
						}
						_enableCommands() {
							const t = this.editor;
							for (const e of t.commands.commands()) e.clearForceDisabled(Pw);
						}
						_handleReadOnlyMode(t) {
							if (this.isSourceEditingMode)
								for (const [, e] of this._replacedRoots)
									e.querySelector("textarea").readOnly = t;
						}
						_isAllowedToHandleSourceEditingMode() {
							const t = this.editor.ui.view.editable;
							return t && !t._hasExternalElement;
						}
					},
					class extends R {
						static get requires() {
							return [zw, Ow];
						}
						static get pluginName() {
							return "Strikethrough";
						}
					},
					class extends R {
						static get requires() {
							return ["Delete", "Input"];
						}
						static get pluginName() {
							return "TextTransformation";
						}
						constructor(t) {
							super(t),
								t.config.define("typing", { transformations: { include: Kp } });
						}
						init() {
							const t = this.editor.model.document.selection;
							t.on("change:range", () => {
								this.isEnabled = !t.anchor.parent.is("element", "codeBlock");
							}),
								this._enableTransformationWatchers();
						}
						_enableTransformationWatchers() {
							const t = this.editor,
								e = t.model,
								n = t.plugins.get("Delete"),
								o = (function (t) {
									const e = t.extra || [],
										n = t.remove || [],
										o = (t) => !n.includes(t);
									return (function (t) {
										const e = new Set();
										for (const n of t)
											if ("string" == typeof n && Wp[n])
												for (const t of Wp[n]) e.add(t);
											else e.add(n);
										return Array.from(e);
									})(t.include.concat(e).filter(o))
										.filter(o)
										.map((t) => ("string" == typeof t && Up[t] ? Up[t] : t))
										.filter((t) => "object" == typeof t)
										.map((t) => ({ from: Gp(t.from), to: Jp(t.to) }));
								})(t.config.get("typing.transformations")),
								i = new Op(t.model, (t) => {
									for (const e of o) {
										if (e.from.test(t)) return { normalizedTransformation: e };
									}
								});
							i.on("matched:data", (t, o) => {
								if (!o.batch.isTyping) return;
								const { from: i, to: r } = o.normalizedTransformation,
									s = i.exec(o.text),
									a = r(s.slice(1)),
									c = o.range;
								let l = s.index;
								e.enqueueChange((t) => {
									for (let n = 1; n < s.length; n++) {
										const o = s[n],
											i = a[n - 1];
										if (null == i) {
											l += o.length;
											continue;
										}
										const r = c.start.getShiftedBy(l),
											d = e.createRange(r, r.getShiftedBy(o.length)),
											u = Yp(r);
										e.insertContent(t.createText(i, u), d), (l += i.length);
									}
									e.enqueueChange(() => {
										n.requestUndoOnBackspace();
									});
								});
							}),
								i.bind("isEnabled").to(this);
						}
					},
					class extends R {
						static get requires() {
							return [qw, Uw];
						}
						static get pluginName() {
							return "TodoList";
						}
					},
					class extends R {
						static get requires() {
							return [Jw, Qw];
						}
						static get pluginName() {
							return "Underline";
						}
					},
				]),
					(Xw.defaultConfig = {
						toolbar: { items: ["link", "bold", "italic"] },
						language: "en",
						image: { toolbar: ["imageTextAlternative"] },
					});
				e.default = Xw;
			},
		]).default;
	});
//# sourceMappingURL=ckeditor.js.map
